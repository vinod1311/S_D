;(function() {
var browser, utils, error, le, core_common, css, animator, constants, behaviour, layout_new, layout2, error_tip, vanillaquery, note_support, locale, note_validation, punycode, location, click, event_emitter, storage, storage_cache, site_data, font_loader, excel_utils, excel_parser_core, note2, note_controller2, visibility, spacer, show_queue2, mimir, tracker, evaluator, cohorts, rendermode, preprocessor, badge, cover_screen, rrhandler, notes_manager, session_tracker, core_boot;
(function () {
  /*
  	
  		Don't try split a hair or be too creative :-)
  
  		We generally have only 3 device types: phone, tablet, desktop
  
  		We have the following platforms: mac, linux, windows, ios, android and winphone
  		NB! winphone and windows are set to 'true' at the same time
  		
  		There is NO way to detect and no reason to seek for 'touch device'. A device can have touch capabilites, but
  		it also can have others. For example ios is in fact pure touch device, but andrid is not (one can attach mouse
  		to usb port). Also we have touch enabled windows laptops where on Chrome and on Firefox we have touch events and
  		mouse events. On MS Surface we have pointer events which can be too both, mouse and touch (and why not pen too)
  
  	*/
  var win = this;
  var doc = win.document;
  var vendors = [
    'Webkit',
    'ms',
    'Moz'
  ];
  var div = doc.createElement('div');
  var prop;
  // thx Modernizr
  function getVendor(prop) {
    var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
    var len;
    if (prop in div.style) {
      return '';
    }
    for (len = vendors.length; len--;) {
      if (vendors[len] + upper in div.style) {
        return vendors[len];
      }
    }
    return false;
  }
  var jsVendor = getVendor('transform');
  // for Javascript
  var cachedProps = {};
  function prefixStyle(prop, vendor) {
    vendor || (vendor = jsVendor);
    if (!cachedProps[vendor])
      cachedProps[vendor] = {};
    var p = cachedProps[vendor][prop];
    if (p === undefined) {
      p = cachedProps[vendor][prop] = vendor.length ? vendor + prop.charAt(0).toUpperCase() + prop.substr(1) : prop[0].toLowerCase() + prop.substr(1);
    }
    return p;
  }
  var is = {
    standalone: win.navigator.standalone,
    retina: win.devicePixelRatio >= 1.5
  };
  var ua = win.navigator.userAgent.toLowerCase();
  var botRegex = /adsbot-google|googlebot|mediapartners-google|googleweblight|google page speed insights|headlesschrome/gi;
  is.bot = botRegex.test(ua);
  // thx MooTools
  //https://github.com/mootools/mootools-core/blob/master/Source/Browser/Browser.js
  var parseUA = function () {
    // chrome is included in the edge UA, so need to check for edge first,
    // before checking if it's chrome.
    var UA = ua.match(/(edge|edg)[\s\/:]([\w\d\.]+)/);
    if (!UA) {
      UA = ua.match(/(opera|ie|firefox|chrome|trident|crios|version)[\s\/:]([\w\d\.]+)?.*?(safari|(?:rv[\s\/:]|version[\s\/:])([\w\d\.]+)|$)/) || [
        null,
        'unknown',
        0
      ];
    }
    if (UA[1] == 'trident') {
      UA[1] = 'ie';
      if (UA[4])
        UA[2] = UA[4];
    } else if (UA[1] == 'crios') {
      UA[1] = 'chrome';
    }
    var platform;
    if (/iemobile|windows phone/i.test(win.navigator.appVersion)) {
      platform = 'winphone';
    } else {
      platform = ua.match(/ip(?:ad|od|hone)/) ? 'ios' : (ua.match(/(?:webos|android)/) || ua.match(/mac|win|linux|cros/) || ['other'])[0];
    }
    if (!platform || platform == 'other') {
      // regex does not give us platform on newest Edge
      platform = win.navigator.platform;
      if (/mac/i.test(platform))
        platform = 'mac';
      if (/win/i.test(platform))
        platform = 'windows';
    }
    if (platform == 'win')
      platform = 'windows';
    return {
      name: UA[1] == 'version' ? UA[3] : UA[1],
      version: parseFloat(UA[1] == 'opera' && UA[4] ? UA[4] : UA[2]),
      platform: platform
    };
  }();
  if (parseUA.name != 'unknown')
    is[parseUA.name] = true;
  is.version = parseUA.version;
  is.name = parseUA.name;
  is.platform = parseUA.platform;
  if (/edg/.test(is.name))
    is.name = 'edge';
  // new edge is equal to chrome, so let's call it as such, we still have is.edg or is.edge set if needed
  if (is.name == 'edge' && is.version > 50) {
    is.name = 'chrome';
    is[is.name] = true;
  }
  if (parseUA.name == 'ie' && doc.documentMode)
    is.version = doc.documentMode;
  if (doc.compatMode == 'BackCompat') {
    is.quirks = true;
    is.version = 1;
  }
  is[parseUA.platform] = true;
  is.windows = is.windows || is.winphone;
  is.mozilla = is.firefox;
  is.webkit = is.safari || is.chrome;
  if (is.webkit && 'webkitAnimation' in div.style) {
    jsVendor = 'Webkit';
  }
  // main 'fuzzy' logic
  is.desktop = !(is.android || is.ios || is.winphone);
  // TODO: keep an eye on this detection
  // this is the hairiest part, Android is what it is and UA string is what it is
  if (is.android) {
    is.tablet = !/mobile/i.test(ua);
    is.genuineAndroid = !/intel/i.test(win.navigator.platform);
  }
  if (is.ios) {
    is.tablet = /ipad/i.test(ua);
    div.style.setProperty('-webkit-overflow-scrolling', 'touch');
    // sometimes we need to know if we are on genuine iOS, not chrome emulator
    is.genuineApple = div.style.getPropertyValue('-webkit-overflow-scrolling') == 'touch';
  }
  is.phone = !is.desktop && !is.tablet;
  is.device = is.tablet ? 'tablet' : is.phone ? 'phone' : 'desktop';
  var has = {
    orientationchange: 'onorientationchange' in win,
    threeD: prefixStyle('perspective') in doc.documentElement.style,
    // remember, this prop say if device HAS touch capability, not if it is pure touch device (without mouse)
    touch: 'ontouchstart' in win || win.navigator.msMaxTouchPoints > 0,
    transform: jsVendor === false ? false : true,
    animation: getVendor('animationName') === false ? false : true,
    pointer: !!win.PointerEvent,
    pointerGestures: !!win.MSGesture,
    pointerEvents: function (style) {
      return 'pointerEvents' in style ? (style.pointerEvents = 'auto', style.pointerEvents = 'foo', style.pointerEvents == 'auto') : false;
    }(div.style)
  };
  /*
  	if (!has.touch && is.ios) {
  		// that is Safari in responsive mode
  		is.ios = false;
  		is.desktop = true;
  	}
  	*/
  if (is.ie && is.version <= 10) {
    // i'm interested only HTML pointer-events, not SVG ones
    has.pointerEvents = false;
  }
  var resizeEvent = 'onorientationchange' in win ? 'orientationchange' : 'resize';
  var transitionEnd;
  var animationEnd;
  //https://gist.github.com/O-Zone/7230245
  var transitions = {
    transition: 'transitionend',
    WebkitTransition: 'webkitTransitionEnd',
    MozTransition: 'transitionend'
  };
  for (prop in transitions) {
    if (div.style[prop] !== undefined) {
      transitionEnd = transitions[prop];
      break;
    }
  }
  var animations = {
    animation: 'animationend',
    WebkitAnimation: 'webkitAnimationEnd',
    MozAnimation: 'animationend'
  };
  for (prop in animations) {
    if (div.style[prop] !== undefined) {
      animationEnd = animations[prop];
      break;
    }
  }
  var cssVendor = jsVendor.length ? '-' + jsVendor.toLowerCase() + '-' : '';
  function modifierKey(event) {
    return event.which == 16 || event.which == 17 || event.which == 18 || event.which == 91 ? event.which : event.ctrlKey && 17 || event.shiftKey && 16 || event.altKey && 18 || event.metaKey && 91 || 0;
  }
  function mouseButton(event) {
    var r = 'right';
    var m = 'middle';
    // event.button
    //-1: No button pressed
    //0: Main button pressed, usually the left button
    //1: Auxiliary button pressed, usually the wheel button or themiddle button (if present)
    //2: Secondary button pressed, usually the right button
    //3: Fourth button, typically the Browser Back button
    //4: Fifth button, typically the Browser Forward button
    // event.buttons
    //0 No buttons are pressed
    //1 Left mouse button press, or Touch contact (PointerEvent only), or Pen contact (PointerEvent only)
    //2 Right mouse button press, or Pen contact with barrel button pressed, or(PointerEvent only)
    //4 Middle mouse button press
    //8 X1 (back) mouse button press (PointerEvent only)
    //16 X2 (forward) mouse button press (PointerEvent only)
    //32 Pen contact with eraser button pressed (PointerEvent only)
    // modern IE and FF
    if (event.buttons !== undefined && event.buttons !== 0) {
      if (event.buttons == 2) {
        return r;
      }
      if (event.buttons == 4) {
        return m;
      }
    } else {
      if (event.button == 2) {
        return r;
      }
      if (event.button == 1) {
        return m;
      }
      if (is.mac && modifierKey(event) == 17) {
        return r;
      }
    }
    // MS Edge (chrome) has difficulties to detect right clikc on mac
    return is.mac && event.ctrlKey ? r : 'left';
  }
  function getOtherVendorList() {
    var len;
    var list = [];
    for (len = vendors.length; len--;)
      if (vendors[len] != jsVendor)
        list.push(vendors[len]);
    if (jsVendor.length)
      list.push('');
    return list;
  }
  function language() {
    return win.navigator.language || win.navigator.userLanguage;
  }
  function timezoneOffSet() {
    return new Date().getTimezoneOffset();
  }
  var user = {
    language: language,
    timezoneOffSet: timezoneOffSet
  };
  //Dimension calculations
  /*	
  	window.inner... is immune to the zoom, always the same
  	html, body {
  		zoom: .75;
  	}
  	win.innerWidth: 536
  	doc.body.getBoundingClientRect().width: 926/953
  	doc.documentElement.getBoundingClientRect().width: 695/715
  	doc.documentElement.clientWidth: 521/536
  	doc.documentElement.offsetWidth: 695/715
  
  	html {
  		zoom: .75;
  	}
  	win.innerWidth: 536
  	doc.body.getBoundingClientRect().width: 695/715 
  	doc.documentElement.getBoundingClientRect().width:	695/715
  	doc.documentElement.clientWidth: 521/536 
  	doc.documentElement.offsetWidth: 695/715  
  
  	body {
  	   zoom: .75;
  	}	
  
  	win.innerWidth: 536
  	doc.body.getBoundingClientRect().width: 695/715 
  	doc.documentElement.getBoundingClientRect().width:	521/536
  	doc.documentElement.clientWidth: 521/536 
  	doc.documentElement.offsetWidth: 521/536  
  	
  */
  function innerHeight() {
    return win.innerHeight || (doc.documentElement || doc.body).clientHeight || 0;
  }
  function innerWidth() {
    return win.innerWidth || (doc.documentElement || doc.body).clientWidth || 0;
  }
  function orientation() {
    /* orientation can lie ....  Samsumg use orientation 0 for it's defualt postions which is landscape on some tablet i.e. Galaxy tab. Needs to rely on calcs 
    http://pioul.fr/cross-device-cross-browser-portrait-landscape-detection
    var o = win.screen.orientation ? win.screen.orientation.angle : win.orientation;
    if ( o === undefined) o = win.innerWidth < win.innerHeight ? 0 : 90;
    return o; */
    return innerWidth() < innerHeight() ? 0 : 90;
  }
  function isLandscape() {
    return orientation() === 90;
  }
  function userAgent() {
    return win.navigator.userAgent;
  }
  function getBodyRealDimensions(ignoreScrollX, ignoreScrollY, b, h) {
    b || (b = doc.body);
    h || (h = doc.documentElement);
    var hs = win.getComputedStyle(h);
    var bs = win.getComputedStyle(b);
    var height = Math.max(b.offsetHeight, h.offsetHeight, b.clientHeight, h.clientHeight);
    var width = Math.max(b.offsetWidth, h.offsetWidth, b.clientWidth, h.clientWidth);
    // if scrolling is allowed ( as usual )
    // the beef here is that on some app-like mobile sites body scrolling is disabled
    if (!(hs.overflowY == 'hidden' || bs.overflowY == 'hidden') && !ignoreScrollY) {
      height = Math.max(height, b.scrollHeight, h.scrollHeight);
    }
    if (!(hs.overflowX == 'hidden' || bs.overflowX == 'hidden') && !ignoreScrollX) {
      width = Math.max(width, b.scrollWidth, h.scrollWidth);
    }
    return {
      width: width,
      height: height
    };
  }
  function scrollTop() {
    return win.pageYOffset || (doc.documentElement || doc.body.parentNode || doc.body).scrollTop || 0;
  }
  var scroll = {
    top: scrollTop,
    // gets percentage scrolled (ie: 80 or no scroll bars will return 100)
    pct: function () {
      var trackLength = getBodyRealDimensions().height - innerHeight();
      return trackLength === 0 ? 100 : Math.floor(scrollTop() / trackLength * 100);
    }
  };
  var dim = {
    screen: {
      //Apple devices use phycical dimensions so they never chagne on rotation
      width: function () {
        return Math[isLandscape() ? 'max' : 'min'](win.screen.width, win.screen.height);
      },
      height: function () {
        return Math[isLandscape() ? 'min' : 'max'](win.screen.width, win.screen.height);
      },
      availWidth: function () {
        return Math[isLandscape() ? 'max' : 'min'](win.screen.availWidth, win.screen.availHeight);
      },
      availHeight: function () {
        return Math[isLandscape() ? 'min' : 'max'](win.screen.availWidth, win.screen.availHeight);
      }
    },
    // this is used only in translateViewportUnitValue, either screen or what specified in meta.viewport
    content: {
      width: 0,
      height: 0
    },
    win: {
      width: innerWidth,
      height: innerHeight
    },
    doc: {
      dims: getBodyRealDimensions,
      width: function (ignoreScrollX, b, h) {
        return getBodyRealDimensions(ignoreScrollX, true, b, h).width;
      },
      height: function (ignoreScrollY, b, h) {
        return getBodyRealDimensions(true, ignoreScrollY, b, h).height;
      }
    }
  };
  var cachedSystemScrollbarWidth;
  function systemScrollbarWidth() {
    var node;
    // system scrollbar width
    if (undefined !== cachedSystemScrollbarWidth) {
      return cachedSystemScrollbarWidth;
    }
    cachedSystemScrollbarWidth = 0;
    if (!has.touch) {
      doc.body.insertAdjacentHTML('beforeend', '<div style="visibility:hidden;overflow-y:scroll;">blaah</div>');
      node = doc.body.lastElementChild;
      cachedSystemScrollbarWidth = node.offsetWidth - node.clientWidth;
      node.parentNode.removeChild(node);
    }
    return cachedSystemScrollbarWidth;
  }
  var meta = doc.querySelector('meta[name=viewport], meta[id=viewport]');
  function isPositionValue(position, desired) {
    if (position && desired == 'fixed') {
      return position == 'fixed' || ~position.indexOf('sticky');
    }
  }
  function getPositionValue(position) {
    if (isPositionValue(position, 'fixed')) {
      if (is.desktop && is.safari) {
        return '-webkit-sticky';
      }
      //			if (is.ios || is.safari) {
      //				return is.ios && !is.genuineApple ? 'sticky' : '-webkit-sticky';
      //			}
      return 'fixed';
    }
    return position;
  }
  // to be real mobile site this must return true
  function notScaledMobileContent() {
    //return dim.screen.width() === dim.win.width();
    return isEqual(dim.screen.width(), dim.win.width() * getDocumentScale(), 1);
  }
  function getDocumentWidth() {
    return dim.doc.width(!is.desktop, doc.body, doc.documentElement);
  }
  function getDocumentScale(custom) {
    var documentWidth = getDocumentWidth();
    if (is.phone && custom !== undefined) {
      if (Array.isArray(custom)) {
        // in case of array [portrait, landscape]
        documentWidth = Number(custom[isLandscape() ? 1 : 0]);
      } else {
        // old, just a number
        if (Number(custom) === custom && custom > 0)
          documentWidth = custom;
      }  // else just use documentWidth - there was a case when after a few seconds all vent 'normal', so just using true in isRealMobileSite does the trick
    }
    return documentWidth / dim.win.width();
  }
  function isEqual(a, b, p) {
    p || (p = 0.1);
    return Math.abs(a - b) <= p;
  }
  // we avoid launcing boxes on landscape on iphone when not in full screen mode (e.g. scrolled down a little)
  function isAddressBarVisible() {
    // this check is for iPhone only
    if (!(is.phone && is.ios && is.safari))
      return false;
    if (!isLandscape())
      return false;
    return !isEqual(getDocumentWidth() / dim.screen.width() * dim.screen.availHeight(), dim.win.height(), 1);
  }
  // used to keep boxes stretch awfully on landscape tablet e.g. to keep same size with portrait
  function minimalScreenDimension() {
    return Math.min(dim.screen.width(), dim.screen.height());
  }
  var exports = {
    screenWidth: dim.screen.width,
    screenHeight: dim.screen.height,
    windowWidth: innerWidth,
    windowHeight: innerHeight,
    minimalScreenDimension: minimalScreenDimension,
    isAddressBarVisible: isAddressBarVisible,
    getDocumentScale: getDocumentScale,
    getDocumentWidth: getDocumentWidth,
    notScaledMobileContent: notScaledMobileContent,
    isPositionValue: isPositionValue,
    getPositionValue: getPositionValue,
    systemScrollbarWidth: systemScrollbarWidth,
    is: is,
    has: has,
    jsVendor: jsVendor,
    otherVendors: getOtherVendorList,
    // this is list of vendors we need to add to make it understandable for all supported browesrs
    cssVendor: cssVendor,
    prefixStyle: prefixStyle,
    transitionEnd: transitionEnd,
    animationEnd: animationEnd,
    resizeEvent: resizeEvent,
    mouseButton: mouseButton,
    //orientation: orientation, Use isLandscape instead
    isLandscape: isLandscape,
    //dim: dim,
    scroll: scroll,
    user: user,
    userAgent: userAgent
  };
  browser = function () {
    dim.content.width = dim.screen.width();
    dim.content.height = dim.screen.height();
    // if on mobile content width is set to number, try to parse it out and adjust dim.content
    if (!is.desktop && meta && meta.content) {
      var w = meta.content.split(',').filter(function (str) {
        if (~str.indexOf('width'))
          return 1;
      })[0];
      if (w)
        w = parseInt(w.split('=')[1], 10);
      if (w === Number(w)) {
        dim.content.width = w;
        dim.content.height = dim.screen.height() / (dim.screen.width() / w);
      }
    }
    return exports;
  }();
}.call(this));
// common
(function () {
  var win = this;
  var doc = win.document;
  var exports = {};
  var frame;
  var listener;
  if (win.location && !win.location.origin) {
    win.location.origin = win.location.protocol + '//' + win.location.hostname + (win.location.port ? ':' + win.location.port : '');
  }
  if (!doc.head) {
    doc.head = doc.getElementsByTagName('head')[0];
  }
  var anchorId = 'sleeknote';
  function anchor(id) {
    var anchor;
    if (exports.JSON) {
      anchor = gid(anchorId);
    }
    if (!anchor) {
      anchor = this.document.getElementById(anchorId);
      // keep that one always as last as some Angular miracles will cough
      if (!anchor)
        this.document.body.insertAdjacentHTML('beforeend', '<span id=' + anchorId + ' aria-hidden="true"></span>');
      anchor = this.document.getElementById(anchorId);
    }
    if (id)
      anchorId = anchor.id = id;
    return anchor;
  }
  var sandboxId = randomName();
  function sandbox() {
    return gid(sandboxId);
  }
  function getFrameWindow() {
    //PP: this is a bit mystery what happens in template functions
    // https://sleeknotestaticcontent.sleeknote.com/note-templates/201801-3.js?1525176792305
    return frame && frame.contentWindow || this;
  }
  if (this.document.body) {
    // insert iframe into anchor if available
    var target = anchor.call(this);
    target.insertAdjacentHTML('beforeend', '<iframe id="' + sandboxId + '" name="' + sandboxId + '" style="display:none!important"></iframe>');
    frame = target.lastElementChild;
    function getFunc(target, name) {
      if (!target)
        return;
      switch (target.nodeType) {
      case 0:
        return function () {
        };
      case 1:
        return getFrameWindow().Element.prototype[name];
      case 9:
        return getFrameWindow().Document.prototype[name];
      case 11:
        return getFrameWindow().DocumentFragment.prototype[name] || function () {
        };
      // fragment has only qs's
      default:
        console.warn('unknown node type: ' + target.nodeType);
        console.trace();
        return function () {
        };
        break;
      }
    }
    // those methods are not universal
    [
      'querySelectorAll',
      'querySelector',
      'getElementsByClassName',
      'getElementsByTagName'
    ].forEach(function (name) {
      exports[name] = function (target, selector) {
        try {
          return getFunc(target, name).call(target, selector);
        } catch (e) {
          debugger;
        }
      };
    });
  }
  listener = function (element, func, handler, capture) {
    element === element + '' && (element = exports.getElementById(element));
    return function self(event) {
      element[func + 'EventListener'](event, handler, !!capture);
      return self;
    };
  };
  exports.JSON = {
    parse: function () {
      return getFrameWindow().JSON.parse.apply(win, arguments);
    },
    stringify: function () {
      return getFrameWindow().JSON.stringify.apply(win, arguments);
    }
  };
  [
    'XMLHttpRequest',
    'decodeURIComponent',
    'encodeURIComponent'
  ].forEach(function (name) {
    exports[name] = function () {
      return getFrameWindow()[name].apply(win, arguments);
    };
  }, this);
  [
    'getElementById',
    'createElement',
    'createDocumentFragment'
  ].forEach(function (name) {
    exports[name] = function () {
      return getFrameWindow().document[name].apply(doc, arguments);
    };
  }, this);
  exports.getComputedStyle = function (element, pseudoElt) {
    return getFrameWindow().getComputedStyle.call(win, element, pseudoElt);
  };
  function Objectkeys(obj) {
    try {
      return getFrameWindow().Object.keys(obj);
    } catch (e) {
      console.warn('frame!');
      var hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !{ toString: null }.propertyIsEnumerable('toString'), dontEnums = [
          'toString',
          'toLocaleString',
          'valueOf',
          'hasOwnProperty',
          'isPrototypeOf',
          'propertyIsEnumerable',
          'constructor'
        ], dontEnumsLength = dontEnums.length;
      if (typeof obj !== 'function' && (typeof obj !== 'object' || obj === null)) {
        throw new TypeError('Object.keys called on non-object');
      }
      var result = [], prop, i;
      for (prop in obj) {
        if (hasOwnProperty.call(obj, prop)) {
          result.push(prop);
        }
      }
      if (hasDontEnumBug) {
        for (i = 0; i < dontEnumsLength; i++) {
          if (hasOwnProperty.call(obj, dontEnums[i])) {
            result.push(dontEnums[i]);
          }
        }
      }
      return result;
    }
  }
  function typeStr(val) {
    return Object.prototype.toString.call(val).slice(8, -1).toLowerCase();
  }
  function extend() {
    /* jshint ignore:start */
    var p;
    var t;
    var src;
    var dst;
    var len = arguments.length;
    var i;
    // this allows easy clonig, you may use it foo = extend(bar) to do that
    if (len == 1) {
      t = typeStr(arguments[0]);
      if (t == 'array') {
        dst = [];
      }
      if (t == 'object') {
        dst = {};
      }
      i = 0;
    } else {
      dst = arguments[0];
      i = 1;
    }
    for (; i < len; i++) {
      src = arguments[i];
      // just pass non extendables through
      t = typeStr(src);
      if (!(t == 'array' || t == 'object')) {
        dst = src;
      } else {
        for (p in src) {
          t = typeStr(src[p]);
          dst[p] = t == 'array' || t == 'object' ? extend(dst[p] ? dst[p] : t == 'array' ? [] : {}, src[p]) : src[p];
        }
      }
    }
    return dst;  /* jshint ignore:end */
  }
  function gtag(tagName) {
    return tagName.nodeName ? tagName : exports.getElementsByTagName(doc, tagName)[0];
  }
  function gid(id) {
    return id ? id.nodeName ? id : doc.getElementById(id) : null;
  }
  function qsa(selector, element) {
    if (element && !element.nodeName) {
      console.warn('QSA second argument must be Element', element);
      return [];
    }
    return Array.prototype.slice.call(exports.querySelectorAll(element || doc, selector));
  }
  function qs(selector, element) {
    return qsa(selector, element)[0];
  }
  function stopPropagation(event) {
    if (event.stopPropagation) {
      event.stopPropagation();
    } else if (win.event) {
      win.event.cancelBubble = true;
    }
  }
  function preventDefault(event) {
    if (event.preventDefault) {
      event.preventDefault();
    } else if (win.event) {
      win.event.returnValue = false;
    }
  }
  function normalizedEvent(event) {
    event = event || win.event;
    // fixes borrowed from jQuery
    if (null === event.which)
      event.which = event.charCode !== null ? event.charCode : event.keyCode;
    if (!event.target)
      event.target = event.srcElement || doc;
    if (event.target.nodeType === 3)
      event.target = event.target.parentNode;
    if (!event.relatedTarget && event.fromElement)
      event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
    return event;
  }
  function objectSize(obj) {
    return Objectkeys(obj).length;
  }
  function getStyle(node, prop) {
    var gs = exports.getComputedStyle;
    var style = gs ? gs(node, null) : null;
    return style ? style[prop] : node.currentStyle[prop];
  }
  function removeNode(node) {
    if (!node)
      return;
    if (!node.nodeName)
      node = gid(node);
    if (node && node.parentNode)
      node.parentNode.removeChild(node);
  }
  function offsetRect(elem) {
    var docElem = doc.documentElement;
    var body = doc.body;
    var box;
    if (elem && elem.nodeName) {
      box = elem.getBoundingClientRect();
    } else {
      // there is now an option to pass getBoundingClientRect() too
      box = elem || {};
    }
    var top = (box.top || 0) + (docElem.scrollTop || body && body.scrollTop) - (docElem.clientTop || body.clientTop || 0);
    var left = (box.left || 0) + (docElem.scrollLeft || body && body.scrollLeft) - (docElem.clientLeft || body.clientLeft || 0);
    return {
      top: top,
      left: left,
      right: left + box.width || 0,
      bottom: top + box.height || 0,
      width: box.width || 0,
      height: box.height || 0
    };
  }
  function eventXY(e, i) {
    var x;
    var y;
    i || (i = 0);
    if (e.changedTouches && e.changedTouches.length > i) {
      x = e.changedTouches[i].pageX;
      y = e.changedTouches[i].pageY;
    } else if (e.targetTouches && e.targetTouches.length > i) {
      x = e.targetTouches[i].pageX;
      y = e.targetTouches[i].pageY;
    } else if (e.pageX || e.pageY) {
      x = e.pageX;
      y = e.pageY;
    } else if (e.clientX || e.clientY) {
      x = e.clientX + doc.body.scrollLeft + doc.documentElement.scrollLeft;
      y = e.clientY + doc.body.scrollTop + doc.documentElement.scrollTop;
    }
    return {
      x: x,
      y: y
    };
  }
  // interval	- throttle firing interval
  // fn 		- callback to be called, max arguments on throttle callback is 3 ( safe bet,
  //				to get rid of arguments garbage, add more if needed )
  // 			  on most cases only one is enough as when acting as event handler ( scroll, resize, keyup )
  //			  throttle phase is passed on as 4th parameter - 1 as first, 2 as throttling, 3 as last
  //
  // context 	- callbcak calling context, if needed
  // first 	- whether to call callback at first throtle call, default false
  // after 	- whether to call callback only after last call to throttle
  function throttle(interval, fn, context, first, after) {
    context || (context = win);
    function Throttle() {
      this.lastTime = 0;
      this.timer = 0;
      this.after = this.after.bind(this);
      this.run = this.run.bind(this);
      // <=IE9 does not support setTimeout arguments
      // hardcoded max 3 arguments
      this.a1;
      this.a2;
      this.a3;
    }
    Throttle.prototype = {
      after: function () {
        fn.call(context, this.a1, this.a2, this.a3, 3);
        this.lastTime = 0;
        this.timer = 0;
      },
      run: function () {
        var now = +new Date();
        var phase = first && !this.lastTime ? 1 : now - this.lastTime > interval ? 2 : 0;
        if (phase) {
          if (!after) {
            fn.call(context, this.a1, this.a2, this.a3, phase);
            this.lastTime = now;
          }
          this.timer && win.clearTimeout(this.timer);
          // have a little 'breathing room', if the after one's interval is too close
          // to interval we have possibility to launcing it prematurely
          this.timer = win.setTimeout(this.after, interval * 1.25);
        }
      },
      throttle: function (a1, a2, a3) {
        this.a1 = a1;
        this.a2 = a2;
        this.a3 = a3;
        win.setTimeout(this.run, 0);
      }
    };
    var T = new Throttle();
    return T.throttle.bind(T);
  }
  function applyOptions(options) {
    var prop;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    if (options)
      for (prop in options)
        if (hasOwnProperty.call(options, prop))
          this[prop] = options[prop];
  }
  /*
  		simple template function, strings inside {} will be replaced, not matched {} will be erased
  		@str: template string a'la 'foo{bar}{blaah}{bar}'
  		@data: array or object of values to be substituted
  
  		template('foo{bar}{blaah}{bar}', {bar: 1})
  		// 'foo11'
  
  		template('foo{1}{0}{1}', [2])
  		// 'foo2'
  
  	*/
  function template(str, data) {
    var k = Array.isArray(data) ? data.map(function (x, i) {
      return i;
    }) : Objectkeys(data);
    var l = k.length;
    while (l--) {
      str = str.replace(new RegExp('\\{' + k[l] + '\\}', 'g'), data[k[l]]);
    }
    return str.replace(/\{\w*\}/g, '');
  }
  function insertHTML(element, html, where) {
    if (!element || !element.nodeName)
      return null;
    // all DOM functions return null
    where || (where = 'beforeend');
    /*
    
    		*/
    var returnElement;
    if (where == 'afterbegin') {
      //Just inside the element, before its first child.
      returnElement = element.firstElementChild;
    } else if (where == 'afterend') {
      // new html will be inserted before returnEelemnt
      returnElement = element.nextElementSibling;
    }
    // supports array of strings too
    element.insertAdjacentHTML(where, Array.isArray(html) ? html.join('') : html);
    if (where == 'beforebegin') {
      //Before the element itself.
      return element.previousElementSibling;
    } else if (where == 'afterbegin') {
      //Just inside the element, before its first child.
      return returnElement ? returnElement.previousElementSibling : element.lastElementChild;
    } else if (where == 'beforeend') {
      //Just inside the element, after its last child.
      return element.lastElementChild;
    } else if (where == 'afterend') {
      // After the element itself.
      return returnElement ? returnElement.previousElementSibling : element.parentNode.lastElementChild;
    }
  }
  function replaceHTML(replaceElem, html) {
    var parent = replaceElem.parentNode;
    //TODO: We should add support for replacing with multiple same level elements, eg: <span></span><div></div>
    if (parent) {
      var d = exports.createElement.call(doc, 'div');
      d.innerHTML = html;
      parent.replaceChild(d.children[0], replaceElem);
    }
  }
  // thank's Dmitry
  function isNumeric(num) {
    //if ( typeStr(num) == 'object' ) debugger;
    return !/^(NaN|-?Infinity)$/.test(+num);
  }
  function isFunction(functionToCheck) {
    return typeStr(functionToCheck) == 'function';
  }
  function loadScript(url, callback, id, target) {
    target || (target = doc);
    var script = exports.createElement.call(target, 'script');
    script.type = 'text/javascript';
    script.async = true;
    script.defer = true;
    function done() {
      callback && callback.call(target.defaultView, url, id);
    }
    if (id) {
      if (gid(id)) {
        done();
      } else {
        script.id = id;
      }
    }
    if (script.readyState) {
      //IE
      script.onreadystatechange = function () {
        if (script.readyState == 'loaded' || script.readyState == 'complete') {
          script.onreadystatechange = null;
          done();
        }
      };
    } else {
      //Others
      script.onload = done;
    }
    script.src = url;
    target.head.insertBefore(script, target.head.firstChild);
  }
  function getHashParams(url) {
    var i = 0;
    var pair;
    var params = {};
    url = url + '' || (url = exports.getElementsByTagName('script')) && url.item(url.length - 1).src;
    if ((url = ([url.split('#')[1]] + '').split('&'))[0]) {
      for (; i < url.length; i++) {
        pair = url[i].split('=', 2);
        params[pair[0]] = pair[1] ? exports.decodeURIComponent(pair[1].replace(/\+/g, ' ')) : undefined;
      }
    }
    return params;
  }
  function empty(x) {
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    // undefined, '', null, 0, empty array
    if (!x || x.length === 0) {
      return true;
    }
    var type = typeStr(x);
    if (type == 'array')
      return;
    // empty {}
    if (type == 'object') {
      for (var n in x) {
        if (hasOwnProperty.call(x, n)) {
          return false;
        }
      }
      return true;
    }
    // convert to string and match single non-space character
    return !(x + '').match(/\S/);
  }
  var html = doc.documentElement;
  var matchesSel = function (func) {
    if (func) {
      return function (node, selector) {
        return func.call(node, selector);
      };
    } else {
      return function (node, selector) {
        var m = node.parentNode ? exports.querySelectorAll(node.parentNode, selector) : [];
        var l = m.length;
        while (l--) {
          if (m[l] === node) {
            return true;
          }
        }
      };
    }
  }(html.matches || html.matchesSelector || html.webkitMatchesSelector || html.msMatchesSelector || html.mozMatchesSelector || html.oMatchesSelector);
  // matches jQuery closest() http://api.jquery.com/closest/
  function querySelectorClosest(node, selector) {
    var n = node;
    if (!node)
      return null;
    while (n !== node.ownerDocument && !matchesSel(n, selector)) {
      n = n.parentNode;
    }
    // to match behaviour of DOM functions, return null here
    return n.ownerDocument ? n : null;
  }
  function getHostname(url) {
    function hostName(str) {
      if (hostName.link === undefined)
        hostName.link = exports.createElement.call(doc, 'a');
      hostName.link.href = str.split('://').length == 2 ? str : win.location.protocol + '//' + str;
      return String(hostName.link.host);
    }
    return hostName(url);
  }
  function getQueryVarByName(name) {
    name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
    var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
    var results = regex.exec(win.location.search || win.location.hash);
    return results ? exports.decodeURIComponent(results[1].replace(/\+/g, ' ')) : '';
  }
  function trim(text) {
    return !text ? '' : (text + '').replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
  }
  function createDocumentFragmentFromHTML(html, element) {
    element || (element = exports.createElement.call(doc, 'div'));
    element.innerHTML = html || '';
    var result = exports.createDocumentFragment.call(doc);
    while (element.hasChildNodes()) {
      result.appendChild(element.firstChild);
    }
    return result.childNodes;
  }
  function camelCaseToDashSeparated(val) {
    return val.replace(/([A-Z])/g, '-$1').toLowerCase();
  }
  function PascalCaseToDashSeparated(val) {
    return camelCaseToDashSeparated(val).substr(1);
  }
  function dashSeparatedToCamelCase(string) {
    return string.replace(/^-ms-/, 'ms-').replace(/-([a-z])/g, function (all, letter) {
      return letter.toUpperCase();
    });
  }
  function cleanUpReferral(Url) {
    var referrerHost = Url;
    referrerHost = referrerHost.replace('https://', '');
    referrerHost = referrerHost.replace('http://', '');
    referrerHost = referrerHost.replace('www.', '');
    referrerHost = referrerHost.split('/')[0];
    var referrerDomains = referrerHost.split('.');
    referrerHost = referrerHost.replace('.' + referrerDomains[referrerDomains.length - 1], '');
    return referrerHost;
  }
  function deepProp(obj, path, delimiter) {
    var parts = path.split(delimiter || '.');
    var res = obj;
    var i = 0;
    for (; i < parts.length; i++) {
      res = res[parts[i]];
      if (res === undefined) {
        break;
      }
    }
    return res;
  }
  function deepPropSet(obj, path, value, delimiter) {
    var parts = path.split(delimiter || '.');
    var res = obj;
    var prev;
    var i = 0;
    for (; i < parts.length; i++) {
      prev = res;
      res = res[parts[i]];
      if (res === undefined) {
        return;  // thats an error actually
      }
    }
    prev[parts[i - 1]] = value;
  }
  function boxShadowOverflow(node, win) {
    var sha = 0;
    var res = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    };
    if (node) {
      var sh = win.getComputedStyle(node).boxShadow.split(' ').filter(function (p) {
        return ~p.indexOf('px');
      }).map(function (p) {
        return p.replace(/px/g, '');
      });
      if (sh.length == 3)
        sh.push(0);
      // we have a shadow defined on that elem?
      if (sh[2] || sh[3]) {
        // shadow amount is spread + half of blur + 1 px
        sha = -(-sh[3] - Math.ceil(sh[2] / 2 + 1));
        // adjust bounds by the amount of shadow and offset-x, offset-y of shadow rectangle
        res.top = sha - sh[1];
        res.bottom = -(-sha - sh[1]);
        res.left = sha - sh[0];
        res.right = -(-sha - sh[0]);
      }
    }
    return res;
  }
  function newDict(o) {
    var n = Object.create(null);
    var keys = arguments[1] ? Array.isArray(arguments[1]) ? arguments[1] : slice(arguments, 1) : Object.keys(o);
    keys.forEach(function (key) {
      if (key in o)
        n[key] = o[key];
    });
    return n;
  }
  // this will calculate real visible area of DOM element - e.g. when you have a child with absolute, -100, -100, outside element, then its bounds are taken into account too.
  function bounds(elem, selector) {
    var x = 10000;
    var top = x;
    var left = x;
    var right = -x;
    var bottom = -x;
    var elemWidth = 0;
    var elemHeight = 0;
    var root;
    var nodes = Array.prototype.slice.call(exports.querySelectorAll(elem, selector || '*')).concat(elem);
    nodes.forEach(function (node, index) {
      function pd(node, side) {
        return parseInt(node.style.getPropertyValue('padding-' + side), 10) || 0;
      }
      //TODO, if this is all that ius needed here, inline elements have no dimensios, anything else?
      //if (win.getComputedStyle(node).display == 'inline') return;
      var r = clientRect(node);
      // if no dimensions, invisible
      if ((!r.height || !r.width) && index < nodes.length - 1)
        return;
      //if (!r.width || !r.height) return; // ignore if invisible
      var sh = boxShadowOverflow(node, exports);
      // adjust bounds by the amount of shadow and offset-x, offset-y of shadow rectangle
      r.top = Math.min(r.top, r.top - sh.top);
      r.bottom = Math.max(r.bottom, r.bottom + sh.bottom);
      r.left = Math.min(r.left, r.left - sh.left);
      r.right = Math.max(r.right, r.right + sh.right);
      // TODO: add more props for finer bounds when centered
      if (index + 1 == nodes.length) {
        root = clientRect(node);
        root.top += pd(node, 'top');
        root.left += pd(node, 'left');
        root.right -= pd(node, 'right');
        root.bottom -= pd(node, 'bottom');
        //console.log(JSON.stringify(root));
        elemWidth = r.right - r.left;
        elemHeight = r.bottom - r.top;
      }
      if (r.top < top)
        top = r.top;
      if (r.left < left)
        left = r.left;
      if (r.bottom > bottom)
        bottom = r.bottom;
      if (r.right > right)
        right = r.right;
    });
    return newDict({
      elem: newDict({
        top: root.top - top,
        left: root.left - left,
        bottom: bottom - root.bottom,
        right: right - root.right,
        width: elemWidth,
        height: elemHeight
      }),
      top: top,
      left: left,
      bottom: bottom,
      right: right,
      width: right - left,
      height: bottom - top,
      elemWidth: elemWidth,
      elemHeight: elemHeight
    });
  }
  function clickListener(event, trigger) {
    var button = querySelectorClosest(event.target, '[data-action]');
    if (button && !button.hasAttribute('disabled')) {
      var eventString = button.getAttribute('data-action');
      var value;
      try {
        value = exports.JSON.parse(button.getAttribute('data-value'));
      } catch (e) {
        value = button.getAttribute('data-value');
      }
      trigger(eventString, value, button);
      return true;
    }
  }
  function detectHTMLChange(elem, callback) {
    callback = callback || function () {
    };
    var html = elem.innerHTML;
    var interval = 100;
    var htmlCheck = win.setInterval(function () {
      if (elem.innerHTML == html) {
        callback();
        win.clearInterval(htmlCheck);
      }
    }, interval);
  }
  if (win.Element) {
    var originalGetBoundingClientRect = win.Element.prototype.getBoundingClientRect;
  }
  function applyCustomGetBoundingClientRect(element) {
    var getBoundingClientRect = function (elem, originalGetBoundingClientRect) {
      var rect = originalGetBoundingClientRect.call(elem);
      var res = {
        top: rect.top,
        left: rect.left,
        right: rect.right,
        bottom: rect.bottom,
        width: rect.width,
        height: rect.height
      };
      var elemWindow;
      var iFrames = [];
      var l;
      while (elem.ownerDocument.defaultView != elem.ownerDocument.defaultView.top) {
        // inside iframe, get iframe rect
        elemWindow = elem.ownerDocument.defaultView;
        // elemWindow parent is window that contains that iframe, get it
        iFrames = exports.querySelectorAll(elemWindow.parent.document, 'iframe');
        l = iFrames.length;
        while (l--) {
          if (iFrames[l].contentWindow == elemWindow) {
            // found it
            rect = iFrames[l].getBoundingClientRect();
            res.left += rect.left;
            res.top += rect.top;
            elem = iFrames[l];
            break;
          }
        }
      }
      res.right = res.left + res.width;
      res.bottom = res.top + res.height;
      return Object.freeze ? Object.freeze(res) : res;
    };
    // don't do anything if element is not inside iframe of if custom function already added
    if (element.ownerDocument.defaultView == element.ownerDocument.defaultView.top || element.getBoundingClientRect.custom)
      return;
    element.getBoundingClientRect = function () {
      return getBoundingClientRect(this, originalGetBoundingClientRect);
    };
    element.getBoundingClientRect.custom = true;
  }
  function customGetBoundingClientRect(element) {
    var rect = originalGetBoundingClientRect.call(element);
    var res = {
      top: rect.top,
      left: rect.left,
      right: rect.right,
      bottom: rect.bottom,
      width: rect.width,
      height: rect.height
    };
    var elemWindow;
    var iFrames = [];
    var l;
    while (element.ownerDocument.defaultView != element.ownerDocument.defaultView.top) {
      // inside iframe, get iframe rect
      elemWindow = element.ownerDocument.defaultView;
      // elemWindow parent is window that contains that iframe, get it
      iFrames = exports.querySelectorAll(elemWindow.parent.document, 'iframe');
      l = iFrames.length;
      while (l--) {
        if (iFrames[l].contentWindow == elemWindow) {
          // found it
          rect = iFrames[l].getBoundingClientRect();
          res.left += rect.left;
          res.top += rect.top;
          element = iFrames[l];
          break;
        }
      }
    }
    res.right = res.left + res.width;
    res.bottom = res.top + res.height;
    return Object.freeze ? Object.freeze(res) : res;
  }
  // because ClientRect is frozen
  function clientRect(elem) {
    var rect = elem.getBoundingClientRect();
    return extend(Object.create(null), {
      top: rect.top,
      left: rect.left,
      right: rect.right,
      bottom: rect.bottom,
      width: rect.width,
      height: rect.height
    });
  }
  function parseCSSText(node) {
    var a = node.style.cssText.split(';');
    var l = a.length;
    var o = {};
    var d;
    while (l--) {
      d = a[l].indexOf(':');
      if (d > 0) {
        o[trim(a[l].substr(0, d))] = trim(a[l].substr(d + 1));
      }
    }
    return o;
  }
  function mergeStyles(from, to) {
    var fs = parseCSSText(from);
    var ts = parseCSSText(to);
    var p;
    var r = [];
    for (p in ts)
      if (ts.hasOwnProperty(p)) {
        if (!fs[p])
          delete ts[p];
      }
    for (p in fs)
      if (fs.hasOwnProperty(p)) {
        ts[p] = fs[p];
      }
    for (p in ts)
      if (ts.hasOwnProperty(p)) {
        r.push(p + ':' + ts[p]);
      }
    return to.style.cssText = r.join(';');
  }
  function syncAttributes(from, to, remove) {
    if (!(from && from.attributes && to && to.attributes))
      return;
    var len;
    var attr;
    // copy attributes from->to
    len = from.attributes.length;
    while (len--) {
      attr = from.attributes[len];
      if (to.getAttribute(attr.name) !== attr.value) {
        // i need !== here
        if (attr.name == 'style') {
          mergeStyles(from, to);
        } else {
          to.setAttribute(attr.name, attr.value);
        }
      }
    }
    // erase attributes in to which are not present in from
    if (remove) {
      len = to.attributes.length;
      while (len--) {
        attr = to.attributes[len];
        if (!from.hasAttribute(attr.name)) {
          to.removeAttribute(attr.name);
        }
      }
    }
  }
  function slice(arr, start, end) {
    return Array.prototype.slice.call(arr, start, end);
  }
  function contains(prop) {
    var args = Array.isArray(arguments[1]) ? arguments[1] : slice(arguments, 1);
    if (Array.isArray(prop)) {
      return args.some(function (value) {
        return ~prop.indexOf(value);
      });
    } else if (typeStr(prop) == 'object') {
      return args.some(function (key) {
        return key in prop;
      });
    }
    return args.some(function (value) {
      return prop == value;
    });
  }
  // https://gist.github.com/brettz9/7147458
  /**
  * Adapted from {@link http://www.bulgaria-web-developers.com/projects/javascript/serialize/}
  * Changes:
  *     Ensures proper URL encoding of name as well as value
  *     Preserves element order
  *     XHTML and JSLint-friendly
  *     Disallows disabled form elements and reset buttons as per HTML4 [successful controls]{@link http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2}
  *         (as used in jQuery). Note: This does not serialize <object>
  *         elements (even those without a declare attribute) or
  *         <input type="file" />, as per jQuery, though it does serialize
  *         the <button>'s (which are potential HTML4 successful controls) unlike jQuery
  * @license MIT/GPL
  */
  function urlencode(str) {
    // http://kevin.vanzonneveld.net
    // Tilde should be allowed unescaped in future versions of PHP (as reflected below), but if you want to reflect current
    // PHP behavior, you would need to add ".replace(/~/g, '%7E');" to the following.
    return encodeURIComponent(str).replace(/!/g, '%21').replace(/'/g, '%27').replace(/\(/g, '%28').replace(/\)/g, '%29').replace(/\*/g, '%2A').replace(/%20/g, '+');
  }
  function parseForm(form, extra, returnObject) {
    'use strict';
    var i, len, formElement, val;
    var obj = {};
    function addNameValue(name, value, returnObject) {
      obj[name] = value;
    }
    if (!form || !form.nodeName || form.nodeName.toLowerCase() !== 'form') {
      throw 'You must supply a form element';
    }
    for (i = 0, len = form.elements.length; i < len; i++) {
      formElement = form.elements[i];
      if (formElement.name === '' || formElement.disabled) {
        continue;
      }
      val = parseNodeValue(formElement);
      if (val !== undefined)
        addNameValue(formElement.name, val);
    }
    Objectkeys(extra || {}).forEach(function (key) {
      addNameValue(key, extra[key]);
    });
    var q = [];
    if (returnObject) {
      q = obj;
    } else {
      q = [];
      Objectkeys(obj).forEach(function (key) {
        q.push(urlencode(key) + '=' + urlencode(obj[key]));
      });
    }
    return q;
  }
  //should replace above code but this change shouldn't affect submitting so lets leave for now
  function parseNodeValue(node) {
    switch (node.nodeName.toLowerCase()) {
    case 'input':
      switch (node.type) {
      case 'checkbox':
      case 'radio':
        if (node.checked) {
          return node.value;
        }
        break;
      case 'file':
        // addNameValue(formElement.name, formElement.value); // Will work and part of HTML4 "successful controls", but not used in jQuery
        break;
      case 'reset':
        break;
      // collect every type
      default:
        return node.value;
        break;
      }
      break;
    case 'textarea':
      return node.value;
      break;
    case 'select':
      switch (node.type) {
      case 'select-one':
        return node.value;
        break;
      case 'select-multiple':
        var j = 0;
        var jLen = 0;
        for (j = 0, jLen = node.options.length; j < jLen; j++) {
          if (node.options[j].selected) {
            return node.options[j].value;
          }
        }
        break;
      }
      break;
    default:
      return node.innerText;
      break;
    }
  }
  function serialize(form, extra) {
    return parseForm(form, extra).join('&');
  }
  function mouseEvent(target, event, type) {
    var synthEvent;
    if (!target)
      return;
    try {
      synthEvent = doc.createEvent('MouseEvent');
      synthEvent.initMouseEvent(type || event.type, true, true, event.view, 0, event.screenX, event.screenY, event.clientX, event.clientY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, 0, null);
      synthEvent.initialTarget = event.target;
      if (!target.dispatchEvent(synthEvent))
        synthEvent.preventDefault();
    } catch (e) {
      console.log(e.message);
    }
  }
  function click(target, event) {
    return mouseEvent(target, event, 'click');
  }
  function appendToUrl(url, data) {
    return url + (data ? (~url.indexOf('?') ? '&' : '?') + data : '');
  }
  function px2rem(px, convert, rootFontSize) {
    return convert !== false ? parseInt(px, 10) / rootFontSize + 'rem' : px;
  }
  function isEqual(a, b, p) {
    p || (p = 0.1);
    return Math.abs(a - b) <= p;
  }
  function getAdvOption(config, oid, vid) {
    var opt = config.options || [];
    var l = opt.length;
    var res = [];
    while (l--) {
      if (opt[l].id == oid) {
        res = opt[l].values || [];
        break;
      }
    }
    if (undefined !== vid) {
      l = res.length;
      while (l--) {
        if (res[l].id == vid)
          return res[l].value;
      }
      return;
    }
    return res;
  }
  function filterMap(array, callback, context) {
    var res = [];
    (array || []).forEach(function () {
      var val = callback && callback.apply(context, arguments);
      if (val)
        res.push(val);
    }, context);
    return res;
  }
  function guid(params) {
    var param = params || {
      prefix: false,
      length: 8
    };
    if (!param.prefix) {
      param.prefix = false;
    }
    if (!param.length) {
      param.length = 8;
    }
    this.length = param.length;
    this.timestamp = +new Date();
    var _getRandomInt = function (min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    };
    var ts = this.timestamp.toString();
    var parts = ts.split('').reverse();
    var id = '';
    for (var i = 0; i < this.length; ++i) {
      var index = _getRandomInt(0, parts.length - 1);
      id += parts[index];
    }
    if (param.prefix)
      id = param.prefix + '-' + id;
    return id;
  }
  function guid_string() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0, v = c == 'x' ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  function fetch(url, success, error) {
    httpRequest(0, url, 0, success, error);
  }
  function httpRequest(method, url, data, success, error) {
    error || (error = function () {
      console.log('error', arguments);
    });
    var request = new win.XMLHttpRequest();
    request.onerror = error;
    request.onload = function () {
      if (request.status >= 200 && request.status < 400) {
        if (success) {
          success(request);
        }
      } else {
        error();
      }
    };
    if (method == 'POST') {
      request.open(method, url, true);
      request.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
      request.send(data);
    } else {
      var queryString = '';
      if (data) {
        queryString = Objectkeys(data).map(function (key) {
          return urlencode(key) + '=' + urlencode(data[key]);
        }).join('&');
      }
      try {
        request.open('GET', appendToUrl(url, queryString), true);
        request.send();
      } catch (e) {
        error();
      }
    }
  }
  function buildQueryString(data) {
    var queryString = '';
    if (data) {
      queryString = Objectkeys(data).map(function (key) {
        return urlencode(key) + '=' + urlencode(data[key]);
      }).join('&');
    }
    return queryString;
  }
  function getDocument(elem) {
    if (elem) {
      if ('contentDocument' in elem)
        return elem.contentDocument;
      return elem.contentWindow.document;
    }
  }
  function getWindow(elem) {
    //if (!getDocument(elem)) debugger;
    return getDocument(elem).defaultView;
  }
  // create random name that qualifies as variable name, starts with letter
  function randomName() {
    var name;
    do {
      name = Math.random().toString(36).substring(7);
    } while (!name.substr(0, 1).match(/[a-zA-Z]/));
    return name;
  }
  function treeWalker(node, getChildren, nodeWork, test) {
    node = node || {};
    getChildren = getChildren || function (node) {
    };
    nodeWork = nodeWork || function (node) {
    };
    test = test || function (node) {
      return false;
    };
    nodeWork(node);
    if (test(node))
      return node;
    var childeren = getChildren(node);
    var length = childeren.length;
    var foundValue;
    for (var i = 0; i < length && !foundValue; i++) {
      foundValue = treeWalker(childeren[i], getChildren, nodeWork, test);
    }
    return foundValue;
  }
  function limit(val, min, max) {
    return val < min ? min : val > max ? max : val;
  }
  function scale(val, from1, to1, from2, to2) {
    return to1 - from1 ? (val - from1) / (to1 - from1) * (to2 - from2) + from2 : from2;
  }
  function toArray(obj) {
    if (Array.isArray(obj))
      return obj;
    var p;
    var arr = [];
    for (p in obj) {
      if (obj.hasOwnProperty(p))
        arr.push(obj[p]);
    }
    return arr;
  }
  function stepId(name) {
    return 'sleeknote-' + name.replace(/[^a-zA-Z0-9\-\_\:\.\[\]]/g, '');
  }
  function findPropValue(src, prop) {
    var t = typeStr(src);
    if (t == 'array' || t == 'object') {
      for (var p in src) {
        t = typeStr(src[p]);
        if (t == 'array' || t == 'object') {
          var res = findPropValue(src[p], prop);
          if (res !== undefined)
            return res;
        } else {
          if (p == prop && src[p] !== undefined)
            return src[p];
        }
      }
    }
  }
  function JITMatch(left, type, right) {
    if ((left === undefined || right === undefined) && type != 'exists' && type != 'notExists')
      return false;
    //make sure everything starts as a string
    var strRight = '' + right;
    var strLeft = '' + left;
    switch (type) {
    case 'exactMatch':
      return strLeft.toLowerCase() == strRight.toLowerCase();
      break;
    case 'notExactMatch':
      return strLeft.toLowerCase() != strRight.toLowerCase();
      break;
    case 'contains':
      return strLeft.toLowerCase().indexOf(strRight.toLowerCase()) > -1;
      break;
    case 'lessThan':
      return convertToFloat(strLeft) < convertToFloat(strRight);
      break;
    case 'lessThanEq':
      return convertToFloat(strLeft) <= convertToFloat(strRight);
      break;
    case 'greaterThan':
      return convertToFloat(strLeft) > convertToFloat(strRight);
      break;
    case 'greaterThanEq':
      return convertToFloat(strLeft) >= convertToFloat(strRight);
      break;
    case 'exists':
      return left == '' ? true : !!left;
      break;
    case 'notExists':
      return !left;
      break;
    }
  }
  //Thanks Floatify
  //https://github.com/pocketrocket/floatify
  function convertToFloat(str) {
    var toFloatFormat = function toFloatFormat(str, ts, ds) {
      var string = str;
      var decimalSeparator = ds || '';
      string = string.split(ts || '').join('');
      if (decimalSeparator !== '') {
        string = string.split(decimalSeparator).join('.');
      }
      return parseFloat(string);
    };
    var parseParts = function parseParts(str, ele, count) {
      var string = str;
      var element = ele;
      var parts = string.split(element);
      function parseMidPart() {
        if (current.length !== 3) {
          return Number.NaN;
        }
        if (left.length > 3) {
          return Number.NaN;
        }
        // no decision, continue
        return null;
      }
      function parseEndPart() {
        if (leftVal === 0 || isNaN(leftVal) || left.length > 3) {
          return toFloatFormat(string, '', element);
        }
        if (current.length === 3) {
          return toFloatFormat(string, element, '');
        }
        if (count === 1) {
          return toFloatFormat(string, '', element);
        }
        return Number.NaN;
      }
      for (var i = 1; i < parts.length; i++) {
        var current = parts[i];
        var left = parts[i - 1];
        var leftVal = parseInt(left, 10);
        var isLast = parts.length - 1 === i;
        var parseResult;
        if (!isLast) {
          parseResult = parseMidPart();
        } else {
          parseResult = parseEndPart();
        }
        if (parseResult !== null) {
          break;
        }
      }
      return parseResult || Number.NaN;
    };
    var parse = function parse(str) {
      var string = str;
      var spacePos;
      var spaceSplit;
      var spaceCount;
      var dotPos;
      var commaPos;
      var lDotPos;
      var lCommaPos;
      var dotCount;
      var commaCount;
      function parseMixedSeparators() {
        // format is using dot and comma
        // last dot position
        lDotPos = string.lastIndexOf('.');
        // last comma position
        lCommaPos = string.lastIndexOf(',');
        // order of 1st dot -> comma must be same as last dot -> comma
        // 123.123.123,123 -> ok 123.123,123.123 -> not ok
        if (Math.sign(dotPos - commaPos) !== Math.sign(lDotPos - lCommaPos)) {
          return Number.NaN;
        }
        // check positions to guess the thousands separator
        if (dotPos > commaPos) {
          if (dotCount > 1) {
            return Number.NaN;
          }
          // best guess: . is thousands separator and , is decimal point
          return toFloatFormat(string, ',', '.');
        }
        if (commaCount > 1) {
          return Number.NaN;
        }
        // best guess: , is thousands separator and . is decimal point
        return toFloatFormat(string, '.', ',');
      }
      function parseSingleSeparators() {
        if (dotPos !== -1) {
          // only dot(s) in format
          return parseParts(string, '.', dotCount);
        }
        if (commaPos !== -1) {
          // only comma(s) in format
          return parseParts(string, ',', commaCount);
        }
        return toFloatFormat(string);
      }
      function precheckFormat() {
        // only combination of 2 separators allowed
        if (dotCount > 0 && commaCount > 0 && spaceCount > 0) {
          return false;
        }
        // if there is any separator (space, comma, dot) found more than once,
        // all other must not be found more than once
        if (dotCount > 1 && (commaCount > 1 || spaceCount > 1)) {
          return false;
        }
        return !(commaCount > 1 && spaceCount > 1);
      }
      string = string.trim();
      // 1st dot position
      dotPos = string.indexOf('.');
      // 1st comma position
      commaPos = string.indexOf(',');
      // 1st space position
      spacePos = string.indexOf(' ');
      if (dotPos + commaPos + spacePos === -3) {
        // life is good, no separators
        return toFloatFormat(string);
      }
      spaceSplit = string.split(' ');
      spaceCount = spaceSplit.length - 1;
      dotCount = string.split('.').length - 1;
      commaCount = string.split(',').length - 1;
      if (!precheckFormat()) {
        return Number.NaN;
      }
      if (spaceCount > 0) {
        if (!string.match(/^(\d{1,3})?(\s\d{3})*([,\.]\d+)?$/)) {
          return Number.NaN;
        }
        string = spaceSplit.join('');
      }
      if (dotPos !== -1 && commaPos !== -1) {
        return parseMixedSeparators();
      }
      return parseSingleSeparators();
    };
    return parse(str);
  }
  extend(exports, {
    convertToFloat: convertToFloat,
    JITMatch: JITMatch,
    findPropValue: findPropValue,
    stepId: stepId,
    toArray: toArray,
    fetch: fetch,
    limit: limit,
    scale: scale,
    newDict: newDict,
    randomName: randomName,
    sandbox: sandbox,
    wrapper: anchor.bind(this),
    Objectkeys: Objectkeys,
    getDocument: getDocument,
    getWindow: getWindow,
    filterMap: filterMap,
    isEqual: isEqual,
    px2rem: px2rem,
    appendToUrl: appendToUrl,
    serialize: serialize,
    parseForm: parseForm,
    parseNodeValue: parseNodeValue,
    mouseEvent: mouseEvent,
    click: click,
    getAdvOption: getAdvOption,
    clickListener: clickListener,
    bounds: bounds,
    // boundsAndOverflow: boundsAndOverflow,
    stopPropagation: stopPropagation,
    preventDefault: preventDefault,
    normalizedEvent: normalizedEvent,
    getStyle: getStyle,
    typeStr: typeStr,
    listener: listener,
    gid: gid,
    qsa: qsa,
    qs: qs,
    gtag: gtag,
    objectSize: objectSize,
    extend: extend,
    contains: contains,
    slice: slice,
    removeNode: removeNode,
    eventXY: eventXY,
    offsetRect: offsetRect,
    // 		requestFrame: requestFrame,
    // 		cancelFrame: cancelFrame,
    throttle: throttle,
    applyOptions: applyOptions,
    template: template,
    insertHTML: insertHTML,
    replaceHTML: replaceHTML,
    isNumeric: isNumeric,
    isFunction: isFunction,
    loadScript: loadScript,
    getHostname: getHostname,
    getHashParams: getHashParams,
    empty: empty,
    matchesSel: matchesSel,
    detectHTMLChange: detectHTMLChange,
    guid: guid,
    guid_string: guid_string,
    querySelectorClosest: querySelectorClosest,
    getQueryVarByName: getQueryVarByName,
    httpRequest: httpRequest,
    buildQueryString: buildQueryString,
    cleanUpReferral: cleanUpReferral,
    trim: trim,
    camelCaseToDashSeparated: camelCaseToDashSeparated,
    dashSeparatedToCamelCase: dashSeparatedToCamelCase,
    PascalCaseToDashSeparated: PascalCaseToDashSeparated,
    htmlToFragment: createDocumentFragmentFromHTML,
    htmlToElement: function (html, element) {
      return createDocumentFragmentFromHTML(html, element)[0];
    },
    syncAttributes: syncAttributes,
    applyCustomGetBoundingClientRect: applyCustomGetBoundingClientRect,
    customGetBoundingClientRect: customGetBoundingClientRect,
    deepProp: deepProp,
    deepPropSet: deepPropSet,
    treeWalker: treeWalker
  });
  utils = function () {
    return exports;
  }();
}.call(this));
(function () {
  /*
  // Chrome
  colno
  lineno
  filename
  message
  error.message
  error.stack
  
  // Safari
  colno
  lineno
  filename
  message
  
  //Firefox
  colno
  lineno
  filename
  message
  error ( message, stack, columnNumber, lineNumber, fileName )
  
  //IE11
  colno
  lineno
  filename (empty)
  message
  error ( message, description, name, number, stack )
  
  //Edge
  as IE11, filename has name
  */
  var win = this;
  var errorCallback;
  function composeLogMessage(event) {
    if (!('colno' in event))
      return composeLogMessage({
        c: -1,
        l: -1,
        m: 'unknown ErrorEvent ' + event
      });
    var stack = '';
    if (event.error && event.error.stack) {
      stack = String(event.error.stack).split('\n');
      stack = stack[0] + stack[1];
    }
    var msg = {
      c: event.colno,
      l: event.lineno,
      filename: event.filename,
      m: event.message
    };
    if (stack)
      msg.s = stack;
    return msg;
  }
  var exports = function (callback) {
    if (callback && callback.apply)
      errorCallback = callback;
  };
  win.addEventListener('error', function (event) {
    if (errorCallback)
      errorCallback(composeLogMessage(event));  //event.preventDefault();
  });
  error = function () {
    errorCallback = console.log.bind(console);
    return exports;
  }();
}.call(this));
(function () {
  //TODO: frontend does not support (yet) external JS, therefore this one sits in common right now
  //TODO: frontend does not support (yet) external JS, therefore this one sits in common right now
  /*
  	PP: CommonJS support removed
  	added init() call
  
  	(function (root, factory) {
  		... here!
  	}(this, function (window) {
  
  
  
  	otherwise just copy-paste unminified source in
  */
  /**
  * @license Copyright 2015 Logentries.
  * Please view license at https://raw.github.com/logentries/le_js/master/LICENSE
  */
  /*jslint browser:true*/
  /*global define, module, exports, console, global */
  /** @param {Object} window */
  (function (root, factory) {
    var LE = factory(root);
    var SleekNote = root.SleekNote;
    LE.init(SleekNote ? 'a78dabea-a262-4195-b62f-1ee0bfe26adf' : '2564181e-abb1-4c37-8925-2c99d789f341');
    le = function () {
      return LE;
    }();
  }(this, function (window) {
    'use strict';
    // cross-browser indexOf fix
    var _indexOf = function (array, obj) {
      for (var i = 0; i < array.length; i++) {
        if (obj === array[i]) {
          return i;
        }
      }
      return -1;
    };
    // Obtain a browser-specific XHR object
    var _getAjaxObject = function () {
      if (typeof XDomainRequest !== 'undefined') {
        // We're using IE8/9
        return new XDomainRequest();
      }
      return new XMLHttpRequest();
    };
    /**
     * A single log event stream.
     * @constructor
     * @param {Object} options
     */
    function LogStream(options) {
      /**
      * @const
      * @type {string} */
      var _traceCode = options.trace ? (Math.random() + Math.PI).toString(36).substring(2, 10) : null;
      /** @type {string} */
      var _pageInfo = options.page_info;
      /** @type {string} */
      var _token = options.token;
      /** @type {boolean} */
      var _print = options.print;
      /** @type {boolean} */
      var _noFormat = options.no_format;
      /** @type {boolean} */
      var _SSL = function () {
        if (typeof XDomainRequest === 'undefined') {
          return options.ssl;
        }
        // If we're relying on XDomainRequest, we
        // must adhere to the page's encryption scheme.
        return window.location.protocol === 'https:' ? true : false;
      }();
      /** @type {string} */
      var _endpoint;
      if (window.LEENDPOINT) {
        _endpoint = window.LEENDPOINT;
      } else if (_noFormat) {
        _endpoint = 'webhook.logentries.com/noformat';
      } else {
        _endpoint = 'js.logentries.com/v1';
      }
      _endpoint = (_SSL ? 'https://' : 'http://') + _endpoint + '/logs/' + _token;
      /**
      * Flag to prevent further invocations on network err
      ** @type {boolean} */
      var _shouldCall = true;
      /** @type {Array.<string>} */
      var _backlog = [];
      /** @type {boolean} */
      var _active = false;
      /** @type {boolean} */
      var _sentPageInfo = false;
      if (options.catchall) {
        var oldHandler = window.onerror;
        var newHandler = function (msg, url, line) {
          _rawLog({
            error: msg,
            line: line,
            location: url
          }).level('ERROR').send();
          if (oldHandler) {
            return oldHandler(msg, url, line);
          } else {
            return false;
          }
        };
        window.onerror = newHandler;
      }
      var _agentInfo = function () {
        var nav = window.navigator || { doNotTrack: undefined };
        var screen = window.screen || {};
        var location = window.location || {};
        return {
          url: location.pathname,
          referrer: document.referrer,
          screen: {
            width: screen.width,
            height: screen.height
          },
          window: {
            width: window.innerWidth,
            height: window.innerHeight
          },
          browser: {
            name: nav.appName,
            version: nav.appVersion,
            cookie_enabled: nav.cookieEnabled,
            do_not_track: nav.doNotTrack
          },
          platform: nav.platform
        };
      };
      var _getEvent = function () {
        var raw = null;
        var args = Array.prototype.slice.call(arguments);
        if (args.length === 0) {
          throw new Error('No arguments!');
        } else if (args.length === 1) {
          raw = args[0];
        } else {
          // Handle a variadic overload,
          // e.g. _rawLog("some text ", x, " ...", 1);
          raw = args;
        }
        return raw;
      };
      // Single arg stops the compiler arity warning
      var _rawLog = function (msg) {
        var event = _getEvent.apply(this, arguments);
        var data = { event: event };
        // Add agent info if required
        if (_pageInfo !== 'never') {
          if (!_sentPageInfo || _pageInfo === 'per-entry') {
            _sentPageInfo = true;
            if (typeof event.screen === 'undefined' && typeof event.browser === 'undefined')
              _rawLog(_agentInfo()).level('PAGE').send();
          }
        }
        if (_traceCode) {
          data.trace = _traceCode;
        }
        return {
          level: function (l) {
            // Don't log PAGE events to console
            // PAGE events are generated for the agentInfo function
            if (_print && typeof console !== 'undefined' && l !== 'PAGE') {
              var serialized = null;
              if (typeof XDomainRequest !== 'undefined') {
                // We're using IE8/9
                serialized = data.trace + ' ' + data.event;
              }
              try {
                console[l.toLowerCase()].call(console, serialized || data);
              } catch (ex) {
                console.log(serialized || data);
              }
            }
            data.level = l;
            return {
              send: function () {
                var cache = [];
                var serialized = JSON.stringify(data, function (key, value) {
                  if (typeof value === 'undefined') {
                    return 'undefined';
                  } else if (typeof value === 'object' && value !== null) {
                    if (_indexOf(cache, value) !== -1) {
                      // We've seen this object before;
                      // return a placeholder instead to prevent
                      // cycles
                      return '<?>';
                    }
                    cache.push(value);
                  }
                  return value;
                });
                if (_active) {
                  _backlog.push(serialized);
                } else {
                  _apiCall(_token, serialized);
                }
              }
            };
          }
        };
      };
      /** @expose */
      this.log = _rawLog;
      var _apiCall = function (token, data) {
        _active = true;
        var request = _getAjaxObject();
        if (_shouldCall) {
          if (request.constructor === XMLHttpRequest) {
            // Currently we don't support fine-grained error
            // handling in older versions of IE
            request.onreadystatechange = function () {
              if (request.readyState === 4) {
                // Handle any errors
                if (request.status >= 400) {
                  console.error('Couldn\'t submit events.');
                  if (request.status === 410) {
                    // This API version has been phased out
                    console.warn('This version of le_js is no longer supported!');
                  }
                } else {
                  if (request.status === 301) {
                    // Server issued a deprecation warning
                    console.warn('This version of le_js is deprecated! Consider upgrading.');
                  }
                  if (_backlog.length > 0) {
                    // Submit the next event in the backlog
                    _apiCall(token, _backlog.shift());
                  } else {
                    _active = false;
                  }
                }
              }
            };
          } else {
            request.onload = function () {
              if (_backlog.length > 0) {
                // Submit the next event in the backlog
                _apiCall(token, _backlog.shift());
              } else {
                _active = false;
              }
            };
          }
          request.open('POST', _endpoint, true);
          if (request.constructor === XMLHttpRequest) {
            request.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
            request.setRequestHeader('Content-type', 'application/json');
          }
          if (request.overrideMimeType) {
            request.overrideMimeType('text');
          }
          request.send(data);
        }
      };
    }
    /**
     * A single log object
     * @constructor
     * @param {Object} options
     */
    function Logger(options) {
      var logger;
      // Default values
      var dict = {
        ssl: true,
        catchall: false,
        trace: true,
        page_info: 'never',
        print: false,
        endpoint: null,
        token: null
      };
      if (typeof options === 'object')
        for (var k in options)
          dict[k] = options[k];
      else
        throw new Error('Invalid parameters for createLogStream()');
      if (dict.token === null) {
        throw new Error('Token not present.');
      } else {
        logger = new LogStream(dict);
      }
      var _log = function (msg) {
        if (logger) {
          return logger.log.apply(this, arguments);
        } else
          throw new Error('You must call LE.init(...) first.');
      };
      // The public interface
      return {
        log: function () {
          _log.apply(this, arguments).level('LOG').send();
        },
        warn: function () {
          _log.apply(this, arguments).level('WARN').send();
        },
        error: function () {
          _log.apply(this, arguments).level('ERROR').send();
        },
        info: function () {
          _log.apply(this, arguments).level('INFO').send();
        }
      };
    }
    // Array of Logger elements
    var loggers = {};
    var _getLogger = function (name) {
      if (!loggers.hasOwnProperty(name))
        throw new Error('Invalid name for logStream');
      return loggers[name];
    };
    var _createLogStream = function (options) {
      if (typeof options.name !== 'string')
        throw new Error('Name not present.');
      else if (loggers.hasOwnProperty(options.name))
        throw new Error('A logger with that name already exists!');
      loggers[options.name] = new Logger(options);
      return true;
    };
    var _deprecatedInit = function (options) {
      var dict = { name: 'default' };
      if (typeof options === 'object')
        for (var k in options)
          dict[k] = options[k];
      else if (typeof options === 'string')
        dict.token = options;
      else
        throw new Error('Invalid parameters for init()');
      return _createLogStream(dict);
    };
    var _destroyLogStream = function (name) {
      if (typeof name === 'undefined') {
        name = 'default';
      }
      delete loggers[name];
    };
    // The public interface
    return {
      init: _deprecatedInit,
      createLogStream: _createLogStream,
      to: _getLogger,
      destroy: _destroyLogStream,
      log: function () {
        for (var k in loggers)
          loggers[k].log.apply(this, arguments);
      },
      warn: function () {
        for (var k in loggers)
          loggers[k].warn.apply(this, arguments);
      },
      error: function () {
        for (var k in loggers)
          loggers[k].error.apply(this, arguments);
      },
      info: function () {
        for (var k in loggers)
          loggers[k].info.apply(this, arguments);
      }
    };
  }));
}.call(this));
core_common = function (B, U, errorCatcher, LE) {
  var win = this;
  var doc = win.document;
  var SleekNote = {
    storageOptions: { useLocalStorage: false },
    CustomInitSettings: {},
    STATUS: {
      UNKN: 1,
      IGNORE: 2,
      DESKTOP: 3,
      TABLET: 4,
      MOBILE: 5
    }
  };
  // errors
  errorCatcher(function (error) {
    delete error.filename;
    var msg = {
      message: 'crash',
      details: U.extend({ u: String(win.location) }, error)
    };
    var d = msg.details;
    if (d.s)
      d.s = d.s.replace(d.u, '');
    //if (win.SleekNote.heyImFirstHere) return;
    if (SleekNote.local) {
      console.log(msg);
    } else if (/sleeknote/i.test(error.filename)) {
      // reduce reporting as most likely the error is recurring
      if (Math.random(0, 1) > 0.05)
        return;
      LE.error(msg);
    }
  });
  //	if (win.SleekNote.heyImFirstHere) {
  //		console.warn && console.warn('Second instance of Sleeknote script detected.');
  //		throw new Error();
  //	}
  // debug
  function output() {
    try {
      // fire dummy error to get call stack
      throw new Error('debug');
    } catch (e) {
      var args = Array.prototype.slice.call(arguments);
      var line = e.stack.split('\n').slice(2, 3).join('').split(':').slice(2, 3).join('');
      args.push('line:', line);
      console && console.log.apply(console, args);
    }
  }
  function queryParams(str, noDecode) {
    var params = {};
    var i;
    var pair;
    str = str.replace(/[?#]/, '');
    str = str.split('&').filter(function (entry) {
      return !U.empty(entry);
    });
    if (str[0]) {
      for (i = 0; i < str.length; i++) {
        pair = str[i].split('=', 2);
        params[pair[0]] = pair[1] ? noDecode ? pair[1] : U.decodeURIComponent(pair[1].replace(/\+/g, ' ')) : undefined;
      }
    }
    return params;
  }
  var loc = win.location;
  var params = queryParams(!loc.search && loc.hash ? loc.hash : loc.search);
  var debug = params.sndebug;
  // https://sleeknotestaticcontent.sleeknote.com/branches/core-SND-1690-new-editor-ui-2.js
  // https://sleeknotestaticcontent.sleeknote.com/sleeknote4-SND-1690-new-editor-ui-2.css
  //https://sn.local/?snaccid=4920&snbranch=SND-1234 <- new parameter 'snbranch' = actual branch short name like 'SND-1234'
  var scripts = doc.getElementsByTagName('script');
  var len = scripts.length;
  var currentScriptSrc = '';
  while (len--) {
    var src = scripts[len].src;
    if ((win.SleekNote.local || src && ~src.indexOf('sleeknotestaticcontent')) && ~src.indexOf('core') && src.indexOf('core-common.js') < 0 && src.indexOf('core-boot.js') < 0) {
      currentScriptSrc = scripts[len].src;
      break;
    }
  }
  var branch = !win.SleekNote.branch && params.snbranch;
  var folder = '';
  SleekNote.appendToFile = '';
  if (branch) {
    if (currentScriptSrc) {
      // extract path and  basename
      win.SleekNote.branch = branch;
      win.SleekNote.path = 'https://core-branches.sleeknote.com/';
      var js = win.document.createElement('script');
      js.type = 'text/javascript';
      js.src = win.SleekNote.path + 'core-' + branch + '.js';
      doc.body.appendChild(js);
      throw new Error('Switching to ' + js.src);
    }
  } else {
    // detect if we are run from subfolder
    var parts = currentScriptSrc.split('/');
    var f = parts[parts.length - 2];
    if (!(~f.indexOf('.') || f == 'frontend')) {
      folder += '/';
    }
    // detect if we are appended
    f = parts.pop().split('-');
    if (f.length == 2) {
      SleekNote.appendToFile = '-' + f[1].split('.')[0];
    }
  }
  SleekNote.debug = debug || '';
  SleekNote.reset = params.snreset;
  SleekNote.editor = params.sneditor;
  SleekNote.print = output;
  //SleekNote.folder = folder == '/' ? '' : folder;
  SleekNote.timestamp = '?' + (Number('1602228862067') || '');
  SleekNote.debugMessage = function (m) {
    var debug = SleekNote.debug;
    if (debug) {
      if (~debug.indexOf('1') || m && ~debug.indexOf(m))
        return output;
    }
    return function () {
    };
  };
  function custom(prop, a, b) {
    var val = SleekNote.CustomInitSettings && SleekNote.CustomInitSettings[prop];
    if (b === undefined) {
      // return prop value or a
      return val ? val : a;
    }
    //if prop is set return a, otherwise b
    return val ? a : b;
  }
  SleekNote.custom = custom;
  SleekNote.getFixedValue = function () {
    return 'fixed';
  };
  SleekNote.use3D = !(B.is.desktop && B.is.chrome && B.is.version < 66);
  // use snhide in editor's iframe for domain to supress sleeknotes in live page
  if (!params.snhide) {
    if ('SleekNote' in win) {
      // new init scripts
      Object.keys(win.SleekNote).forEach(function (key) {
        if (win.SleekNote[key] !== undefined)
          SleekNote[key] = win.SleekNote[key];
      });
    } else {
      // old init scripts
      [
        'CustomerId',
        'HideSleeknoteBadge',
        'SleeknotePiwikSiteId',
        'SleekNotes',
        'SleeknoteGoals'
      ].forEach(function (p) {
        if (p in win) {
          SleekNote[p] = win[p];
          delete win[p];
        }
      });
    }
  }
  if (SleekNote.CustomInitSettings.cookiePath)
    SleekNote.storageOptions.cookiePath = SleekNote.CustomInitSettings.cookiePath;
  // 	SleekNote.CustomInitSettings.noIFrames = true;
  // 	SleekNote.preview = true;
  //SleekNote.CustomInitSettings.noZoomCheck = false;
  if (!win.SleekNote || !win.SleekNote.editor) {
    win.SleekNote = {};
  }
  return SleekNote;
}(browser, utils, error, le);
(function () {
  /*
  		- as jQuery css, use singlem props or use object
  		- automatically prefixes properties
  			(all prefixable properties are in 'prefixed' object, amend if needed)
  		- allows value shorthands:
  
  			* 1/0 or true/false for: display, visibility, backfacevisibility, overfow
  
  			* array for transform
  			SleekNote.css.set(node, 'transform', [10,10]) // translate(10, 10)
  			SleekNote.css.set(node, 'transform', [10,10,0]) // translate3d(10,10,0)
  			SleekNote.css.set(node, 'transform', [1,0,0,1,10,10]) // matrix(1,0,0,1,10,10)
  			
  			* add common units: % for origin, ms for duration, px for properties listed in variable 'pixel'
  
  
  		Usage:
  
  		SleekNote.css.set(document.body, 'overflow', 1)
  		
  		SleekNote.css.set(document.body, {
  			width: 100,
  			overflow: 0
  		})
  
  		SleekNote.css.inline('backfaceVisibility', 1) // '-webkit-backface-visibility:'visible';'
  		SleekNote.css.inline('backgroundColor', 'foo') // 'background-color:'foo';'
  	
  	*/
  var win = this;
  var doc = win.document;
  var U;
  var B;
  //var legal = doc.body.style;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  // all style names that probably need prefix
  var prefixed = {
    userDrag: '',
    userSelect: '',
    flexDirection: '',
    flexWrap: '',
    justifyContent: '',
    alignItems: '',
    alignContent: '',
    order: '',
    flex: '',
    alignSelf: '',
    flexGrow: '',
    flexShrink: '',
    flexBasis: '',
    animation: '',
    animationDelay: '',
    animationDirection: '',
    animationDuration: '',
    animationFillMode: '',
    animationIterationCount: '',
    animationName: '',
    animationPlayState: '',
    animationTimingFunction: '',
    transform: '',
    transformOrigin: '',
    transformStyle: '',
    transition: '',
    transitionDelay: '',
    transitionDuration: '',
    transitionProperty: '',
    transitionTimingFunction: '',
    perspective: '',
    perspectiveOrigin: '',
    backfaceVisibility: ''
  };
  var pixel = ',top,left,bottom,right,perspective';
  var getComputedStyle;
  var isArray = Array.isArray;
  var prefixList = [
    '-webkit-',
    '-moz-',
    '-ms-',
    ''
  ];
  function translateProperty(prop, allPrexixes) {
    var dash = prop.indexOf('-');
    if (dash === 0)
      return prop;
    var camelCase = ~dash ? U.dashSeparatedToCamelCase(prop.toLowerCase()) : prop;
    var dashed;
    // in case first was '-'
    if (prop.charAt(0) == '-')
      camelCase = camelCase.charAt(0).toLowerCase() + camelCase.substr(1);
    dashed = U.camelCaseToDashSeparated(camelCase);
    if (camelCase in prefixed) {
      if (allPrexixes) {
        return prefixList.map(function (prefix) {
          return prefix + dashed;
        });
      } else {
        return B.cssVendor + dashed;
      }
    }
    if (dashed.indexOf('webkit-') === 0)
      dashed = '-' + dashed;
    return allPrexixes ? [dashed] : dashed;
  }
  function translateValue(prop, value) {
    var arr = isArray(value);
    // '' is special case in css context, setting value to '' will effectively erase it, so we can not coerse it to number
    var num = U.isNumeric(value);
    var str = !arr && (value === '' || !num);
    if (num && value !== '')
      value = +value;
    var len;
    var i;
    var v = '';
    prop = prop.toLowerCase().replace(/\-/g, '');
    function bezier(arr) {
      return 'cubic-bezier(' + arr.join(',') + ')';
    }
    function re(value) {
      if (!value.blink) {
        if (value < 1 && value > 0 || value < 0 && value > -1)
          value = 0;
      } else {
        if (~value.indexOf('e-'))
          value = '0%';
      }
      return value;
    }
    function translate(arr) {
      var z = arr.length == 3;
      var x = re(arr[0] || 0);
      var y = re(arr.length == 1 ? 0 : arr[1] || 0);
      if (!x.indexOf || x.indexOf('%') < 0) {
        x += 'px';
      }
      if (!y.indexOf || y.indexOf('%') < 0) {
        y += 'px';
      }
      return 'translate' + (z ? '3d' : '') + '(' + x + ',' + y + (z ? ',' + (arr[2] || 0) : '') + ')';
    }
    function xy(arr) {
      var x = re(arr[0]);
      var y = re(arr.length == 1 ? 0 : arr[1]);
      if (!x.blink) {
        x += 'px';
      }
      if (!y.blink) {
        y += 'px';
      }
      return x + ' ' + y;
    }
    function unit(str) {
      return (str + '').replace(/[0-9.-\s]/gi, '');
    }
    // eslint-disable-next-line no-unused-vars
    var getStackTrace = function () {
      var obj = {};
      if ('captureStackTrace' in Error)
        Error.captureStackTrace(obj, getStackTrace);
      return obj.stack || '';
    };
    if (/origin/.test(prop) && arr) {
      return Math.round(value[0] * 100) + '% ' + Math.round(value[1] * 100) + '%';
    } else if (prop == 'transform' && arr) {
      len = value.length;
      /*
      		2: translate [100,200]
      		3: - translate3d if numbers [100, 200, 0]
      		   - translate/translate3d, rotate, scale, if first member is Array -> [[100,200], 90, 2]
      		   - also rotate can be 3d [[100,200], [0, 1, 1, 180], 2]
      		   - it is very rare to have a need to scale3d, no support yet TODO
      		4: translate, rotate, scale, perspective
      		5: translate, rotate, scale, perspective, translate (this allows both, % translate and px translate)
      		6: matrix
      	*/
      if (len <= 5) {
        if (len >= 4 && (+value[3] || 0)) {
          // if perspective is not zero number
          v = 'perspective(' + value[3] + 'px) ';
        }
        v += isArray(value[0]) ? translate(value[0]) : translate(value);
        if (len == 5) {
          v += ' ' + translate(isArray(value[4]) ? value[4] : [value[4]]);
        }
        if (len > 1 && isArray(value[0])) {
          v += isArray(value[1]) ? ' rotate3d(' + value[1].join() + 'deg)' : ' rotate(' + (+value[1] || 0) + 'deg)';
          v += ' scale(' + (+value[2] || 1) + ')';
        }
        return v;
      } else if (len == 6) {
        return 'matrix(' + value.join(',') + ')';
      }
    } else if (U.contains(prop, 'width', 'height', 'left', 'top', 'right', 'bottom')) {
      // we need to force all these into form of calc(0vh + 0px) IF we use either viewport units or pixels
      //console.log('translate for calc before: ', value);
      if (value === undefined)
        return;
      if (str || value === 0) {
        return value;
      }
      var tmp = isArray(value) ? U.extend(value) : [value];
      // do not mess with the original
      //			var layout = /layout/.test(getStackTrace());
      //			if (!layout) console.warn(getStackTrace());
      //console.log('css', prop, value, layout);
      //console.trace();
      var present = [];
      try {
        tmp = tmp.map(function (v, i) {
          v = (v + '').replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
          var n;
          if (U.isNumeric(v)) {
            n = v;
            v = v + 'px';
          } else {
            n = parseInt(v, 10);
          }
          if (i) {
            if (n < 0) {
              v = v.replace('-', '- ');
            } else if (n >= 0) {
              v = '+ ' + v;
            }
          } else {
          }
          present.push(unit(v));
          return v;
        });
      } catch (e) {
        debugger;
      }
      [
        'px',
        U.contains(prop, 'width', 'left', 'right') ? 'vw' : 'vh'
      ].forEach(function (u) {
        if (present.indexOf(u) < 0)
          tmp.push((tmp.length ? '+ ' : '') + '0' + u);
      });
      //console.log('css2', prop, 'calc(' + value.join(' ') + ')', getStackTrace());
      return 'calc(' + tmp.join(' ') + ')';  //			arr.value = value
                                             //				//				.filter(function(v) {
                                             //				//					return parseInt(v, 10);
                                             //				//				})
                                             //				.map(function(v) {
                                             //					return U.isNumeric(v) ? v + 'px' : v;
                                             //				});
                                             //
                                             //			//			value = value
                                             //			//				.filter(function(v) {
                                             //			//					return parseInt(v, 10);
                                             //			//				})
                                             //			//				.map(function(v) {
                                             //			//					return U.isNumeric(v) ? v + 'px' : v;
                                             //			//				});
                                             //			var c = value.length > 1 ? 'calc(' + value.join('') + ')' : value[0] || '0px';
                                             //			//console.log('translate for calc after: ', c);
                                             //			return c;
    } else if (prop == 'backgroundsize') {
      if (arr)
        return xy(value);
      if (U.isNumeric(value))
        value += 'px';
    } else if (prop == 'backgroundposition' && arr) {
      return xy(value);
    } else if (!str && value !== 0 && (~pixel.indexOf(',' + prop) || /width|height|margin|padding|radius|size/.test(prop))) {
      return value + 'px';
    } else if (prop == 'transitionproperty') {
      if (arr)
        value = value.join(', ');
      value = value.replace(B.cssVendor, '');
      return value.replace('transform', B.cssVendor + 'transform');
    } else if (prop == 'display' && !str) {
      return value ? 'block' : 'none';
    } else if (prop == 'pointerevents' && !str) {
      return value ? 'auto' : 'none';
    } else if ((prop == 'visibility' || /overflow/.test(prop) || prop == 'backfacevisibility') && !str) {
      return value ? 'visible' : 'hidden';
    } else if (/delay|duration/.test(prop) && !str) {
      if (arr)
        value = value.join('ms, ');
      return value + 'ms';
    } else if (/timingFunction/.test(prop) && arr) {
      if (value[0] === +value[0]) {
        // [0, 1, 1, 1]
        return bezier(value);
      } else {
        // ['ease', [0, 1, 1, 1]]
        for (i = 0; i < value.length; i++)
          v += (i ? ', ' : '') + (isArray(value[i]) ? bezier(value[i]) : value[i]);
        return v;
      }
    }
    if (value === undefined || value === null)
      value = '';
    return value;
  }
  function applyStyle(node, prop, value, important) {
    //IE can't handle undefined being passed in the priority property
    //
    // 		if (node.id == 'form7ca80cec-e1e8-4fee-85d6-0a22360f84af') {
    // 			console.log(translateProperty(prop), translateValue(prop, value));
    // 			//if (translateValue(prop, value).indexOf('NaN') > 0) debugger;
    // 			//console.trace();
    // 		}
    node.style.setProperty(translateProperty(prop), translateValue(prop, value), important ? 'important' : '');
    if (prop == 'fontFamily') {
      node.style.fontFamily = node.style.fontFamily.replace(/\"/g, '\'');
    }
  }
  function prioritizeProperties(props) {
    var t = props.indexOf('transform');
    var w = props.indexOf('width');
    var h = props.indexOf('height');
    if (~t && (~w && w < t || ~h && h < t)) {
      props.splice(t, 1);
      props.unshift('transform');
      t = props.indexOf('transformOrigin');
      if (~t) {
        props.splice(t, 1);
        props.unshift('transformOrigin');
      }
    }
    return props;
  }
  function applyStyles() {
    var args = Array.prototype.slice.call(arguments);
    var styles;
    if (U.typeStr(args[1]) == 'object') {
      args.splice(2, 0, '');
      // 'value' is missing, add it
      styles = args[1];
      prioritizeProperties(Object.keys(styles)).forEach(function (prop) {
        args[1] = prop;
        args[2] = styles[prop];
        applyStyle.apply(null, args);
      });
    } else {
      applyStyle.apply(null, args);
    }
  }
  function set() {
    var args = Array.prototype.slice.call(arguments);
    var len;
    // allow silent failure, makes life easier
    var nodes;
    if (!args[0])
      return;
    if (!args[0].nodeName && (len = args[0].length)) {
      // jQuery result passed
      nodes = args[0];
      while (len--) {
        args[0] = nodes[len];
        applyStyles.apply(this, args);
      }
    } else if (args[0].style) {
      applyStyles.apply(this, args);
    }
  }
  var cachedComputedStyle;
  function get(node, prop, option) {
    if (!prop || !prop.blink)
      return '';
    node.length && (node = node[0]);
    // jQuery result passed
    var computedStyle;
    if (option == 'cached' && cachedComputedStyle) {
      computedStyle = cachedComputedStyle;
    } else {
      computedStyle = getComputedStyle(node, null);
      cachedComputedStyle = undefined;
    }
    if (option == 'seed') {
      cachedComputedStyle = computedStyle;
    }
    var value = computedStyle[property(prop)];
    return value && String(value).indexOf('px') == value.length - 2 ? parseInt(value, 10) : value;
  }
  function property(prop) {
    prop = U.dashSeparatedToCamelCase(prop);
    var pfx = prefixed[prop];
    return pfx ? pfx : prop;
  }
  var prefixList = [
    '-webkit-',
    '-moz-',
    '-ms-',
    ''
  ];
  function inline(prop, value, allPrefixes) {
    var props = prop;
    if (props === undefined)
      return '';
    if (U.typeStr(prop) != 'object') {
      props = {};
      props[prop] = value;
    } else {
      allPrefixes = value;
    }
    var a = [];
    var camelCased;
    var dashSeparated;
    for (prop in props)
      if (hasOwnProperty.call(props, prop)) {
        value = translateValue(prop, props[prop]);
        if (prop == 'fontFamily') {
          // prettier-ignore
          value = value.replace(/\"/g, '\'');
        }
        if (undefined === value)
          continue;
        value = ':' + value + ';';
        camelCased = U.dashSeparatedToCamelCase(prop);
        //if (!(prop in legal)) continue;
        if (prefixed[camelCased]) {
          if (allPrefixes) {
            dashSeparated = U.camelCaseToDashSeparated(camelCased);
            (Array.isArray(allPrefixes) ? allPrefixes : prefixList).forEach(function (prefix) {
              a.push(prefix, dashSeparated, value);
            });
          } else {
            a.push(U.camelCaseToDashSeparated(prefixed[camelCased]), value);
          }
        } else {
          a.push(U.camelCaseToDashSeparated(camelCased), value);
        }
      }
    return a.join('');
  }
  function normalize(prop, value) {
    var props = prop;
    if (props === undefined)
      return {};
    if (U.typeStr(prop) != 'object') {
      props = {};
      props[prop] = value;
    }
    var a = {};
    var camelCased;
    for (prop in props)
      if (hasOwnProperty.call(props, prop)) {
        value = translateValue(prop, props[prop]);
        if (prop == 'fontFamily') {
          // prettier-ignore
          value = value.replace(/\"/g, '\'');
        }
        if (undefined === value)
          continue;
        camelCased = U.dashSeparatedToCamelCase(prop);
        if (prefixed[camelCased])
          camelCased = prefixed[camelCased];
        a[camelCased] = value;
      }
    return a;
  }
  var styleSheetId;
  function addRule(selector, rules, target, index) {
    target || (target = doc);
    var styleElem = U.qsa('#' + styleSheetId, target)[0];
    if (!styleElem) {
      styleElem = target.createElement('style');
      styleElem.id = styleSheetId;
      (target.head || U.qsa('head', target)[0] || target.documentElement).appendChild(styleElem);
    }
    styleElem.sheet.insertRule(selector + '{' + rules + '}', 0);
  }
  function getOriginalCSSData(elem, props) {
    var save = {};
    var style;
    var cssText;
    if (elem && elem.nodeName) {
      style = elem.style;
      cssText = style.cssText;
    } else {
      cssText = inline(elem);
      style = elem;
    }
    props.forEach(function (prop) {
      save[prop] = ~cssText.indexOf(U.camelCaseToDashSeparated(prop)) ? style[prop] : '';
    });
    return U.JSON.stringify(save);
  }
  function setCSSIfOverriden(name, elem, styles, props, important) {
    name = 'data-' + name;
    if (!elem)
      return;
    if (elem.hasAttribute(name)) {
      var saved = U.JSON.parse(elem.getAttribute(name));
      //Object.keys(saved).forEach(function(prop){
      props.forEach(function (prop) {
        if (styles[prop]) {
          // attempt to set style that SHOULD BE overriden on concealing
          saved[prop] = styles[prop];
          delete styles[prop];
        }
      });
      elem.setAttribute(name, U.JSON.stringify(saved));
    }
    set(elem, styles, important);
  }
  function overwriteCSS(name, elem, styles) {
    elem.setAttribute('data-' + name, getOriginalCSSData(elem, Object.keys(styles)));
    set(elem, styles);
  }
  function restoreCSS(name, elem, except) {
    name = 'data-' + name;
    if (!elem.hasAttribute(name))
      return;
    var props = U.JSON.parse(elem.getAttribute(name));
    if (Array.isArray(except)) {
      except.forEach(function (prop) {
        delete props[prop];
      });
    }
    set(elem, props);
    elem.removeAttribute(name);
  }
  function concealedStyles() {
    return {
      //PP: weird, but that causes problems on some sites when hiding rotated teasers, not changing position from fixed->absolute
      // fixes it
      //position: 'absolute',
      //PP: this must right now not be zero, will be changed in new NM
      //width: 0, // per PP re-enabling. feab07b was where it was commented out
      height: 0,
      pointerEvents: 'none',
      // the deal with overflow is that browsers apply all this now differently (started with Chrome: we apply overflowX:hidden, but
      // as we read then overflowX is '', but overflow is 'hidden visible', then when we apply overflow first at restore, it gets overwritten
      // with '' when we apply overflowX, which was set to '', shortly, it is a mess ) and as we now support
      // browsers that support pointer-events, it is just easier this way
      /*
      	overflow: 0,
      	overflowX: 0,
      	overflowY: 0,
      	*/
      visibility: 0,
      overflowY: 0
    };
  }
  var concealeProps = Object.keys(concealedStyles());
  function concealedStyle(style) {
    return inline(U.extend({}, style || {}, concealedStyles()));
  }
  function concealedData(elem) {
    return getOriginalCSSData(elem, concealeProps);
  }
  function conceal(elem) {
    return overwriteCSS('conceal', elem, concealedStyles());
  }
  function reveal(elem) {
    return restoreCSS('conceal', elem);
  }
  function cssConcealed(elem, styles, important) {
    return setCSSIfOverriden('conceal', elem, styles, concealeProps, important);
  }
  function flashRevealIf(elem, callback) {
    var name = 'data-conceal';
    var concealed = elem.hasAttribute(name);
    if (concealed)
      reveal(elem, ['visibility']);
    var r = callback(elem);
    if (concealed)
      conceal(elem);
    return r;
  }
  function applyPerspectiveIf(prop, perspective) {
    // good all-round perspective value, no matter what, is 800px
    if (prop.transform.length >= 3 && Array.isArray(prop.transform[0]) && prop.transform[0][2] > 0 || Array.isArray(prop.transform[4]) && prop.transform[4][2] > 0 || Array.isArray(prop.transform[1]) && (prop.transform[1][0] || prop.transform[1][1])  // rotate3d
)
      prop.transform[3] = +perspective || 800;
    return prop;
  }
  var exports = {
    normalize: normalize,
    applyPerspectiveIf: applyPerspectiveIf,
    addRule: addRule,
    set: set,
    get: get,
    inline: inline,
    property: property,
    clear: function (node, prop) {
      set(node, prop);
    },
    overwriteCSS: overwriteCSS,
    restoreCSS: restoreCSS,
    conceal: conceal,
    // usage of concealedStyles & concealedData is in HTML building in memory
    concealedStyle: concealedStyle,
    concealedData: concealedData,
    cssConcealed: cssConcealed,
    flashRevealIf: flashRevealIf,
    reveal: reveal,
    addRuleObj: function (selector, styles, target) {
      this.addRule(selector, inline(styles), target);
      this.addRule('@media print', selector + '{display: none!important;}', target);
      return true;
    }
  };
  css = function (utils, browser) {
    U = utils;
    B = browser;
    styleSheetId = U.randomName();
    getComputedStyle = U.getComputedStyle;
    return exports;
  }(utils, browser);
}.call(this));
animator = function (U, CSS) {
  var win = this;
  var pow = Math.pow;
  var PI = Math.PI;
  var lim = 2.5 * PI;
  var abs = Math.abs;
  var cos = Math.cos;
  var scale = U.scale;
  var limit = U.limit;
  // you could pass function or ease method name
  function makeEaseFunc(param) {
    if (Array.isArray(param)) {
      var bezier = new UnitBezier(param[0], param[1], param[2], param[3]);
      return function (pos, from, to, duration) {
        return scale(bezier.solve(pos, solveEpsilon((+duration || 600) / 1000)), 0, 1, from, to);
      };
    } else {
      switch (param) {
      case 'easeOut':
        return function (pos, from, to) {
          var t;
          return scale((t = pos - 1) * t * t * t * t + 1, 0, 1, from, to);
        };
      case 'wall':
        return function (dx, from, to) {
          var amp = pow(1 - pow(dx, cos(dx * 2)), 2);
          return scale(1 - abs(cos(lim * dx * dx)) * amp, 0, 1, from, to);
        };
      case 'linear':
        return function (pos, from, to) {
          return scale(pos, 0, 1, from, to);
        };
      default:
        // if param is string, otherwise assume function
        return param === param + '' ? function (pos, from, to) {
          return scale(-cos(pos * PI) / 2 + 0.5, 0, 1, from, to);
        } : param;
      }
    }
  }
  // The epsilon value we pass to UnitBezier::solve given that the animation is going to run over |dur| seconds. The longer the
  // animation, the more precision we need in the timing function result to avoid ugly discontinuities.
  function solveEpsilon(duration) {
    return 1 / (200 * duration);
  }
  function Animator() {
    this.duration = 0;
    this.finished;
    // callback to call when all motions are finished
    this.started;
    // callback to call after first frame ( yes! )
    this.motions = [];
    this.timer = 0;
    this.animate = this.animate.bind(this);
    this.add.apply(this, arguments);
    this.play = this.play.bind(this);  // allows to easy start animation with setTimeout
  }
  Animator.scale = scale;
  Animator.makeEaseFunc = makeEaseFunc;
  Animator.makeFullTransformArray = function (a) {
    // clone first!
    a = U.extend(a);
    if (Array.isArray(a[0])) {
      if (!Array.isArray(a[1])) {
        //transform rotate to 3d notation
        a[1] = [
          0,
          0,
          1,
          a[1]
        ];
      }
      if (!Array.isArray(a[4])) {
        a[4] = [
          0,
          0
        ];
      }
    } else {
      // simple translate array
      a = [
        a,
        [
          0,
          0,
          1,
          0
        ],
        1,
        undefined,
        [
          0,
          0
        ]
      ];
    }
    return a;
  };
  Animator.blendTransformArray = function (from, to, pos) {
    function calc(a, b) {
      var p = a.indexOf ? a.indexOf('%') : -1;
      if (~p) {
        a = parseInt(a, 10);
        b = parseInt(b, 10);
      }
      var r = (a + (b - a) * pos).toFixed(6);
      //if (p && Math.floor(Math.abs(r) - 0.1) <= 0) r = 0;
      if (~p)
        r = r + '%';
      return r;
    }
    if (!Array.isArray(from[0])) {
      return [
        calc(from[0], to[0]),
        calc(from[1], to[1])
      ];
    }
    var translate = [
      calc(from[0][0], to[0][0]),
      calc(from[0][1], to[0][1]),
      0
    ];
    // allow out of bounds translate
    pos = limit(pos, 0, 1);
    var rotate = Array.isArray(from[1]) ? [
      from[1][0],
      from[1][1],
      from[1][2],
      calc(from[1][3], to[1][3])
    ] : calc(from[1], to[1]);
    var ret = [
      translate,
      rotate,
      from[2] + (to[2] - from[2]) * pos
    ];
    // not animating perspective, pick either one
    if (from[3] !== undefined || to[3] !== undefined)
      ret[3] = from[3] === undefined ? to[3] : from[3];
    if (from[4] !== undefined || to[4] !== undefined) {
      ret[4] = [
        calc(from[4][0], to[4][0]),
        calc(from[4][1], to[4][1])
      ];
    }
    //console.log(JSON.stringify(ret));
    return ret;
  };
  Animator.getTransformPos = function (from, to, blended) {
    if (from[0][0] != to[0][0]) {
      return Math.abs(blended[0][0] - from[0][0]) / Math.abs(to[0][0] - from[0][0]);
    } else if (from[0][1] != to[0][1]) {
      return Math.abs(blended[0][1] - from[0][1]) / Math.abs(to[0][1] - from[0][1]);
    }
    return 0;
  };
  // TODO: this is used only in skeleton
  Animator.createMotion = function (elem, from, to) {
    var keys = Object.keys(from);
    var units = U.extend(from);
    var len;
    var k;
    var blended = {};
    var fromNum = {};
    var toNum = {};
    var motion = {
      frame: function (pos, first, last) {
        if (last) {
          CSS.set(elem, to);
        } else if (first) {
          CSS.set(elem, from);
        } else {
          len = keys.length;
          while (len--) {
            k = keys[len];
            blended[k] = fromNum[k] + (toNum[k] - fromNum[k]) * pos + units[k];
          }
          CSS.set(elem, blended);
        }
      }
    };
    len = keys.length;
    while (len--) {
      k = keys[len];
      units[k] = String(units[k]).replace(/[0-9\-\.]/g, '');
      fromNum[k] = parseFloat(from[k]);
      toNum[k] = parseFloat(to[k]);
    }
    return motion;
  };
  Animator.prototype = {
    add: function () {
      var i = 0;
      var motions;
      if (Array.isArray(arguments[0])) {
        motions = arguments[0];
      } else {
        motions = arguments;
      }
      for (; i < motions.length; i++)
        this.motion(motions[i]);
      return this;
    },
    play: function (finished) {
      var i = 0;
      var motion;
      if (this.timer)
        return this;
      if (!this.motions.length) {
        finished && finished();
        return this;
      }
      this.startTime = +new Date();
      for (; motion = this.motions[i]; i++)
        motion.finished = false;
      if (finished)
        this.finished = finished;
      try {
        this.timer = win.setTimeout(this.animate, 13);
      } catch (E) {
        this.frame(this.duration);
      }
      return this;
    },
    stop: function () {
      if (this.timer) {
        //U.cancelFrame(this.timer);
        win.clearTimeout(this.timer);
        this.timer = 0;
        this.finished && this.finished();
      }
      return this;
    },
    ffwd: function () {
      if (this.timer) {
        this.frame(this.duration);
        this.stop();
      }
      return this;
    },
    motion: function (motion) {
      if (motion != Object(motion) || !motion.frame)
        return;
      var delay = +motion.delay || 0;
      var duration = +motion.duration || 400;
      motion.parent = this;
      this.motions[this.motions.length] = {
        ease: makeEaseFunc(motion.ease || 'default'),
        from: +motion.from || 0,
        to: +motion.to || 1,
        frame: motion.frame,
        duration: duration,
        delay: delay,
        pos: undefined
      };
      this.duration = Math.max(this.duration, duration + delay);
      if (motion.finished)
        this.finished = motion.finished;
      return this;
    },
    go: function (pos, easing) {
      var i = 0;
      var motion;
      for (; motion = this.motions[i]; i++) {
        motion.pos = easing ? motion.ease(pos, motion.from, motion.to) : pos;
        motion.frame(motion.pos, pos <= 0, pos >= 1);
      }
    },
    frame: function (time) {
      var i = 0;
      var motion;
      var mtime;
      var last;
      var first;
      for (; motion = this.motions[i]; i++) {
        mtime = time - motion.delay;
        if (mtime < 0 || motion.finished)
          continue;
        last = mtime >= motion.duration;
        first = motion.pos === undefined;
        motion.pos = motion.ease(last ? 1 : mtime / motion.duration, motion.from, motion.to, motion.duration);
        motion.frame(motion.pos, first, last);
        motion.finished = last;
        if (first && this.started) {
          this.started();
          this.started = undefined;
        }
      }
    },
    playLastFrame: function () {
      var i = 0;
      var motion;
      //console.log(this.motions);
      for (; motion = this.motions[i]; i++) {
        motion.frame(1, false, true);
      }
    },
    animate: function (timestamp) {
      var time = limit(Date.now() - this.startTime, 0, this.duration);
      this.frame(time);
      //if ( time > this.duration/4 ) debugger;
      if (time >= this.duration) {
        this.stop();
      } else {
        this.timer = win.setTimeout(this.animate, 13);
      }
    }
  };
  function UnitBezier(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    this.cx = 3 * p1x;
    this.bx = 3 * (p2x - p1x) - this.cx;
    this.ax = 1 - this.cx - this.bx;
    this.cy = 3 * p1y;
    this.by = 3 * (p2y - p1y) - this.cy;
    this.ay = 1 - this.cy - this.by;
  }
  UnitBezier.prototype = {
    sampleCurveX: function (t) {
      // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
      return ((this.ax * t + this.bx) * t + this.cx) * t;
    },
    sampleCurveY: function (t) {
      return ((this.ay * t + this.by) * t + this.cy) * t;
    },
    sampleCurveDerivativeX: function (t) {
      return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
    },
    // Given an x value, find a parametric value it came from.
    solveCurveX: function (x, epsilon) {
      var t0;
      var t1;
      var t2;
      var x2;
      var d2;
      var i;
      // First try a few iterations of Newton's method -- normally very fast.
      for (t2 = x, i = 0; i < 8; i++) {
        x2 = this.sampleCurveX(t2) - x;
        if (abs(x2) < epsilon)
          return t2;
        d2 = this.sampleCurveDerivativeX(t2);
        if (abs(d2) < 0.000001)
          break;
        t2 = t2 - x2 / d2;
      }
      // Fall back to the bisection method for reliability.
      t0 = 0;
      t1 = 1;
      t2 = x;
      if (t2 < t0)
        return t0;
      if (t2 > t1)
        return t1;
      while (t0 < t1) {
        x2 = this.sampleCurveX(t2);
        if (abs(x2 - x) < epsilon)
          return t2;
        if (x > x2) {
          t0 = t2;
        } else {
          t1 = t2;
        }
        t2 = (t1 - t0) * 0.5 + t0;
      }
      // Failure.
      return t2;
    },
    solve: function (x, epsilon) {
      return this.sampleCurveY(this.solveCurveX(x, epsilon));
    }
  };
  return Animator;
}(utils, css);
constants = {
  IMAGEMAXSIZE: 250000,
  PROFILE: {
    UNKN: 1,
    IGNORE: 2,
    DESKTOP: 3,
    TABLET: 4,
    MOBILE: 5
  },
  PROFILEIDS: {
    DESKTOP: 'desktop',
    MOBILE: 'mobile'
  },
  POS: {
    // old effects
    POPUP: 5,
    BOTTOM_LEFT: 7,
    BOTTOM_RIGHT: 9,
    // not used
    CENTER_LEFT: 4,
    CENTER_RIGHT: 6,
    // new effects
    SLIDEUP: 10,
    // mobile popup slide in up, teaser at bottom (old 5)
    SLIDEUP2: 11,
    // mobile popup slide in up, teaser at top
    HELLO: 12,
    // full width slide from up, no teaser
    HELLO2: 17,
    // full width slide from bottom, no teaser
    POPUP2: 13,
    // old desktop popup, no teaser (old 5)
    POPUP7: 15,
    // old tablet popup, teaser bottom-left
    POPUP9: 16,
    // old tablet popup, teaser bottom-right
    POPUP5: 18
  },
  AL: {
    TOP_LEFT: 1,
    TOP_RIGHT: 2,
    BOTTOM_RIGHT: 3,
    BOTTOM_LEFT: 4
  },
  PA: {
    CENTER: 1,
    INSIDE: 2,
    OUTSIDE: 3,
    RIGHT: 4,
    LEFT: 5,
    BOTTOM: 6,
    TOP: 7
  },
  CONDITIONS: {
    PAGESVISITEDOPTIONS: {
      ONESESSION: 'current session',
      ALLSESSIONS: 'all sessions'
    },
    UTMSOURCE: 'utm_source',
    UTMMEDIUM: 'utm_medium',
    UTMCAMPAIGN: 'utm_campaign',
    UTMTERM: 'utm_term',
    UTMCONTENT: 'utm_content',
    // 			GROUPS: {
    // 				AND: 0,
    // 				OR: 1,
    // 			},
    GROUPS: {
      AND: true,
      OR: false
    },
    KEYS: {
      SEQUENCE: 'sequence',
      SUBSCRIBER: 'currentSubscriber',
      VISITOR: 'newVisitor',
      QUERY: 'specificQuery',
      REFERRAL: 'specificReferral',
      UTM: 'utm',
      SHOW: 'showCount',
      COOKIE: 'specificCookie',
      GEOTARGETING: 'geotargeting',
      ELEMENT: 'htmlElement',
      SITE: 'siteData',
      PAGE: 'pageCount',
      TARGETING: 'specificURL',
      IP: 'specificIP',
      URLMATCHES: 'URLMatches',
      URLCONTAINS: 'URLContains'
    },
    TYPES: {
      EXISTS: 'exists',
      NOTEXISTS: 'notExists',
      EXACTMATCH: 'exactMatch',
      NOTEXACTMATCH: 'notExactMatch',
      CONTAINS: 'contains',
      LESSTHAN: 'lessThan',
      LESSTHANEQ: 'lessThanEq',
      GREATERTHAN: 'greaterThan',
      GREATERTHANEQ: 'greaterThanEq'  /*, 'matchesList'*/,
      EQUALS: 'equals'
    },
    MATCHTYPES: {
      INCLUDE: 'include',
      EXCLUDE: 'exclude',
      NONE: 'none',
      BOTH: 'both'
    }
  },
  SUNDAY: 0,
  MONDAY: 1,
  DATETIMEFORMAT: 'DD-MM-YYYY - HH:mm',
  DATEFORMAT: 'DD-MM-YYYY',
  TIMEFORMAT: '- HH:mm',
  SCHEDULERDATEFORMAT: 'YYYY/MM/DD',
  SETUPDATEFORMAT: 'Do MMMM YYYY',
  URLPATTERN: '^((?:https?:\\/\\/)?[^./]+(?:\\.[^./]+)+(?:\\/.*)?)$',
  IPPATTERN: '^((25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.(25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.(25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.(25[0-5]|2[0-4]\\d|[01]?\\d\\d?)(,\\n|,?|,\\s))*$',
  SHOPIFYURLPATTERN: '^.*products.json$',
  MYCAMPAIGNSURL: 'https://app.sleeknote.com'
};
behaviour = function (C, U, SleekNote, B) {
  var P = C.POS;
  var CENTER = C.PA.CENTER;
  var INSIDE = C.PA.INSIDE;
  var OUTSIDE = C.PA.OUTSIDE;
  var BOTTOM = C.PA.BOTTOM;
  var TOP = C.PA.TOP;
  var MOBILE = C.PROFILE.MOBILE;
  var TABLET = C.PROFILE.TABLET;
  var DESKTOP = C.PROFILE.DESKTOP;
  var TOP_LEFT = C.AL.TOP_LEFT;
  var noIFrames = SleekNote.CustomInitSettings.noIFrames;
  /*
  
  name and type and id
  
  for ver < 4 name == type and id is v1 ones fixed
  
  for v4 and up the behaviour (interactions) is defined inside box itself, on older
  ones we define it here, inside behaviour.js - whole teaser click, what to show on submit, what to do on form/teaser close
  
  - forms sequence must be defined, if no success link is defined use the one that exist, default all teasers open first form
  - if first form is submitted, it becomes hidden
  - minimize, maximize is for current open form only
  
  
  */
  // support distanceFromEdge as padding/margin in DOM
  function getDistanceFromEdge(cfg, side) {
    var distance = cfg.distanceFromEdge === undefined ? [] : (cfg.distanceFromEdge + '').split(',');
    distance = distance.map(function (p) {
      return +p || 0;
    });
    if (distance.length > 4)
      distance.length = 4;
    var def = 0;
    // set default as 10
    if (U.empty(cfg.distanceFromEdge) && cfg.profile == DESKTOP || cfg.profile == TABLET && !SleekNote.tabletUsesMobile)
      def = 10;
    switch (distance.length) {
    case 0:
      distance = [
        def,
        def,
        def,
        def
      ];
      break;
    case 1:
      distance = [
        distance[0],
        distance[0],
        distance[0],
        distance[0]
      ];
      break;
    case 2:
      distance = [
        distance[0],
        distance[1],
        distance[0],
        distance[1]
      ];
      break;
    case 3:
      distance = [
        distance[0],
        distance[1],
        distance[2],
        distance[1]
      ];
      break;
    }
    var index = [
      'top',
      'right',
      'bottom',
      'left'
    ].indexOf(side);
    if (index < 0)
      index = 0;
    //console.log(side, distance[index]);
    return evenValue(+distance[index] || 0);
  }
  var simpleAnimations = true;
  var defaultDuration = 300;
  function evenValue(value) {
    return value % 2 ? value + 1 : value;
  }
  function custom(prop) {
    return SleekNote.CustomInitSettings && SleekNote.CustomInitSettings[prop];
  }
  function distanceFromEdges(note, reset) {
    // -1 means not specified, if set then edge now always wins over box-shadow
    // if -1 then padding only, whatever it may be
    var left = -1;
    var bottom = -1;
    var top = -1;
    var right = -1;
    //var distanceFromEdge;
    var cfg = note.config;
    // cache
    if (cfg.edge && !reset)
      return cfg.edge;
    var badge = note.controller.manager.badge;
    var badgeHeight = badge && needs.badge(cfg) ? badge.dimensions().height + (cfg.version > 1 ? 0 : 6) : 0;
    //if (cfg.type == 'teaser') debugger;
    switch (cfg.position) {
    case P.SLIDEUP2:
    case P.SLIDEUP:
      //left = right = distanceFromEdge;
      left = getDistanceFromEdge(cfg, 'left');
      right = getDistanceFromEdge(cfg, 'right');
      if (cfg.relativeWidth && cfg.relativeWidth != 100) {
        if (cfg.attach == 'right') {
          left = -1;
        } else {
          right = -1;
        }
      }
      break;
    case P.HELLO2:
    case P.HELLO:
      // sleekbar is always attached to the viewport edges
      //left = right = distanceFromEdge = 0;
      left = right = 0;
      if (cfg.position == P.HELLO) {
        top = 0;
      } else {
        bottom = 0;
      }
      break;
    }
    switch (cfg.position) {
    case P.SLIDEUP:
      if (cfg.type == 'teaser') {
        bottom = getDistanceFromEdge(cfg, 'bottom');
      } else {
        top = getDistanceFromEdge(cfg, 'top');
      }
      break;
    case P.SLIDEUP2:
      top = getDistanceFromEdge(cfg, 'top');
      break;
    case P.POPUP:
    case P.POPUP2:
    case P.POPUP7:
    case P.POPUP9:
      if (cfg.type == 'teaser') {
        bottom = getDistanceFromEdge(cfg, 'bottom');
        if (cfg.position == P.POPUP7)
          left = getDistanceFromEdge(cfg, 'left');
        if (cfg.position == P.POPUP9)
          right = getDistanceFromEdge(cfg, 'right');
      } else {
        top = cfg.profile == DESKTOP ? -1 : getDistanceFromEdge(cfg, 'top');
        left = cfg.profile == DESKTOP ? -1 : getDistanceFromEdge(cfg, 'left');
        right = cfg.profile == DESKTOP ? -1 : getDistanceFromEdge(cfg, 'right');
        bottom = cfg.profile == DESKTOP ? -1 : getDistanceFromEdge(cfg, 'bottom');
      }
      break;
    case P.CENTER_LEFT:
      if (cfg.type == 'teaser') {
        bottom = getDistanceFromEdge(cfg, 'bottom');
      } else {
        left = getDistanceFromEdge(cfg, 'left');
      }
      break;
    case P.CENTER_RIGHT:
      if (cfg.type == 'teaser') {
        bottom = getDistanceFromEdge(cfg, 'bottom');
      } else {
        right = getDistanceFromEdge(cfg, 'right');
      }
      break;
    case P.BOTTOM_LEFT:
      left = Math.max(badgeHeight, getDistanceFromEdge(cfg, 'left'));
      bottom = getDistanceFromEdge(cfg, 'bottom');
      break;
    case P.BOTTOM_RIGHT:
      right = Math.max(badgeHeight, getDistanceFromEdge(cfg, 'right'));
      bottom = getDistanceFromEdge(cfg, 'bottom');
      break;
    }
    cfg.edge = {
      top: top,
      left: left,
      bottom: bottom,
      right: right
    };
    return cfg.edge;
  }
  // this allows us to make relative relative widths as
  // it is assumed that relative applied in editor is standard iPhone portrait related
  // on lanscape and on tablet, we need different widths
  function translateRelative(config) {
    // be aware, return 0 here and CSS calc() will crash in IE and non-apply in all others
    var width = config.relativeWidth || 0;
    var unit = SleekNote.editor ? '%' : 'vw';
    if (config.relativeWidth) {
      switch (config.profile) {
      // 				case MOBILE:
      // 					unit = 'vmin';
      // 					break;
      case TABLET:
        if (!U.contains(config.position, P.HELLO, P.HELLO2)) {
          width = 100 / (B.minimalScreenDimension() / 320);
          unit = 'vmin';
        }
        break;
      }
    }
    return {
      width: width,
      unit: unit
    };
  }
  var defaults = {
    common: {
      relativeWidth: 0,
      current: 'close',
      width: 0,
      height: 0,
      attach: 'left'
    },
    spacer: function (config) {
      // either definition of selector
      var definitions = {
        bodyTop: {
          def: 'bodyTop',
          kind: 'shared',
          selector: 'body',
          insert: 'afterbegin',
          style: {
            width: ['100vw'],
            position: 'relative'
          }
        },
        selector: {
          def: 'selector',
          selector: '',
          kind: 'controller',
          insert: 'afterbegin',
          style: {
            width: '100%',
            position: 'static'
          }
        }
      };
      var obj = U.typeStr(config.placement) == 'object';
      var type = 'bodyTop';
      var definition = definitions[type];
      if (obj) {
        definition = definitions[obj.def];
      } else {
        definition = definitions[config.placement];
        if (!definition) {
          // config.placement IS selector
          definition = definitions.selector;
          definition.selector = config.placement;
        }
      }
      return U.extend({
        type: 'spacer',
        id: 'sleeknote-spacer-' + (definition.kind == 'shared' ? definition.selector : config.campaignId),
        next: config.next,
        current: config.current,
        width: [config.width],
        height: config.boundsHeight
      }, definition, obj ? config.placement : {});
    },
    badge: function (config) {
      return U.extend({}, this.common, config || {}, { type: 'badge' });
    },
    cover: function (config) {
      return U.extend({}, this.common, { type: 'cover' });
    },
    teaser: function (config) {
      var relativeWidth = +config.relativeWidth || 0;
      var attach = config.attach;
      if (config.profile == MOBILE) {
        relativeWidth = relativeWidth || 100;
        switch (config.position) {
        case P.POPUP9:
        case P.BOTTOM_RIGHT:
          attach = attach || 'right';
          break;
        default:
          attach = attach || 'left';
        }
      }
      return U.extend({}, this.common, config, {
        type: 'teaser',
        attach: attach,
        relativeWidth: relativeWidth
      });
    },
    form: function (config) {
      var relativeWidth = +config.relativeWidth || 0;
      var toggle;
      if (config.profile == MOBILE) {
        relativeWidth = relativeWidth || 100;
      }
      switch (config.position) {
      case P.SLIDEUP:
      case P.SLIDEUP2:
        relativeWidth = relativeWidth || (config.profile == MOBILE ? 100 : 0);
        break;
      case P.HELLO:
      case P.HELLO2:
        toggle = toggle || '[data-type="toggle"]';
        // this box toggles between hidden and shown state
        relativeWidth = relativeWidth || 100;
        break;
      }
      var res = U.extend({}, this.common, config, {
        type: 'form',
        toggle: toggle,
        relativeWidth: relativeWidth
      });
      return res;
    },
    success: function (config) {
      return U.extend(defaults.form(config), {
        type: 'success',
        toggle: undefined
      });
    }
  };
  /*
  	var easeOpen = [0.33, 0.66, 0.66, 1];
  	var easeClose = [0.32, 0, 1, 0.5];
  	//easing = [0, 0, 0, 1]
  	var easeInOut = [0.42, 0, 0.58, 1];
  	var easeOut = [0, 0, 0.58, 1];
  	var easeIn = [0.42, 0, 1, 1];
  	var ease = [0.25, 0.1, 0.25, 1];
  	*/
  var animations = {
    defaults: {
      ease: [
        0,
        0,
        0.58,
        1
      ],
      duration: defaultDuration,
      delay: 0,
      style: {}
    },
    create: function () {
      var args = [
        {},
        this.defaults
      ].concat(Array.prototype.slice.call(arguments));
      return U.extend.apply(null, args);
    },
    centerSlideIn: {
      rotateScale: function (p, open) {
        if (!p.rotate)
          return;
        var left = p.halign == 'left';
        var orientation = p.rotate;
        return [
          C.PA[orientation.toUpperCase()],
          CENTER,
          90 * (left ? 1 : -1),
          1
        ];
      },
      /*
      		valign: top, bottom
      		halign: left, right
      		rotate: boolean
      	*/
      open: function (p) {
        return animations.create({
          anchor: C.AL[(p.valign || 'bottom').toUpperCase() + '_' + (p.halign || 'left').toUpperCase()],
          to: [
            INSIDE,
            CENTER
          ],
          move: [
            0,
            '50%'
          ],
          rotateScale: !simpleAnimations ? this.rotateScale(p, true) : undefined,
          style: { opacity: 1 },
          duration: defaultDuration
        });
      },
      close: function (p) {
        return animations.create(this.open(p), {
          to: [
            OUTSIDE,
            CENTER
          ]
        });
      },
      // to position box inside iframe
      // TODO
      box: function (p) {
        return this.open(p);
      }
    },
    // pop up in the center of the viewport
    centerPopupSlide: {
      open: function () {
        return animations.create({
          anchor: TOP_LEFT,
          to: [
            CENTER,
            CENTER
          ],
          move: [
            '50%',
            '50%'
          ],
          animate: { opacity: 1 },
          duration: 400
        });
      },
      close: function () {
        return animations.create(this.open(), {
          ease: 'easeOut',
          move: [
            '50%',
            '45%'
          ],
          animate: { opacity: 0 },
          duration: 400
        });
      },
      closeDown: function () {
        return animations.create(this.close(), {
          move: [
            '50%',
            '55%'
          ]
        });
      },
      openSpring: function () {
        return animations.create(this.open(), {
          duration: 600,
          ease: 'wall'
        });
      }
    },
    // pop up in the center of the viewport
    centerPopupRotate: {
      open: function () {
        return animations.create({
          anchor: TOP_LEFT,
          to: [
            CENTER,
            CENTER
          ],
          move: [
            '50%',
            '50%'
          ],
          rotateScale: [
            CENTER,
            CENTER,
            [
              0,
              1,
              1,
              0
            ],
            1
          ],
          animate: { opacity: 1 },
          duration: defaultDuration
        });
      },
      close: function () {
        return animations.create(this.open(), {
          rotateScale: [
            CENTER,
            CENTER,
            [
              0,
              1,
              1,
              -180
            ],
            0.1
          ],
          ease: [
            0.25,
            0.1,
            0.25,
            1
          ],
          animate: { opacity: 0 }
        });
      },
      close2: function () {
        return animations.create(this.close(), {
          rotateScale: [
            CENTER,
            CENTER,
            [
              0,
              1,
              1,
              180
            ],
            0.1
          ]
        });
      },
      openflip: function () {
        return animations.create(this.open(), {
          style: { backfaceVisibility: 'hidden' },
          ease: [
            0.5,
            0,
            0.5,
            1
          ],
          origin: [
            0,
            0.5
          ],
          rotateScale: [
            CENTER,
            CENTER,
            [
              1,
              0,
              0,
              0
            ],
            1
          ]
        });
      },
      closeflip: function () {
        return animations.create(this.close(), {
          style: { backfaceVisibility: 'hidden' },
          ease: [
            0.5,
            0,
            0.5,
            1
          ],
          rotateScale: [
            CENTER,
            CENTER,
            [
              1,
              0,
              0,
              -180
            ],
            1
          ],
          origin: [
            0,
            0.5
          ],
          animate: { opacity: 1 }
        });
      },
      closeflip2: function () {
        return animations.create(this.closeflip(), {
          rotateScale: [
            CENTER,
            CENTER,
            [
              1,
              0,
              0,
              180
            ],
            1
          ]
        });
      }
    },
    // the same as centerPopup except vertically on top and slide from top
    topCenterPopup: {
      open: function () {
        return animations.create(animations.centerPopupSlide.open(), {
          to: [
            CENTER,
            INSIDE
          ],
          move: [
            '50%',
            0
          ]
        });
      },
      close: function () {
        return animations.create(animations.centerPopupSlide.close(), {
          to: [
            CENTER,
            OUTSIDE
          ],
          move: [
            '50%',
            0
          ]
        });
      }
    },
    // slide in
    basicSlideIn: {
      /*
      		move: number
      		valign: top, bottom
      		halign: left, right
      	*/
      open: function (p) {
        //debugger;
        //				console.log(p.move);
        //				if (p.move == 0) debugger;
        return animations.create({
          anchor: C.AL[(p.valign || 'top').toUpperCase() + '_' + (p.halign || 'left').toUpperCase()],
          to: [
            C.PA[p.center ? 'CENTER' : 'INSIDE'],
            INSIDE
          ],
          //move: p.center ? ['50%', 0] : undefined,
          move: p.center ? [
            '50%',
            p.move.y
          ] : [
            p.move.x,
            p.move.y
          ],
          rotateScale: !simpleAnimations ? [
            CENTER,
            CENTER,
            0,
            1
          ] : undefined,
          //origin: [p.halign == 'right' ? 1 : p.halign == 'left' ? 0 : 0.5, p.valign == 'bottom' ? 1 : p.valign == 'top' ? 0 : 0.5],
          origin: [
            p.halign == 'right' ? 1 : 0,
            p.valign == 'bottom' ? 1 : 0
          ],
          ease: [
            0.25,
            0.1,
            0.25,
            1
          ],
          duration: 600,
          style: { opacity: 1 }
        });
      },
      close: function (p) {
        return animations.create(this.open(p), {
          to: [
            C.PA[p.center ? 'CENTER' : 'INSIDE'],
            OUTSIDE
          ],
          ease: [
            0.42,
            0,
            1,
            1
          ],
          move: p.center ? [
            '50%',
            0
          ] : [
            p.move.x,
            0
          ],
          rotateScale: !simpleAnimations ? [
            CENTER,
            CENTER,
            0,
            0.1
          ] : undefined
        });
      },
      half: function (p) {
        var res = animations.create(this.open(p));
        //				res.move || (res.move = [0, 0]);
        //				res.move[1] = +p.move || 0;
        return res;
      }
    },
    badgeSlideIn: {
      /*
      		halign: center, left, right
      	*/
      open: function (p) {
        var align = (p.halign || 'left').toUpperCase();
        return animations.create({
          anchor: C.AL['BOTTOM_' + (align == 'CENTER' ? 'LEFT' : align)],
          to: [
            align == 'CENTER' ? CENTER : INSIDE,
            INSIDE
          ],
          move: align == 'CENTER' ? [
            '50%',
            0
          ] : undefined,
          rotateScale: align == 'CENTER' ? undefined : [
            C.PA[align],
            BOTTOM,
            -90,
            1
          ],
          duration: defaultDuration
        });
      },
      close: function (p) {
        var align = (p.halign || 'left').toUpperCase();
        return animations.create(this.open(p), {
          ease: [
            0.25,
            0.1,
            0.25,
            1
          ],
          rotateScale: align == 'CENTER' ? undefined : [
            C.PA[align],
            TOP,
            -90,
            1
          ],
          to: [
            align == 'CENTER' ? CENTER : INSIDE,
            OUTSIDE
          ]
        });
      }
    },
    grow: {
      open: function (p) {
        return animations.create({
          anchor: TOP_LEFT,
          to: [
            INSIDE,
            INSIDE
          ],
          animate: {
            //paddingTop: p.height
            height: p.height
          }
        });
      },
      close: function (p) {
        return animations.create(this.open(p), {
          animate: {
            //paddingTop: 0
            height: 0
          }
        });
      },
      half: function (p) {
        return animations.create(this.open(p));
      }
    },
    fadeIn: {
      open: function () {
        return animations.create({
          anchor: TOP_LEFT,
          to: [
            INSIDE,
            INSIDE
          ],
          ease: 'linear',
          origin: [
            0,
            0
          ],
          animate: { opacity: 1 }
        });
      },
      close: function () {
        return animations.create(this.open(), {
          delay: 100,
          animate: { opacity: 0 }
        });
      }
    }
  };
  function hasCover(config) {
    switch (config.position) {
    case P.SLIDEUP:
    case P.SLIDEUP2:
      if (config.profile != DESKTOP)
        return true;
      break;
    case P.POPUP:
    case P.POPUP2:
    case P.POPUP5:
    case P.POPUP7:
    case P.POPUP9:
      return true;
    }
  }
  var needs = {
    spacer: function (config) {
      //if (config.profile == MOBILE) return false;
      var res = !U.empty(config.placement) && isTopSleekBar(config);
      // hook for some early customers with fixed headers
      if (res && config.placement == 'bodyTop') {
        return !custom('nospacer');
      }
      return res;
    },
    badge: function (config) {
      // we could have badge on top, but can't on bottom and can't when injected, so disable altogether
      if (B.is.ie)
        return false;
      //PP: I am not going to fix it for IE,
      if (U.contains(config.position, P.HELLO, P.HELLO2))
        return false;
      return false;  // return U.contains(config.type, 'form', 'success') && config.profile == DESKTOP;
    },
    cover: function (config) {
      if (!U.contains(config.type, 'form', 'success'))
        return false;
      return hasCover(config);
    }
  };
  var componentAnimations = {
    spacer: function (config, func, note) {
      var height = config.height;
      if (note && note.config.toggle) {
        var toggleDOMNode = U.qs(note.config.toggle, note.config.boxNode);
        if (toggleDOMNode) {
          var tb = toggleDOMNode.getBoundingClientRect();
          height = tb.height;
        }
      }
      return animations.grow[func]({ height: height });
    },
    badge: function (config, func) {
      var halign = 'center';
      switch (config.position) {
      case P.CENTER_LEFT:
      case P.BOTTOM_LEFT:
        halign = 'left';
        break;
      case P.CENTER_RIGHT:
      case P.BOTTOM_RIGHT:
        halign = 'right';
        break;
      }
      return animations.badgeSlideIn[func]({ halign: halign });
    },
    cover: function (config, func) {
      return animations.fadeIn[func]();
    },
    form: function (config, func, companion, to) {
      //var basicSlideIn = {
      /*
      	move: number
      	valign: top, bottom
      	halign: left, right
      */
      var valign;
      var halign;
      var animation = 'topCenterPopup';
      var move = config.move ? U.extend(config.move) : {
        x: 0,
        y: 0
      };
      //var animateTo = to;
      //var animateFrom = !to;
      switch (config.position) {
      case P.SLIDEUP:
      case P.SLIDEUP2:
        valign = 'top';
        animation = 'basicSlideIn';
        break;
      case P.HELLO:
        animation = 'basicSlideIn';
        valign = 'top';
        break;
      case P.HELLO2:
        animation = 'basicSlideIn';
        valign = 'bottom';
        break;
      case P.POPUP:
      case P.POPUP2:
        animation = 'centerPopupSlide';
        // default
        if (companion) {
          if (config.type == 'form') {
            if (companion == 'teaser') {
              if (func == 'open')
                func = 'openSpring';
            }
            if (companion == 'success') {
              if (func == 'close')
                func = 'closeDown';
            }
          }
        }
        break;
      case P.POPUP5:
      case P.POPUP7:
      case P.POPUP9:
        animation = 'topCenterPopup';
        break;
      case P.CENTER_LEFT:
        halign = 'left';
        valign = 'bottom';
        animation = 'centerSlideIn';
        break;
      case P.CENTER_RIGHT:
        halign = 'right';
        valign = 'bottom';
        animation = 'centerSlideIn';
        break;
      case P.BOTTOM_LEFT:
        animation = 'basicSlideIn';
        halign = 'left';
        valign = 'bottom';
        break;
      case P.BOTTOM_RIGHT:
        animation = 'basicSlideIn';
        halign = 'right';
        valign = 'bottom';
        break;
      }
      if (func == 'half' && config.toggle) {
        var toggleDOMNode = U.qs(config.toggle, config.boxNode);
        var tb = toggleDOMNode.getBoundingClientRect();
        var bb = config.boxNode.getBoundingClientRect();
        if (tb.height) {
          switch (config.position) {
          case P.HELLO:
            if (noIFrames) {
              move.y = -(tb.top - bb.top);
            } else {
              move.y = -tb.top;
            }
            break;
          case P.HELLO2:
            if (noIFrames) {
              move.y = -(bb.height - tb.height);
            } else {
              move.y = tb.height - config.boundsHeight;
            }
            break;
          }
        }
      }
      if (!animations[animation][func])
        func = 'open';
      return animations[animation][func]({
        halign: halign,
        valign: valign,
        move: move
      });
    },
    success: function (config, func, companion, to) {
      return this.form(config, func, companion, to);
    },
    teaser: function (config, func) {
      var halign;
      var valign;
      var rotate;
      var center;
      var move = config.move ? U.extend(config.move) : {
        x: 0,
        y: 0
      };
      var animation = 'basicSlideIn';
      switch (config.position) {
      case P.SLIDEUP:
        valign = 'bottom';
        if (config.attach && config.relativeWidth < 100) {
          halign = config.attach;
        } else {
          if (config.profile == MOBILE) {
            halign = 'left';
          } else {
            center = true;
          }
        }
        break;
      case P.SLIDEUP2:
        valign = 'top';
        if (config.attach && config.relativeWidth < 100) {
          halign = config.attach;
        } else {
          if (config.profile == MOBILE) {
            halign = 'left';
          } else {
            center = true;
          }
        }
        break;
      case P.POPUP:
      case P.POPUP2:
      case P.POPUP5:
        center = true;
        valign = 'bottom';
        break;
      case P.CENTER_LEFT:
        rotate = 'left';
        halign = 'left';
        valign = 'bottom';
        animation = 'centerSlideIn';
        break;
      case P.CENTER_RIGHT:
        rotate = 'right';
        halign = 'right';
        valign = 'bottom';
        animation = 'centerSlideIn';
        break;
      case P.POPUP7:
      case P.BOTTOM_LEFT:
        halign = 'left';
        valign = 'bottom';
        break;
      case P.POPUP9:
      case P.BOTTOM_RIGHT:
        halign = 'right';
        valign = 'bottom';
        break;
      }
      // for most positions the 'box' is equal to 'open'
      if (!animations[animation][func])
        func = 'open';
      return animations[animation][func]({
        halign: halign,
        valign: valign,
        center: center,
        rotate: rotate,
        move: move
      });
    }
  };
  function isSleekBar(config) {
    return U.contains(config.position, P.HELLO, P.HELLO2);
  }
  function isTopSleekBar(config) {
    return U.contains(config.position, P.HELLO);
  }
  function animationParameters(note, from, to, companion) {
    // from&to -> open, close, half,
    var type = note.config.type;
    //if (!(type in defaults)) return;
    var res = U.extend({
      description: {
        name: note.config.name,
        what: type,
        to: to,
        from: from,
        obj: note
      }
    }, note.config, note.dimensions());
    res.from = componentAnimations[type](res, from, companion, false);
    res.to = componentAnimations[type](res, to, companion, true);
    if (res.to) {
      res.duration = res.to.duration;
      res.delay = res.to.delay;
      res.ease = res.to.ease;
      if (~SleekNote.debug.indexOf('a'))
        res.duration *= 10;
      res.duration *= 1;
    }
    return res;
  }
  function boxParameters(note, pos) {
    var res = U.extend({}, note.config, note.dimensions());
    res.to = componentAnimations[note.config.type](res, pos);
    res.next = pos;
    return res;
  }
  function DOMNodeScrolling(config, editor, editorVersion) {
    var profile = config.profile;
    var type = config.type;
    var widthAdjustment = 0;
    var className = '';
    var style = { overflow: 'visible' };
    //maxHeight = noIFrames ? '100%' : 'calc(' + maxHeight + ' + ' + this.spaceAmount() + 'px)';
    if (!isSleekBar(config)) {
      // no scrollbars whatsoever for sleekbars
      style.maxHeight = editor && noIFrames && editorVersion >= 4 ? '100%' : '100vh';
      if (profile == MOBILE) {
        if (type != 'teaser') {
          // allow horizontal scrollbars on mobile
          Object.assign(style, {
            webkitOverflowScrolling: 'touch',
            overflowY: 'auto',
            overflowX: 'hidden'
          });
          className = 'form';
          if (editor) {
            // in editor we need to hide scrollbars with this trick
            style.overflowY = 'scroll';
            widthAdjustment = B.systemScrollbarWidth();
          }
        }
      } else {
      }
    }
    return {
      style: style,
      widthAdjustment: widthAdjustment,
      className: className
    };
  }
  return {
    DOMNodeScrolling: DOMNodeScrolling,
    translateRelative: translateRelative,
    //paddings: paddings,
    defaults: function (type, config) {
      return type in defaults ? defaults[type](config) : config;
    },
    isSleekBar: isSleekBar,
    isPopup: function (config) {
      if (config.profile != DESKTOP)
        return;
      switch (config.position) {
      case P.POPUP:
      case P.POPUP2:
      case P.POPUP5:
      case P.POPUP7:
      case P.POPUP9:
        return true;
      }
    },
    needs: needs,
    distanceFromEdges: distanceFromEdges,
    animationParameters: animationParameters,
    boxParameters: boxParameters
  };
}(constants, utils, core_common, browser);
layout_new = function (B, U, Animator, CSS, CONST, SleekNote, behaviour) {
  var win = this;
  var doc;
  // this is now expected to come from layout.initialize()
  var body;
  // this is 'body' tag where we insert stuff
  function custom(prop) {
    return SleekNote.CustomInitSettings && SleekNote.CustomInitSettings[prop];
  }
  var noIFrames = SleekNote.CustomInitSettings.noIFrames;
  var wrap = '<{tagName} id="{id}" class="{className}" {conceal} style="{style}">{frame}</{tagName}>';
  var conceal = 'data-conceal=\'{data}\'';
  var debug = 0;
  var sleeknoteFrame = U.randomName();
  var frameStyle = {
    display: 'block!important',
    position: 'static!important',
    boxSizing: 'border-box!important',
    background: 'transparent!important',
    border: 'none!important',
    minHeight: '0!important',
    maxHeight: 'none!important',
    margin: '0!important',
    padding: '0!important',
    /*
    		back in the old days IFRAME 100% was problematic, hence the inherit here, but these days it seems to work
    		Chrome 75 broke inherit (on height), added 100%
    	*/
    height: '100%!important',
    width: '1px!important',
    maxWidth: '100%!important',
    minWidth: '100%!important'
  };
  var sleeknoteWrap = U.randomName();
  var sleeknoteWrapStyle = {
    display: 'block',
    position: 'relative',
    top: 0,
    left: 0,
    padding: 0,
    margin: 0,
    border: 'none',
    boxSizing: 'border-box',
    backgroundColor: debug ? 'rgba(255,127,0,0.5)' : 'transparent',
    willChange: 'transform, opacity',
    transitionDuration: 0,
    height: 0,
    width: '100vw'
  };
  var sleeknoteWrapNoIFrame = U.randomName();
  var sleeknoteWrapNoIFrameStyle = {
    overflow: 'visible',
    // 		overflowX: 'hidden',
    // 		overflowY: 'auto',
    //pointerEvents: 'none',
    pointerEvents: 'auto',
    backfaceVisibility: 'hidden',
    //visibility: 'hidden',
    zIndex: -1,
    display: 'block',
    position: 'absolute',
    padding: 0,
    margin: 0,
    border: 'none',
    boxSizing: 'border-box',
    backgroundColor: debug ? 'rgba(255,127,0,0.5)' : 'transparent',
    willChange: 'transform, opacity',
    transitionDuration: 0,
    width: '100%'
  };
  var initialHTML = '<!doctype html><html><head></head><body></body></html>';
  function getFrame(div) {
    return div.querySelector('.' + sleeknoteFrame);
  }
  function useSrcDoc(opt) {
    return !(B.is.ie || opt.useDocumentWrite);
  }
  function createIFrame(opt, wrap) {
    var frame = win.document.createElement('iframe');
    frame.className = sleeknoteFrame;
    useSrcDoc(opt) && frame.setAttribute('srcdoc', initialHTML);
    frame.onload = function () {
      onload.call(this, opt, wrap);
    };
    return frame;
  }
  function createWrap(opt, className) {
    var wrapStyle = opt.style || {};
    var style = opt.concealed ? CSS.concealedStyle(wrapStyle) : CSS.inline(wrapStyle);
    return U.insertHTML(opt.parent, U.template(wrap, {
      tagName: opt.tagName || 'span',
      id: opt.id,
      className: className + ' ' + (opt.className || ''),
      conceal: opt.concealed ? U.template(conceal, { data: CSS.concealedData(wrapStyle) }) : '',
      style: style
    }), opt.position || 'beforeend');
  }
  function onload(opt, wrap) {
    var frameElement = this;
    frameElement.onload = undefined;
    var docum = U.getDocument(frameElement);
    if (useSrcDoc(opt)) {
      debug && console.log('using srcdoc', frameElement.getAttribute('srcdoc'));
    } else {
      debug && console.log('using document.write');
      docum.open();
      docum.write(initialHTML);
      docum.close();
    }
    debug && console.log(docum.doctype, docum.compatMode);
    var content = opt.content || '';
    if (content.querySelector) {
      // DOM with head and body tags
      var e = 'documentElement';
      [
        'head',
        'body'
      ].forEach(function (str) {
        docum[e].replaceChild(content.querySelector(str), docum[e].querySelector(str));
      });
    } else if (U.typeStr(content) == 'function') {
      content(docum);
    } else {
      docum.body.innerHTML = content;
    }
    opt.onload && opt.onload(wrap, docum);
    if (opt.onresize) {
      U.getWindow(frameElement).addEventListener(/*B.is.ios || B.is.android ? 'orientationchange' :*/
      'resize', opt.onresize);
    }
  }
  var rulesAdded = false;
  function addRules(docum) {
    if (!rulesAdded) {
      CSS.addRuleObj('.' + sleeknoteWrap, sleeknoteWrapStyle, docum);
      CSS.addRuleObj('.' + sleeknoteWrapNoIFrame, sleeknoteWrapNoIFrameStyle, docum);
      CSS.addRuleObj('iframe.' + sleeknoteFrame + ':not(p)', frameStyle, docum);
      rulesAdded = true;
    }
  }
  function insertIFrame(opt) {
    var wrap = createWrap(opt, sleeknoteWrap);
    var frame = createIFrame(opt, wrap);
    wrap.appendChild(frame);
  }
  function insertPlain(opt) {
    var wrap = createWrap(opt, sleeknoteWrapNoIFrame);
    var content = opt.content || '';
    if (content.querySelector) {
      wrap.appendChild(content.querySelector('body').firstElementChild);
    } else if (U.typeStr(content) == 'function') {
      content(wrap);
    } else {
      wrap.innerHTML = content;
    }
    opt.onload(wrap, wrap.ownerDocument);
  }
  function insertForCore(opt) {
    var docum = opt.parent.ownerDocument;
    addRules(docum);
    return noIFrames ? insertPlain(opt) : insertIFrame(opt);
  }
  function css(div, style, frameStyle) {
    // split props between div/iframe
    CSS.cssConcealed(div, style);
    var frame = getFrame(div);
    frameStyle || (frameStyle = {});
    if (frame) {
      if (U.empty(frameStyle))
        return;
      CSS.cssConcealed(frame, frameStyle, true);
    }
  }
  var anchorClassName = U.randomName();
  var anchorStyle = {
    direction: 'ltr!important',
    position: 'fixed',
    display: 'block',
    width: '100%',
    height: 0,
    margin: 0,
    padding: 0,
    overflow: 'visible',
    transformStyle: 'preserve-3d',
    //pointerEvents: 'none',
    background: 'transparent',
    backfaceVisibility: 'hidden',
    visibility: 'hidden',
    left: 0
  };
  var anchorRule;
  function createAnchor(target, top, editorVersion) {
    if (editorVersion == 4) {
      anchorStyle.position = 'absolute';
      anchorStyle.height = '100%';
    }
    if (!anchorRule) {
      anchorRule = CSS.addRuleObj('.' + anchorClassName, anchorStyle, doc);
    }
    var anchor = U.insertHTML(target, '<anchor class="sleeknote-anchor ' + anchorClassName + '" aria-hidden=true></anchor>', editorVersion == 2 ? 'afterend' : 'beforeend');
    anchor.style[top ? 'top' : 'bottom'] = 0;
    SleekNote.debug && (anchor.style.outline = '10px red solid');
    return anchor;
  }
  var A = CONST.AL;
  var PA = CONST.PA;
  var angles = [
    0,
    90,
    180,
    270
  ];
  function bounds(elem) {
    // we can pass cached getBoundingClientRect() results too
    return elem.nodeName ? elem.getBoundingClientRect() : elem;
  }
  function getAngle(val) {
    if (Array.isArray(val)) {
      if (!val[0] && !val[1]) {
        // rotateZ is plain 2D rotate
        return +val[3] || 0;
      } else {
        // 3D rotate not supported
        return 0;
      }
    }
    return val;
  }
  function Positioner() {
  }
  Positioner.prototype = {
    position: function (param, DOMNode, heightUnit) {
      this.bounds = bounds(DOMNode);
      this.elem = DOMNode;
      this.anchor = param.anchor;
      this.translate = [
        0,
        0
      ];
      this.translatePx = [
        0,
        0
      ];
      this.angle = 0;
      this.scale = 1;
      this.style = { position: 'absolute' };
      this.heightUnit = heightUnit ? heightUnit : 'vh';
      return this;
    },
    css: function (style) {
      U.extend(this.style, style);
      return this;
    },
    origin: function (horizontally, vertically) {
      if (vertically === undefined)
        vertically = horizontally;
      if (horizontally !== undefined)
        this.style.transformOrigin = [
          horizontally,
          vertically
        ];
      return this;
    },
    // center, inside, outside
    to: function (horiz, vert) {
      if (vert === undefined)
        vert = horiz;
      var t = this.translate;
      function set(p, r) {
        var d = p == 1 ? vert : horiz;
        t[p] = (r ? 1 : -1) * (d == PA.CENTER ? 50 : d == PA.INSIDE ? 0 : 100);
      }
      //debugger;
      switch (this.anchor) {
      case A.TOP_RIGHT:
        set(0, 1);
        set(1, 0);
        break;
      case A.BOTTOM_RIGHT:
        set(0, 1);
        set(1, 1);
        break;
      case A.BOTTOM_LEFT:
        set(0);
        set(1, 1);
        break;
      default:
        // TOP_LEFT
        set(0);
        set(1);
      }
      return this;
    },
    move: function (horiz, vert) {
      // only % or 0 is allowed to t,l,br
      var s = this.style;
      if (vert === undefined)
        vert = horiz;
      if (horiz === undefined)
        return this;
      var ph = 0;
      var pv = 0;
      if (horiz && horiz === +horiz) {
        ph = horiz;
        horiz = 0;
      }
      if (vert && vert === +vert) {
        pv = vert;
        vert = 0;
      } else {
        vert = parseInt(vert, 10) + this.heightUnit;
      }
      //console.log('move', this.anchor, vert, horiz);
      s.top = s.right = s.bottom = s.left = 'auto';
      switch (this.anchor) {
      case A.TOP_RIGHT:
        s.top = vert;
        s.right = horiz;
        ph = -ph;
        break;
      case A.BOTTOM_RIGHT:
        s.bottom = vert;
        s.right = horiz;
        ph = -ph;
        pv = -pv;
        break;
      case A.BOTTOM_LEFT:
        s.bottom = vert;
        s.left = horiz;
        pv = -pv;
        break;
      default:
        // TOP_LEFT
        s.top = vert;
        s.left = horiz;
      }
      this.translatePx[0] = ph;
      this.translatePx[1] = pv;
      return this;
    },
    /*
    			this one allows simple rotations (+-90deg only ) and scaling. Result will be aligned to orignal
    			DOM element.
    
    			For example: 
    			
    			A) Let's say we have 200px x 100px box (teaser) that we like to have positioned just outside of
    			viewport, right, and rotated -90deg (or BoxAndBarAlignment as '6'). Also we want to have it shrinked
    			by half. Assume that our box is already placed there, in its original size.
    			
    			The task left is to rotate it so that rotated box is still in the center and scale it to 0.5 so that left edge
    			touches viewports left edge. To achieve that we need to apply the following tranform:
    			
    			transform-origin: 50% 50%;
        		transform: translate(-75px, 0px) rotate(-90deg) scale(0.5);
    
    			B) Let's say we have that same box and need to place it as we place Badge with BoxAndBarAlignment as '9'. For
    			that we initally place Badge box with BOTTOM_RIGHT anchor horizontally OUTSIDE, vertically INSIDE. Here too
    			we rotate badge by -90deg, but instead of center alignement, we need to align badge with bottom of the box, for
    			that we need transform
    			
    			transform-origin: 50% 50%;
        		transform: translate(-50px, -50px) rotate(-90deg);
    
    			The function below takes care of all this 'magic'
    
    		*/
    // only steps of 90deg's are allowed
    // horiz: LEFT,RIGHT,CENTER
    // vert: TOP,BOTTOM,CENTER
    rotateScale: function (horiz, vert, angle, scale) {
      if (this.bounds && horiz !== undefined && vert !== undefined) {
        this.scale = +scale || 1;
        this.angle = Array.isArray(angle) ? angle : +angle || 0;
        // allow only 90deg multiples
        // TODO: im not sure what to do with 3d rotations, i just assume no rotation at all, lets see
        // TODO: support 2d rotate in 3d notation
        var nangle = getAngle(this.angle) % 360;
        if (nangle < 0)
          nangle += 360;
        // in case of Array we never get here to reset angle...
        if (!~angles.indexOf(nangle))
          nangle = angle = 0;
        var rotated = nangle && nangle - 180;
        var width = rotated ? this.bounds.height : this.bounds.width;
        var height = rotated ? this.bounds.width : this.bounds.height;
        if (horiz != PA.CENTER)
          this.translate[0] += (horiz == PA.LEFT ? -1 : 1) * (this.bounds.width - width * this.scale) / 2 / this.bounds.width * 100;
        if (vert != PA.CENTER)
          this.translate[1] += (vert == PA.BOTTOM ? -1 : 1) * (height * this.scale - this.bounds.height) / 2 / this.bounds.height * 100;
      } else {
        this.scale = 1;
        this.angle = 0;
      }
      return this;
    },
    set: function (elem) {
      CSS.set(elem || this.elem, this.get());
      return this;
    },
    get: function () {
      //this.style.transformOrigin = '50% 50%';
      this.style.transform = [
        this.translate[0] + '%',
        this.translate[1] + '%'
      ];
      //if (getAngle(this.angle) || this.scale !== 1 || this.translatePx[0] || this.translatePx[1]) {
      if (Array.isArray(this.angle) || this.angle || this.scale !== 1 || this.translatePx[0] || this.translatePx[1]) {
        this.style.transform = [
          this.style.transform,
          this.angle,
          this.scale,
          undefined,
          this.translatePx
        ];
      }
      //console.log(JSON.stringify(this.style.transform));
      return this.style;
    },
    /*
    			Use this to create animations:
    			- 'from' & 'to' are both output of get()
    			-  usually you just cant blindly animate from 'from' to 'to' because for example some of top,left,right,bottom
    			are 'auto' on one side and numeric on other side.
    			- it will take 'to' as anchor and calculates CSS properties to position 'elem' at 'from' position,
    			using only transform, so by animating that transform, everything works as expected
    			- for animation the you set inital 'to' as endpoint and styles calculated here as startpoint
    			
    			TODO: this currently uses DOM to measure boundingBox's
    
    		*/
    prepForTrans: function (elem, from, to, doNotSet) {
      //var clone;
      //var eb;
      // 			function getBounds(style) {
      // 				// position clone and measure position
      // 				var cloneStyle = U.extend({}, style, {
      // 					visibility: 0,
      // 					width: eb.width,
      // 					height: eb.height,
      // 				});
      // 				if (style == 'to') cloneStyle.position = 'absolute';
      // 				if (Array.isArray(cloneStyle.transform[0])) cloneStyle.transform[2] = 1;
      // 				CSS.set(clone, cloneStyle);
      // 				return bounds(clone);
      // 			}
      var res;
      //var vis;
      // if theres no need to do anything
      // these may be arrays now, therefore convert
      if (String(from.left) == String(to.left) && String(from.top) == String(to.top) && String(from.bottom) == String(to.bottom) && String(from.right) == String(to.right)) {
        res = U.extend({}, from, { visibility: 1 });
      } else {
        var fb;
        var tb;
        // do we have inline visibility set?
        //vis = elem.style.visibility;
        // 				clone = U.insertHTML(elem, '<div></div>', 'beforebegin');
        // 				eb = elem.getBoundingClientRect();
        // 				fb = getBounds(from);
        // 				tb = getBounds(to);
        //
        // 				U.removeNode(clone);
        var old = elem.style.cssText;
        var box = elem;
        //.firstElementChild;
        CSS.set(box, to);
        tb = bounds(box);
        CSS.set(box, from);
        fb = bounds(box);
        res = U.extend({}, to);
        // 				res = U.extend({}, to, {
        // 					visibility: 1,
        // 				});
        // measure distance from center to center
        var dx = fb.left + fb.width / 2 - (tb.left + tb.width / 2);
        var dy = fb.top + fb.height / 2 - (tb.top + tb.height / 2);
        var target = U.extend(Array.isArray(res.transform[0]) ? res.transform[0] : res.transform);
        //var scale = Array.isArray(to.transform[0]) ? to.transform[2] : 1;
        // TODO, figure out the scaling effect later, this works now, if we set scale to 1 on both ends, regardless what it is
        var scale = 1;
        var nangle = (Array.isArray(to.transform[0]) ? +to.transform[1] || 0 : 0) % 360;
        if (nangle < 0)
          nangle += 360;
        var rotated = nangle && nangle - 180;
        var width = rotated ? tb.height : tb.width;
        var height = rotated ? tb.width : tb.height;
        target[0] = dx / (width / scale) * 100 + parseInt(target[0], 10) + '%';
        target[1] = dy / (height / scale) * 100 + parseInt(target[1], 10) + '%';
        // 				res.transform = target;
        // 				if (Array.isArray(from.transform[0])) res.transform = [target, from.transform[1], from.transform[2]];
        res.transform = Array.isArray(res.transform[0]) || Array.isArray(from.transform[0]) ? [target] : target;
        if (Array.isArray(to.transform[0])) {
          res.transform[1] = to.transform[1];
          res.transform[2] = to.transform[2];
        }
        if (Array.isArray(from.transform[0])) {
          res.transform[1] = from.transform[1];
          res.transform[2] = from.transform[2];
        }
        if (to.transform[4])
          res.transform[4] = to.transform[4];
      }
      //set new 'from' if desired
      if (doNotSet) {
        if (old)
          elem.style.cssText = old;  // 				if (vis) {
                                     // 					CSS.set(elem, vis);
                                     // 				}
      } else {
        CSS.set(elem, res);
      }
      return res;
    }
  };
  var positioner = new Positioner();
  var blendTransformArray = function (from, to, pos) {
    function calc(a, b) {
      var p = a.indexOf ? a.indexOf('%') : -1;
      if (~p) {
        a = parseInt(a, 10);
        b = parseInt(b, 10);
      }
      var r = (a + (b - a) * pos).toFixed(6);
      //if (p && Math.floor(Math.abs(r) - 0.1) <= 0) r = 0;
      if (~p)
        r = r + '%';
      return r;
    }
    if (!Array.isArray(from[0])) {
      return [
        calc(from[0], to[0]),
        calc(from[1], to[1])
      ];
    }
    var translate = [
      calc(from[0][0], to[0][0]),
      calc(from[0][1], to[0][1]),
      0
    ];
    // allow out of bounds translate
    pos = U.limit(pos, 0, 1);
    var rotate = Array.isArray(from[1]) ? [
      from[1][0],
      from[1][1],
      from[1][2],
      calc(from[1][3], to[1][3])
    ] : calc(from[1], to[1]);
    var ret = [
      translate,
      rotate,
      from[2] + (to[2] - from[2]) * pos
    ];
    // not animating perspective, pick either one
    if (from[3] !== undefined || to[3] !== undefined)
      ret[3] = from[3] === undefined ? to[3] : from[3];
    if (from[4] !== undefined || to[4] !== undefined) {
      ret[4] = [
        calc(from[4][0], to[4][0]),
        calc(from[4][1], to[4][1])
      ];  //console.log(from[4][1], to[4][1]);
    }
    //console.log(JSON.stringify(ret));
    return ret;
  };
  var layout = {
    sleeknoteWrap: noIFrames ? sleeknoteWrapNoIFrame : sleeknoteWrap,
    viewportUnitRatio: function () {
      return 1;
    },
    getFrameScale: function () {
      return 1;
    },
    getDocument: function () {
      return doc;
    },
    initialize: function (contentWindow, editorVersion) {
      editorVersion && (this.editorVersion = editorVersion);
      if (this.editorVersion == 4) {
        body = contentWindow;
        doc = body.ownerDocument;
      } else {
        if (contentWindow) {
          win = contentWindow;
        }
        doc = win.document;
        body = doc.body;
      }
      U.qsa('.' + anchorClassName, body).forEach(U.removeNode);
      this.bottom = createAnchor(body, false, this.editorVersion);
      this.top = createAnchor(body, true, this.editorVersion);
    },
    onReposition: false,
    // showQueue to fill
    prepareForAnimation: function (motions) {
      var indexes = U.filterMap(motions, function (motion) {
        if (U.contains(motion.description.what, 'cover', 'badge') || motion.description.to == 'close')
          return;
        var note = motion.description.obj;
        var z = Number(U.getAdvOption(note.controller.config, note.config.profile == CONST.PROFILE.MOBILE ? 'zindexes-mobile' : 'zindexes-desktop', note.config.type == 'teaser' ? 1 : 2));
        if (isNaN(z))
          z = 99999;
        return {
          zIndex: z,
          DOMNode: note.config.DOMNode
        };
      });
      if (indexes.length) {
        var z = indexes[0].zIndex;
        var n = indexes[0].DOMNode;
        if (this.top.contains(n)) {
          this.top.style.zIndex = Math.max(this.top.style.zIndex, z);
        } else if (this.bottom.contains(n)) {
          this.bottom.style.zIndex = Math.max(this.bottom.style.zIndex, z);
        }
        n.style.zIndex = z;
      }
    },
    prepForTrans: function (elem, from, to, doNotSet) {
      return positioner.prepForTrans(elem, from, to, doNotSet);
    },
    css: function (config, nodeName, style, node) {
      // in rare cases like in this.insert() we yet do not have config[nodeName]
      var frameStyle = {};
      node || (node = config[nodeName]);
      if (!node)
        return;
      return css(node, style, frameStyle);
    },
    doc: function (obj) {
      return obj && U.getDocument(getFrame(obj)) || obj;
    },
    // this is for errortip only
    absolutePositionBegin: function (elemAnchor, elem) {
      return positioner.position({ anchor: elemAnchor }, elem);
    },
    // for note submit, mimic old layout
    getAnchor: function () {
      return { DOMNode: this.top };
    },
    createPositionStyles: function (config, prop) {
      //console.log('createPositionStyles');
      var param = config[prop];
      //if (!param) debugger;
      var pos = positioner.position(param, config.DOMNode, this.editorVersion == 4 && '%');
      var s = param.style || (param.style = {});
      if (config.isHidden) {
        s.visibility = 0;
      }
      s.width = config.width;
      s.height = config.height;
      Object.keys(param.animate || {}).forEach(function (key) {
        s[key] = param.animate[key];
      });
      var rotateScale = U.extend(param.rotateScale);
      if (this.getFrameScale() != 1 && !rotateScale) {
        rotateScale = [
          CONST.PA.CENTER,
          CONST.PA.CENTER,
          0,
          1
        ];
        rotateScale[3] *= this.getFrameScale();
      }
      var res = pos.move.apply(pos, param.move).move.apply(pos, (config.translatePx || [,]).concat(true)).to.apply(pos, param.to).rotateScale.apply(pos, rotateScale).origin.apply(pos, param.origin).css(s).get();
      return res;
    },
    createMotion: function (config, callback) {
      var animatables = Object.keys(config.to.animate || {});
      var motion = {
        ease: Animator.makeEaseFunc(config.ease || 'easeOut'),
        props: ['transform'].concat(animatables),
        animate: {
          from: {},
          to: {}
        },
        description: config.description,
        delay: config.delay || 0,
        duration: config.duration || 0,
        firstProp: function () {
          CSS.reveal(config.DOMNode);
          return U.extend({}, this.from, { transform: blendTransformArray(this.animate.from.transform, this.animate.to.transform, 0) });
        },
        frame: function (pos, first, last) {
          // first time we apply full transform matrix
          function set(styles) {
            if (callback)
              return callback(styles, first, last);
            return styles;
          }
          var len;
          var blended = {};
          var k;
          if (last) {
            return set(this.to);
          } else if (first) {
            return set(this.firstProp());
          } else {
            len = this.props.length;
            while (len--) {
              k = this.props[len];
              if (k == 'transform') {
                blended.transform = blendTransformArray(this.animate.from.transform, this.animate.to.transform, pos);
              } else {
                if (pos > 1) {
                  blended = this.to;
                } else if (pos < 0) {
                  blended = this.firstProp();
                } else {
                  blended[k] = this.animate.from[k] + (this.animate.to[k] - this.animate.from[k]) * pos;
                }
              }
            }
            return set(blended);
          }
        }
      };
      motion.frame = motion.frame.bind(motion);
      // no alignement & stuff works if display is not block
      // 			if (config.current == 'close') {
      // 				CSS.cssConcealed(config.DOMNode, { visibility: 'hidden' });
      // 			}
      // 			CSS.cssConcealed(config.DOMNode, { display: 'block' });
      //config.DOMNode.style.display = 'block';
      //CSS.reveal(config.DOMNode);
      // 'to' must be solved before 'from'!
      [
        'to',
        'from'
      ].forEach(function (p) {
        motion[p] = CSS.applyPerspectiveIf(this.createPositionStyles(config, p));
        if (p == 'from') {
          motion[p] = CSS.applyPerspectiveIf(layout.prepForTrans(config.DOMNode, motion.from, motion.to, true));
        }
        motion.animate[p].transform = Animator.makeFullTransformArray(motion[p].transform);
        animatables.forEach(function (key) {
          motion[p][key] = motion.animate[p][key] = config[p].animate[key];
        });
      }, this);
      return motion;
    },
    insertIntoAnchor: function (anchor, opt) {
      if (U.gid(opt.id))
        U.removeNode(opt.id);
      insertForCore(U.extend({
        tabletUsesMobile: SleekNote.tabletUsesMobile,
        parent: anchor,
        concealed: true,
        position: 'beforeend'
      }, opt));
    },
    insert: function (opt) {
      var anchor;
      var dbg = SleekNote.debug;
      var type = opt.what;
      //var className = '';
      if (type == 'note')
        type = opt.config.type;
      // keep things inside anchor in correct stacking order
      var style = opt.style || {};
      style.zIndex = [
        'cover',
        'form',
        'success',
        'teaser',
        'badge'
      ].indexOf(type);
      // current rules:
      // desktop: use BR on all, except fixed SleekBar, which goes into TL, not fixed SleekBar is not inserted into anchor
      // mobile: use TL on all, except teaser on bottom which goes into BR
      var profile = opt.config.profile;
      switch (opt.what) {
      case 'note':
        var param = behaviour.animationParameters({
          config: opt.config,
          dimensions: function () {
            return {};
          }
        }, 'close', 'open');
        //console.log('ap', param);
        anchor = param.to.anchor;
        // some note is inserted *always* before badge or cover
        if (profile != CONST.PROFILE.DESKTOP) {
        } else {
          if (opt.config.position == CONST.POS.HELLO) {
            if (!U.empty(opt.config.placement)) {
              return insertForCore({
                tabletUsesMobile: SleekNote.tabletUsesMobile,
                parent: body,
                id: opt.config.name + opt.id,
                content: opt.content,
                className: 'sleeknote-anchor',
                style: {
                  visibility: 0,
                  zIndex: custom('zIndex'),
                  position: 'absolute'
                },
                //position: opt.insertPosition,
                concealed: true,
                onload: opt.onload,
                onresize: opt.onresize,
                useDocumentWrite: opt.useDocumentWrite
              });
            }  //							anchor = this.top;
          } else {
          }
        }
        var scroll = behaviour.DOMNodeScrolling(opt.config, opt.editor, opt.editorVersion);
        // 					if (
        // 						profile == CONST.PROFILE.MOBILE &&
        // 						U.contains(type, 'form', 'success') /*&&
        // 						!U.contains(opt.config.position, CONST.POS.HELLO, CONST.POS.HELLO2)*/
        // 					) {
        // // 						style = U.extend(style, {
        // // 							webkitOverflowScrolling: 'touch',
        // // 							overflowY: this.editorVersion ? 'scroll' : 'auto',
        // // 							overflowX: 'hidden',
        // // 						});
        // 						className += ' form';
        // 					}
        this.insertIntoAnchor(U.contains(anchor, A.BOTTOM_RIGHT, A.BOTTOM_LEFT) ? this.bottom : this.top, {
          id: opt.config.name + opt.id,
          style: U.extend(style, scroll.style),
          content: opt.content,
          className: (dbg ? opt.config.name + ' ' : '') + ' ' + scroll.className,
          onload: opt.onload,
          onresize: opt.onresize,
          useDocumentWrite: opt.useDocumentWrite
        });
        break;
      case 'badge':
      case 'cover':
        this.insertIntoAnchor(this.top, {
          what: opt.what,
          id: opt.id,
          style: style,
          content: opt.content,
          onload: opt.onload
        });
        break;
      }
    }
  };
  return layout;
}(browser, utils, animator, css, constants, core_common, behaviour);
layout2 = function (layout) {
  return layout;
}(layout_new);
error_tip = function (B, U, CSS, layout, Animator, SleekNote, C) {
  function method(noteObj) {
    return noteObj.isHello ? 'inline' : 'tooltip';
  }
  function showTooltip(noteObj, node, text) {
    var parent = U.querySelectorClosest(node, '.form-element, .element');
    if (!parent)
      return;
    var form = noteObj.config.formNode;
    var pb = parent.getBoundingClientRect();
    var fb = form.getBoundingClientRect();
    hide(noteObj);
    var tt = U.insertHTML(form, '<div id="validation-tooltip" style=\'width:auto;overflow:visible;height:auto;color:#fff;font-family:"Helvetica neue", arial, sans-serif;padding:5px 10px;line-height: 16px;font-weight:bold;font-size:11px;text-align:center;background:#ED5757;position:absolute;z-index:9999;border-radius:2px\'>' + text + '<span class="tip" style="position:absolute;top:100%;left:50%;margin-left:-5px;width:0;height:0;border-top:5px solid #ED5757;border-right:5px solid transparent;border-left:5px solid transparent"></span></div>');
    CSS.set(tt, 'opacity', 0);
    if (node.offsetWidth - node.clientWidth || node.offsetHeight - node.clientHeight) {
      node.setAttribute('data-default-bordercolor', CSS.get(node, 'borderColor'));
      CSS.set(node, { borderColor: '#ED5757' });
    }
    layout.absolutePositionBegin(C.AL.TOP_LEFT, tt).move(pb.left - fb.left + pb.width / 2, pb.top - fb.top - 10).to(C.PA.CENTER, C.PA.OUTSIDE).set();
    // TODO: some day maybe ...
    //remifySelector('#validation-tooltip, #validation-tooltip>*', note);
    new Animator({
      duration: 200,
      frame: function (first, last) {
        CSS.set(tt, {
          top: U.px2rem(-20 + 18 * this.pos, /*convert2rem(note)*/
          false),
          opacity: this.pos
        });
      }
    }).play();
  }
  function hideTooltip(noteObj) {
    var tt = U.qs('#validation-tooltip', noteObj.doc);
    if (tt) {
      tt.id = '';
      U.qsa('input[data-default-bordercolor]', noteObj.doc).forEach(function (node) {
        CSS.set(node, { borderColor: node.getAttribute('data-default-bordercolor') });
      });
      // 			Y('input[data-default-bordercolor]').each(function() {
      // 				var y = Y(this);
      // 				var bg;
      // 				if ((bg = y.attr('data-default-bordercolor'))) {
      // 					y.css('border-color', bg);
      // 				}
      // 			});
      new Animator({
        duration: 200,
        frame: function (first, last) {
          CSS.set(tt, { opacity: 1 - this.pos });
          if (last) {
            U.removeNode(tt);
          }
        }
      }).play();
    }
  }
  var savedStyle = {};
  var savedTarget;
  function showInline(noteObj, obj, text) {
    savedStyle = {
      borderColor: CSS.get(obj, 'borderColor'),
      borderWidth: CSS.get(obj, 'borderWidth'),
      borderStyle: CSS.get(obj, 'borderStyle'),
      boxShadow: CSS.get(obj, 'boxShadow')
    };
    CSS.set(obj, {
      borderColor: '#ED5757',
      borderWidth: 1,
      borderStyle: 'solid',
      boxShadow: '0px 0px 10px 3px #ED5757'
    });
    savedTarget = obj;
  }
  function hideInline(noteObj) {
    CSS.set(savedTarget, savedStyle);
  }
  function show(noteObj, obj, text) {
    switch (method(noteObj)) {
    case 'inline':
      showInline(noteObj, obj, text);
      break;
    default:
      showTooltip(noteObj, obj, text);
    }
  }
  function hide(noteObj) {
    switch (method(noteObj)) {
    case 'inline':
      hideInline(noteObj);
      break;
    default:
      hideTooltip(noteObj);
    }
  }
  return {
    show: show,
    hide: hide
  };
}(browser, utils, css, layout2, animator, core_common, constants);
vanillaquery = function (U, CSS) {
  var win = this;
  var doc = win.document;
  function Y(selector, context) {
    return new NL(qsa(selector, context));
  }
  //	function merge( first, second ) {
  //		var len = +second.length;
  //		var j = 0;
  //		var i = first.length;
  //		for ( ; j < len; j++ ) first[ i++ ] = second[ j ];
  //		first.length = i;
  //		return first;
  //	}
  function sibling(cur, dir) {
    /* jshint ignore:start */
    while ((cur = cur[dir]) && cur.nodeType !== 1) {
    }
    /* jshint ignore:end */
    return cur ? [cur] : cur;
  }
  function siblings(n, elem) {
    var matched = [];
    for (; n; n = n.nextSibling)
      if (n.nodeType === 1 && n !== elem)
        matched.push(n);
    return matched;
  }
  function filter(arr, selector, not) {
    return selector && arr ? arr.filter(function (elem) {
      var m = U.matchesSel(elem, selector);
      return not ? !m : m;
    }) : arr;
  }
  function qsa(selector, context) {
    if (!selector)
      return [];
    if (selector instanceof NL || Array.isArray(selector))
      return selector;
    if (typeof selector == 'object' && (selector.nodeType || 'setInterval' in selector))
      return [selector];
    if (typeof selector === 'string' && selector[0] == '<' && selector[selector.length - 1] == '>' && selector.length >= 3)
      return U.htmlToElement(selector);
    return (context || doc).querySelectorAll(selector);
  }
  function NL(nodeList) {
    var l = nodeList.length;
    this.length = l;
    while (l--)
      this[l] = nodeList[l];
    return this;
  }
  // text, comment, attribute
  function ntca(elem) {
    var nType = elem.nodeType;
    return !(nType == 3 || nType == 8 || nType == 2);
  }
  Y.each = function (obj, callback) {
    var length;
    var i = 0;
    if ('length' in obj) {
      length = +obj.length || 0;
      for (; i < length; i++) {
        if (callback.call(obj[i], i, obj[i]) === false) {
          break;
        }
      }
    } else {
      for (i in obj) {
        if (callback.call(obj[i], i, obj[i]) === false) {
          break;
        }
      }
    }
    return obj;
  };
  Y.hasClass = function (el, value) {
    return new RegExp('(^|\\s)' + value + '(\\s|$)').test(el.className);
  };
  Y.bindTo = function (document) {
    var bound = function (selector, context) {
      return Y(selector, context || document);
    };
    bound.each = Y.each;
    bound.hasClass = Y.hasClass;
    return bound;
  };
  NL.prototype = {
    each: function (callback) {
      return Y.each(this, callback);
    },
    attr: function (key, value) {
      if (typeof key == 'string' && value === undefined && this[0])
        return this[0].getAttribute(key);
      if (typeof key != 'object') {
        var tmp = {};
        tmp[key] = value;
        key = tmp;
      }
      var props = Object.keys(key);
      return this.each(function () {
        var i = 0;
        var p;
        for (; p = props[i]; i++)
          if (ntca(this))
            this.setAttribute(p, key[p]);
      });
    },
    prop: function (key, value) {
      if (typeof key == 'string' && value === undefined && this[0])
        return ntca(this[0]) ? this[0][key] : null;
      if (typeof key != 'object') {
        var tmp = {};
        tmp[key] = value;
        key = tmp;
      }
      var props = Object.keys(key);
      return this.each(function () {
        var i = 0;
        var p;
        for (; p = props[i]; i++)
          if (ntca(this))
            this[p] = key[p];
      });
    },
    css: function (key, value) {
      if (typeof key == 'string' && value === undefined && this[0])
        return CSS.get(this[0], key);
      return this.each(function () {
        CSS.set(this, key, value);
      });
    },
    remove: function () {
      this.each(function () {
        if (this.parentNode)
          this.parentNode.removeChild(this);
      });
    },
    show: function () {
      return this.each(CSS.conceal);
    },
    hide: function () {
      return this.each(CSS.reveal);
    },
    val: function () {
      if (!this[0] || this[0].nodeType !== 1)
        return;
      return U.trim(this[0].value);
    },
    children: function () {
      return Y(this.length ? siblings(this[0].firstChild) : 0);
    },
    next: function (selector) {
      return Y(this.length ? filter(sibling(this[0], 'nextSibling'), selector) : 0);
    },
    not: function (selector) {
      return Y(filter(Array.prototype.slice.call(this), selector, true));
    },
    first: function () {
      return Y(this[0]);
    },
    bind: function (type, fn, capture) {
      return this.each(function () {
        U.listener(this, 'add', fn, capture)(type);
      });
    },
    unbind: function (type, fn, capture) {
      return this.each(function () {
        U.listener(this, 'remove', fn, capture)(type);
      });
    },
    hasClass: function (value) {
      return Y.hasClass(this[0], value);
    },
    addClass: function (value) {
      var i, l;
      if (typeof value == 'string')
        value = [value];
      for (i = 0, l = value.length; i < l; i++)
        this.each(function () {
          if (value[i] && !Y.hasClass(this, value[i]))
            this.className = this.className ? this.className + ' ' + value[i] : value[i];
        });
      return this;
    },
    removeClass: function (value) {
      var i, l;
      if (typeof value == 'string')
        value = [value];
      for (i = 0, l = value.length; i < l; i++)
        this.each(function () {
          this.className = this.className.replace(new RegExp('(^|\\s+)' + value[i] + '(\\s+|$)'), ' ');
        });
      return this;
    }
  };
  return Y;
}(utils, css);
note_support = function (B, U, CSS, errorTip, CONST, vanilla) {
  //var debug = SleekNote.debugMessage('f');
  var mobileHeaderHeight = 60;
  var mobileFooterHeight = 20;
  var teaserRotationOveride = {
    '-webkit-transform-origin': 'none',
    '-webkit-transform': 'none',
    '-moz-transform': 'none',
    '-ms-transform': 'none',
    '-o-transform': 'none',
    transform: 'none'
  };
  var mobileBoxStyles = {
    position: 'relative',
    width: '100%',
    top: '10px',
    margin: '0px',
    border: 'none',
    bottom: 'auto',
    left: '0px',
    right: '0px',
    'box-shadow': 'none',
    padding: mobileHeaderHeight + 'px 20px ' + mobileFooterHeight + 'px',
    '-webkit-border-radius': '10px',
    '-moz-border-radius': '10px',
    'border-radius': '10px',
    height: 'auto',
    'min-height': '0px',
    '-webkit-text-size-adjust': '100%',
    'background-image': 'none'
  };
  var mobileSuccessStyles = {
    position: 'static',
    width: '100%',
    top: '0px',
    bottom: 'auto',
    margin: '0px',
    border: 'none',
    left: '0px',
    right: '0px',
    'box-shadow': 'none',
    padding: mobileHeaderHeight + 'px ' + mobileFooterHeight + 'px 20px',
    '-webkit-border-radius': '10px',
    '-moz-border-radius': '10px',
    'border-radius': '10px',
    height: 'auto',
    'min-height': '0px',
    '-webkit-text-size-adjust': '100%'
  };
  /* :::MOBILE SUCCESS STYLING - END::: */
  /* :::MOBILE TEASER STYLING::: */
  var mobileTeaserStyles = {
    width: '100%',
    bottom: 'initial',
    left: 'initial',
    right: 'initial',
    top: '0px'
  };
  var mobileTeaserParagraphStyles = {
    'line-height': '38px',
    'text-align': 'center',
    'font-size': '16px !important'
  };
  var mobileTeaserTextContainerStyles = {
    position: 'static',
    top: 'initial',
    bottom: 'initial',
    left: 'initial',
    right: 'initial',
    'min-height': '40px'
  };
  /* :::MOBILE TEASER STYLING END::: */
  /* :::MOBILE COMMON STYLING::: */
  var mobileInputStyles = {
    'font-size': '16px',
    '-webkit-user-modify': 'read-write-plaintext-only'
  };
  var mobileRadioLabelStyles = { padding: '1px 0px 1px 25px' };
  var fullWidthStyles = {
    width: '100%',
    'line-height': 'initial'
  };
  var centerAlign = { 'text-align': 'center' };
  var resetHorz = {
    left: 'auto',
    right: 'auto'
  };
  var mobileRelativePositionStyles = {
    position: 'relative',
    top: 'initial',
    bottom: 'initial',
    left: 'initial',
    right: 'initial'
  };
  return {
    prepare: function (noteFrame, next) {
      var note = noteFrame.config;
      //var Y = noteFrame.Y;
      var Y = vanilla.bindTo(noteFrame.doc);
      //var form = Y('#SNForm')[0];
      var scripts = 0;
      var finish = function () {
        if (!scripts) {
          if (note.type == 'teaser') {
            runTeaserPreload(note);
          } else {
            if (note.mobile) {
              note.version == 2 ? runBoxMobileView2(Y, note, noteFrame) : runBoxMobileView(Y, note, noteFrame);
            } else {
              runBoxDesktopView(Y, note);
            }
          }
          next && next();
        }
      };
      function runBoxDesktopView(note) {
        //setTabIndex(Y, noteFrame);
        // just to be sure, remove that later
        Y('[data-sn-type="close"]').css({ zIndex: 1 });
      }
      function runTeaserPreload(note) {
        if (note.profile == CONST.PROFILE.MOBILE) {
          Y('#sleeknoteMinified').css(mobileTeaserStyles);
          if (note.version < 3) {
            Y('.text-container').css(mobileTeaserTextContainerStyles);
            Y('.text-container, .SNTextEdit').css(fullWidthStyles);
            Y('.SNTextEdit').css(centerAlign);
            Y('p').css(mobileTeaserParagraphStyles);
            Y('#sleeknoteMinified [data-sn-type="grid"]').css({ width: '100%' });
            Y('#sleeknoteMinified img').remove();
          }
        }
      }
      function init1(note) {
        if (note.version != 1)
          return;
        Y('#sleeknoteMinified').css(teaserRotationOveride);
        // https://www.in-italia.se/
        if (B.is.ie) {
          CSS.addRule('p,li', 'line-height: 1.18', noteFrame.doc);
        }
      }
      function init2(note) {
        //PP: thats my brain fart in editor...
        function fixPrefixedCSS() {
          Y('body [style]').each(function () {
            var style = this.style;
            var styleText = this.getAttribute('style');
            if (~styleText.indexOf('-webkit-') && !('webkitTransform' in style) && U.empty(style.transform)) {
              // we have -webkit in inline style, but it is not supported by that browser...and transform is not set
              this.setAttribute('style', styleText.replace(/-webkit-/g, ''));
              // this is pretty ridiculous hot-fix for IE that has issues applying vertical-align when content of table-cell changes
              if (B.is.ie && this.parentNode.querySelectorAll('.element').length == 1) {
                var valign = this.parentNode.style.verticalAlign;
                var pb = this.parentNode.getBoundingClientRect();
                var mx = noteFrame.win.getComputedStyle(this).transform.replace(/^.*\((.*)\)$/g, '$1').split(/, +/);
                var shift = +mx[5];
                if (valign == 'middle') {
                  shift += pb.height / 2;
                }
                this.style.transform = 'translate(' + mx[4] + 'px, 0)';
                this.style.top = shift + 'px';
              }
            }
          });
        }
        if (note.version != 2)
          return;
        fixPrefixedCSS();
        Y('.row').css('tableLayout', 'fixed');
        Y('form').css('padding', '0px');
        Y('#sleeknoteMinified, #sleeknoteSuccess, #sleeknoteBox').each(function () {
          var close = Y('[data-sn-type="close"]', this)[0];
          var grid = Y('[data-sn-type="grid"]', this)[0].parentNode;
          var gridBounds = grid.getBoundingClientRect();
          Y('[data-sn-type="sticker"]', this).each(function () {
            var bounds = this.getBoundingClientRect();
            Y(this).css({
              top: bounds.top - gridBounds.top,
              left: bounds.left - gridBounds.left,
              transform: ''
            });
            grid.insertBefore(this, close);
          });
        });
      }
      function init3(note) {
        if (note.version != 3)
          return;
        mobileHeaderHeight = 40;
        teaserRotationOveride = {
          '-webkit-transform-origin': 'none',
          '-webkit-transform': 'none',
          '-moz-transform': 'none',
          '-ms-transform': 'none',
          '-o-transform': 'none',
          transform: 'none'
        };
        mobileBoxStyles = {
          position: 'relative',
          width: '100%',
          top: '10px',
          margin: '0px',
          border: 'none',
          bottom: 'auto',
          left: '0px',
          right: '0px',
          'box-shadow': 'none',
          padding: mobileHeaderHeight + 'px 0px 0px',
          height: 'auto',
          'min-height': '0px',
          '-webkit-text-size-adjust': '100%',
          'background-image': 'none'
        };
        mobileSuccessStyles = {
          position: 'static',
          width: '100%',
          top: '0px',
          bottom: 'auto',
          margin: '0px',
          border: 'none',
          left: '0px',
          right: '0px',
          'box-shadow': 'none',
          padding: mobileHeaderHeight + 'px 0px 0px',
          height: 'auto',
          'min-height': '0px',
          '-webkit-text-size-adjust': '100%'
        };
      }
      function init23(note) {
        if (note.version == 1)
          return;
        //new link button
        // TODO: move to CSS
        Y('.linkbutton, img').each(function () {
          var href = Y(this).attr('data-sn-custom-href');
          var step = Y(this).attr('data-sn-custom-step');
          var email = Y(this).attr('data-sn-custom-email');
          if (href || step || email)
            Y(this).css({ cursor: 'pointer' });
        });
        //links inside text, add correct target if none
        Y('a').each(function () {
          var target = Y(this).attr('target');
          // just to be sure
          var customHref = Y(this).attr('data-sn-custom-href') || Y(this).attr('data-sn-custom-email');
          if (U.empty(customHref) && U.empty(target)) {
            Y(this).attr('target', '_blank');
            Y(this).attr('rel', 'noopener');
          }
        });
        Y('a').each(function () {
          if (Y(this).attr('target') == '_blank')
            Y(this).attr('rel', 'noopener');
        });
      }
      //Catch form submission by enter key
      Y('input').bind('keypress', function (event) {
        event = U.normalizedEvent(event);
        if (event.which == 13) {
          U.preventDefault(event);
          U.click(noteFrame.doc.querySelector('[data-section="Button"]'), event);
        }
      });
      Y('input').bind('focus', function (event) {
        errorTip.hide(noteFrame);
      });
      init1(note);
      init2(note);
      init23(note);
      init3(note);
      // TODO: FB adds iframe, we need to wait until this and all images are loaded
      if (noteFrame.doc.querySelectorAll('.fb-container').length) {
        scripts++;
        U.loadScript('//connect.facebook.net/en_US/all.js', function () {
          noteFrame.win.FB.init({
            appId: '684387618256004',
            status: true,
            cookie: true,
            xfbml: true,
            oauth: true
          });
          noteFrame.win.FB.Event.subscribe('edge.create', function (response) {
            noteFrame.message({
              type: 'aftersubmit',
              from: note,
              target: 'Facebook'
            });
            noteFrame.win.socialSubmitSleeknoteBox();
          });
          scripts--;
          finish();
        }, 'facebook-jssdk', noteFrame.doc);
      }
      if (noteFrame.doc.querySelectorAll('.twitter-follow-button, .twitter-share-button').length) {
        scripts++;
        U.loadScript('//platform.twitter.com/widgets.js', function () {
          noteFrame.win.twttr.events.bind('tweet', function (event) {
            noteFrame.message({
              type: 'aftersubmit',
              from: note,
              target: 'Twitter'
            });
            noteFrame.win.socialSubmitSleeknoteBox();
          });
          noteFrame.win.twttr.events.bind('follow', function (event) {
            noteFrame.message({
              type: 'aftersubmit',
              from: note,
              target: 'Twitter'
            });
            noteFrame.win.socialSubmitSleeknoteBox();
          });
          scripts--;
          finish();
        }, 'twitter-wjs', noteFrame.doc);
      }
      finish();
    }
  };
  function runBoxMobileView2(Y, note, noteFrame) {
    // 		function adaptRadius2Closebar(id) {
    // 			var form = Y(id + ' form')[0];
    // 			if (!form) return;
    // 			Y(id + ' .sleeknoteMobileClose').css({
    // 				borderTopRightRadius: 10,
    // 				borderTopLeftRadius: 10,
    // 			});
    // 			Y(id + ' form .row:first-child .column').each(function () {
    // 				var p = parseInt(CSS.get(this, 'paddingTop'), 10);
    // 				CSS.set(this, 'paddingTop', p + 40);
    // 			});
    // 		}
    function oneColumnPerRow(id, note) {
      var docFragment = noteFrame.doc.createDocumentFragment();
      var columns = Y(id + ' form .column');
      // this does not work, as note has no such property
      var imagesAllowed = note.CustomInitSettings && note.CustomInitSettings.allowMobileImages;
      if (!columns.length)
        return;
      columns.each(function (i) {
        if (!imagesAllowed || U.typeStr(imagesAllowed) == 'array' && imagesAllowed.indexOf(note.campaignId) == -1 || imagesAllowed != note.campaignId)
          Y('[data-sn-type="image"]', this).remove();
        if (!this.children.length)
          return;
        if (this.children.length == 1 && Y(this.children[0]).hasClass('column-bg'))
          return;
        docFragment.appendChild(this);
      });
      var grid = Y(id + ' form [data-sn-type="grid"]')[0];
      if (!grid)
        return;
      grid.innerHTML = '';
      //var formStyle = noteFrame.win.getComputedStyle( Y( id + ' form')[0] );
      var last = docFragment.children.length - 1;
      var i = 0;
      var col;
      var row;
      var bgStyle;
      var borderRadius = 10;
      while (col = docFragment.children[0]) {
        bgStyle = {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          width: '100%',
          height: '100%',
          borderTopRightRadius: '0px',
          borderTopLeftRadius: '0px',
          borderBottomRightRadius: '0px',
          borderBottomLeftRadius: '0px'
        };
        if (!i) {
          bgStyle.borderTopRightRadius = borderRadius;
          bgStyle.borderTopLeftRadius = borderRadius;
          if (i == last) {
            bgStyle.borderBottomRightRadius = borderRadius;
            bgStyle.borderBottomLeftRadius = borderRadius;
          }
        } else if (i == last) {
          bgStyle.borderBottomRightRadius = borderRadius;
          bgStyle.borderBottomLeftRadius = borderRadius;
        }
        Y('.column-bg', col).css(bgStyle);
        i += 1;
        row = noteFrame.doc.createElement('div');
        row.className = 'row';
        row.appendChild(col);
        grid.appendChild(row);
      }
      Y(id + ' form [data-sn-type="close"]').remove();
      Y(id + ' form [data-sn-type="sticker"]').remove();
      // adjust widths
      Y(id + ' form [data-sn-type="grid"]').css('width', '100%');
      Y(id + ' .column').css('width', '100%');
      Y(id + ' form').css('float', 'none');
      Y(id).css('width', '100%');
    }
    //placeholder(Y, noteFrame);
    if (note.version < 3) {
      oneColumnPerRow('#sleeknoteBox', note);
      oneColumnPerRow('#sleeknoteSuccess', note);
    }
    Y('.fb-container').css(centerAlign);
    Y('.fb_iframe_widget span').first().css(fullWidthStyles);  // 		if (!U.contains(note.position, CONST.POS.HELLO, CONST.POS.HELLO2)) {
                                                               // 			var mobileCloseStyles = {
                                                               // 				position: 'absolute',
                                                               // 				left: 0,
                                                               // 				top: 0,
                                                               // 				'z-index': 9999,
                                                               // 				background: '#fff',
                                                               // 				width: '100%',
                                                               // 				'text-align': 'right',
                                                               // 				color: '#474747',
                                                               // 				'font-family': "'Helvetica Neue', arial, sans-serif",
                                                               // 				'font-style': 'italic',
                                                               // 				'font-size': 14,
                                                               // 				'border-bottom': '1px solid #ddd',
                                                               // 				height: 40,
                                                               // 			};
                                                               //
                                                               // 			var closeIcon =
                                                               // 				'<img src="//sleeknoteimages.sleeknote.com/mobile-close' +
                                                               // 				(B.is.retina ? '_retina' : '') +
                                                               // 				'.png" class="mobile-close-icon" style="cursor:pointer;position:absolute;right:7px;top:7px;' +
                                                               // 				(B.is.retina ? 'width:26px;' : '') +
                                                               // 				'">';
                                                               // 			var mobileCloseButton = '<div class="sleeknoteMobileClose" style="' + CSS.inline(mobileCloseStyles, true) + '">' + closeIcon + '</div>';
                                                               //
                                                               // 			Y(U.insertHTML(Y('#sleeknoteBox')[0], mobileCloseButton));
                                                               // 			adaptRadius2Closebar('#sleeknoteBox');
                                                               // 			// note.badge is no more
                                                               // 			// 			if (note.badge) {
                                                               // 			// 				var href = '//sleeknote.com/?utm_source=Badge&utm_medium=' + note.type + '&utm_campaign=' + note.hostname;
                                                               // 			// 				U.insertHTML(
                                                               // 			// 					noteFrame.doc.querySelector('.sleeknoteMobileClose'),
                                                               // 			// 					'<a target="_blank" rel=noopener href="' +
                                                               // 			// 						href +
                                                               // 			// 						'" style="opacity:0.5;position:relative;display:block;width:120px;height:40px;background:url(//sleeknoteimages.sleeknote.com/badge.svg);background-size: 77px 20px; background-repeat: no-repeat; background-position: 20px 10px;"></a>'
                                                               // 			// 				);
                                                               // 			// 			}
                                                               //
                                                               // 			Y(U.insertHTML(Y('#sleeknoteSuccess')[0], mobileCloseButton));
                                                               // 			adaptRadius2Closebar('#sleeknoteSuccess');
                                                               // 		}
                                                               // into note2
                                                               //U.insertHTML(noteFrame.doc.body, '<div style="position:absolute; width:100%; height: 100%; cursor: pointer;"></div>', 'afterbegin');
  }
  function runBoxMobileView(Y, note, noteFrame) {
    var formElements = [];
    // Iterate through form elements and position them according to their top position
    if (note.version < 3 && Y('#SNForm').length > 0) {
      formElements = [];
      Y('#SNForm .form-element').each(function () {
        var obj = Y(this);
        if (obj.children().first().attr('type') != 'hidden') {
          formElements.push({
            obj: obj,
            height: this.offsetHeight,
            topPosition: CSS.get(this, 'top')
          });
        }
      });
      var compare = function (a, b) {
        return a.topPosition - b.topPosition;
      };
      formElements.sort(compare);
      var newTopValue = 0;
      Y.each(formElements, function (i) {
        var currentIndex = i;
        if (i > 0) {
          newTopValue = newTopValue + formElements[i - 1].height + 10;
        }
        Y.each(formElements, function (i) {
          if (currentIndex === 0) {
            formElements[i].obj.css('top', 0);
          } else if (i >= currentIndex) {
            formElements[i].obj.css('top', newTopValue);
          }
        });
      });
      var heighestOffset = 0;
      var formBottom = 0;
      Y('#SNForm .form-element').each(function () {
        var top = CSS.get(this, 'top');
        if (top > heighestOffset) {
          heighestOffset = top;
          formBottom = top + this.offsetHeight;
        }
      });
      Y('#SNForm').css('height', formBottom);
    }
    //setTabIndex(Y, noteFrame);
    //placeholder(Y, noteFrame);
    if (!U.contains(note.position, CONST.POS.HELLO, CONST.POS.HELLO2)) {
      Y('#sleeknoteBox').css(mobileBoxStyles);
      Y('#sleeknoteSuccess').css(mobileSuccessStyles);
    }
    if (note.version < 3) {
      /* jshint ignore:start */
      Y('#sleeknoteBox > *, #sleeknoteSuccess > *').each(function () {
        if (this.style['float'] || this.style.width) {
          CSS.set(this, {
            width: '100%',
            'max-width': '100%'
          });
        }
      });
      /* jshint ignore:end */
      Y('#sleeknoteSuccess, #sleeknoteBox').css('background-image', 'none');
      Y('input[type="text"], input[type="email"], input[type="telephone"]').css(mobileInputStyles);
      Y('.fb-container').css(centerAlign);
      Y('.SNTextEdit, .text-container, button, .SNTextEdit, .SNCTAEdit, .form-element, form, input[type="text"], input[type="email"], iframe, .fb_iframe_widget').css(fullWidthStyles);
      //PP: chek that!
      Y('.fb_iframe_widget span').first().css(fullWidthStyles);
      Y('.SNTextEdit, .text-container, #SNForm, .SNCTAEdit').css(mobileRelativePositionStyles);
      Y('.form-element').css(resetHorz);
      Y('img, .SNCloseButton, .image-container').remove();
      Y('input[type="radio"]').next('label').css(mobileRadioLabelStyles);
      Y('img').not('.mobile-close-icon').remove();
    }  // 		var mobileCloseStyles = {
       // 			position: 'absolute',
       // 			left: 0,
       // 			top: 0,
       // 			'z-index': 9999,
       // 			background: '#fff',
       // 			width: '100%',
       // 			'text-align': 'right',
       // 			color: '#474747',
       // 			'font-family': "'Helvetica Neue', arial, sans-serif",
       // 			'font-style': 'italic',
       // 			'font-size': 14,
       // 			'border-bottom': '1px solid #ddd',
       // 			height: 40,
       // 		};
       //
       // 		if (!U.contains(note.position, CONST.POS.HELLO, CONST.POS.HELLO2)) {
       // 			var closeIcon =
       // 				'<img src="//sleeknoteimages.sleeknote.com/mobile-close' +
       // 				(B.is.retina ? '_retina' : '') +
       // 				'.png" class="mobile-close-icon" style="cursor:pointer;position:absolute;right:7px;top:7px;' +
       // 				(B.is.retina ? 'width:26px;' : '') +
       // 				'">';
       // 			var mobileCloseButton = '<div class="sleeknoteMobileClose" style="' + CSS.inline(mobileCloseStyles, true) + '">' + closeIcon + '</div>';
       //
       // 			//			Y(U.insertHTML(Y('#sleeknoteBox')[0], mobileCloseButton));
       // 			// note.badge is no more
       // 			// 			if (note.badge) {
       // 			// 				var href = '//sleeknote.com/?utm_source=Badge&utm_medium=' + note.type + '&utm_campaign=' + note.hostname;
       // 			// 				U.insertHTML(
       // 			// 					noteFrame.doc.querySelector('.sleeknoteMobileClose'),
       // 			// 					'<a target="_blank" rel=noopener href="' +
       // 			// 						href +
       // 			// 						'" style="opacity:0.5;position:relative;display:block;width:120px;height:40px;background:url(//sleeknoteimages.sleeknote.com/badge.svg);background-size: 77px 20px; background-repeat: no-repeat; background-position: 20px 10px;"></a>'
       // 			// 				);
       // 			// 			}
       //
       // 			//			Y(U.insertHTML(Y('#sleeknoteSuccess')[0], mobileCloseButton));
       // 			Y(U.insertHTML(Y(note.id)[0], mobileCloseButton));
       //		}
  }
}(browser, utils, css, error_tip, constants, vanillaquery);
locale = function (U) {
  // keep this as minimal as possible, languages added by request, fetch new datetime ones from external/moment-with-locales.js
  var win = this;
  var doc = win.document;
  var browserLocale = (win.navigator.userLanguage || win.navigator.language).split('-')[0];
  function list() {
    return Object.keys(locales);
  }
  function select(selected) {
    return {
      selected: getLocale(selected),
      options: list().map(function (locale) {
        return {
          value: locale,
          text: locales[locale].caption
        };
      })
    };
  }
  function getLocale(locale) {
    var all = list();
    if (!locale)
      locale = browserLocale;
    if (all.indexOf(locale) < 0)
      locale = 'en';
    return locale;
  }
  function currencyList() {
    return Object.keys(currencies);
  }
  function selectCurrency(selected) {
    return {
      selected: getCurrecy(selected),
      options: currencyList().sort(function (a, b) {
        var textA = currencies[a].caption.toUpperCase();
        var textB = currencies[b].caption.toUpperCase();
        return textA < textB ? -1 : textA > textB ? 1 : 0;
      }).map(function (currency) {
        return {
          value: currency,
          text: currencies[currency].caption
        };
      })
    };
  }
  function getCurrecy(currency) {
    var all = currencyList();
    if (!currency)
      currency = 'dkkrone';
    if (all.indexOf(currency) < 0)
      currency = 'dkkrone';
    return currency;
  }
  function findCurrencyData(currency) {
    if (!currency)
      currency = 'dkkrone';
    return currencies[currency];
  }
  function getType(type) {
    var types = [
      'y',
      'M',
      'd',
      'h',
      'm',
      's'
    ];
    if (type === +type)
      return types[type];
    return type;
  }
  // type is single char
  function timeStr(locale, amount, type) {
    type = getType(type);
    if (amount != 1)
      type += type;
    var relativeTime = locales[getLocale(locale)].relativeTime[type];
    return relativeTime.call ? relativeTime(amount, true, type) : relativeTime.replace('%d', amount);
  }
  function relativeTime() {
    var time = Array.isArray(arguments[1]) ? arguments[1] : Array.prototype.slice.call(arguments, 1);
    var locale = arguments[0];
    var res = time.reduce(function (str, val, index) {
      if (val > 0) {
        var formatted = timeStr(locale, val, index);
        if (index == 5)
          formatted = '<ins data-sn-subtype=seconds>' + formatted + '</ins>';
        str += ' ' + formatted;
      }
      return str;
    }, '');
    //console.log(arguments, res);
    return res;  //return '<p><span>' + res + '</span></p>';
  }
  var exampleNumbers = [
    0,
    0,
    2,
    3,
    4,
    6
  ];
  //y,M,d,m,s
  function exampleRelativeTime(locale) {
    // keep tese in sync with exampleNumbers
    return relativeTime(locale, 0, 0, 2, 3, 4, 6);
  }
  /*
  		walk over text nodes inside parent
  		if found a) number b) string, create function that can replace it with something else, either real number or string in different locale
  	
  	*/
  function createWalker(node) {
    return doc.createTreeWalker(node, win.NodeFilter.SHOW_TEXT, function () {
      return win.NodeFilter.FILTER_ACCEPT;
    }, false);
  }
  function replaceCountdownText(content, text) {
    var div = doc.createElement('div');
    div.innerHTML = content || '';
    var walker = createWalker(div);
    while (walker.nextNode()) {
      if (walker.currentNode.textContent.length && walker.currentNode.parentElement.tagName != 'INS') {
        walker.currentNode.parentElement.innerHTML = text;
        var p = U.querySelectorClosest(walker.currentNode.parentElement, 'p');
        return p ? p.outerHTML : div.innerHTML;
      }
    }
    return '<p>' + text + '</p>';
  }
  function createDateReplacer(node) {
    var parts;
    var walker = createWalker(node);
    var funcs = [];
    var content;
    var regex = new RegExp('[' + exampleNumbers + ']', 'g');
    while (walker.nextNode()) {
      parts = [];
      // which date parts included in this node
      content = walker.currentNode.textContent.replace(regex, function (m) {
        parts.push(+m);
        // we need to replace unique number with something always searchable
        return '{{' + m + '}}';
      });
      if (parts.length) {
        funcs.push(function (node, content, parts) {
          return function (dateArray) {
            node.textContent = content;
            parts.forEach(function (m) {
              node.textContent = node.textContent.replace('{{' + m + '}}', dateArray[exampleNumbers.indexOf(m)]);
            });
          };
        }(walker.currentNode, content, parts));
      }
    }
    return function () {
      return function (dateArray) {
        funcs.forEach(function (func) {
          func(dateArray);
        });
      };
    }();
  }
  function replaceDateWithText(node, text) {
    var walker = createWalker(node);
    var first = true;
    while (walker.nextNode()) {
      walker.currentNode.textContent = first ? text : '';
      if (first)
        first = false;
    }
  }
  function errorMessage(what, locale) {
    return locales[getLocale(locale)].errors[what] || 'Error';
  }
  function productRecString(what, locale) {
    return locales[getLocale(locale)].productRec[what] || 'Error';
  }
  function processRelativeTime$2(number, withoutSuffix, key) {
    var format = {
      m: [
        'eine Minute',
        'einer Minute'
      ],
      h: [
        'eine Stunde',
        'einer Stunde'
      ],
      d: [
        'ein Tag',
        'einem Tag'
      ],
      dd: [
        number + ' Tage',
        number + ' Tagen'
      ],
      M: [
        'ein Monat',
        'einem Monat'
      ],
      MM: [
        number + ' Monate',
        number + ' Monaten'
      ],
      y: [
        'ein Jahr',
        'einem Jahr'
      ],
      yy: [
        number + ' Jahre',
        number + ' Jahren'
      ]
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }
  function plural$4(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
  }
  function relativeTimeWithPlural$3(number, withoutSuffix, key) {
    var format = {
      ss: withoutSuffix ? '__' : '__',
      mm: withoutSuffix ? '__' : '__',
      hh: '__',
      dd: '__',
      MM: '__',
      yy: '__'
    };
    if (key === 'm') {
      return withoutSuffix ? '' : '';
    } else {
      return number + ' ' + plural$4(format[key], +number);
    }
  }
  function plural$3(n) {
    return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1;
  }
  function translate$8(number, withoutSuffix, key) {
    var result = number + ' ';
    switch (key) {
    case 'ss':
      return result + (plural$3(number) ? 'sekundy' : 'sekund');
    case 'm':
      return withoutSuffix ? 'minuta' : 'minut';
    case 'mm':
      return result + (plural$3(number) ? 'minuty' : 'minut');
    case 'h':
      return withoutSuffix ? 'godzina' : 'godzin';
    case 'hh':
      return result + (plural$3(number) ? 'godziny' : 'godzin');
    case 'MM':
      return result + (plural$3(number) ? 'miesice' : 'miesicy');
    case 'yy':
      return result + (plural$3(number) ? 'lata' : 'lat');
    }
  }
  var locales = {
    en: {
      caption: 'English',
      errors: {
        'email-error': 'This email is not valid.',
        'required-error': 'This field is required.'
      },
      relativeTime: {
        s: 'a few seconds',
        ss: '%d seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        M: 'a month',
        MM: '%d months'
      },
      weekDaysInitials: {
        S: 'S',
        M: 'M',
        T: 'T',
        W: 'W',
        Th: 'T',
        F: 'F',
        Sa: 'S'
      },
      productRec: {
        pricePreamble: 'from',
        seeMore: 'Flip to see more'
      }
    },
    da: {
      caption: 'Dansk',
      errors: {
        'email-error': 'Denne email er ikke gyldig.',
        'required-error': 'Dette felt er pkrvet.'
      },
      relativeTime: {
        s: 'f sekunder',
        ss: '%d sekunder',
        m: 'et minut',
        mm: '%d minutter',
        h: 'en time',
        hh: '%d timer',
        d: 'en dag',
        dd: '%d dage',
        M: 'en mned',
        MM: '%d mneder'
      },
      productRec: {
        pricePreamble: 'fra',
        seeMore: 'Vend for at se mere'
      }
    },
    nb: {
      caption: 'Norwegian Bokml',
      errors: {
        'email-error': 'Denne e-postadressen er ikke gyldig.',
        'required-error': 'Dette feltet er ndvendig.'
      },
      relativeTime: {
        s: 'noen sekunder',
        ss: '%d sekunder',
        m: 'ett minutt',
        mm: '%d minutter',
        h: 'en time',
        hh: '%d timer',
        d: 'en dag',
        dd: '%d dager',
        M: 'en mned',
        MM: '%d mneder'
      },
      productRec: {
        pricePreamble: 'fra',
        seeMore: 'snu for  se mer'
      }
    },
    nn: {
      caption: 'Norwegian Nynorsk',
      errors: {
        'email-error': 'Denne e-postadressen er ikke gyldig.',
        'required-error': 'Dette feltet er ndvendig.'
      },
      relativeTime: {
        s: 'nokre sekund',
        ss: '%d sekund',
        m: 'eit minutt',
        mm: '%d minutt',
        h: 'ein time',
        hh: '%d timar',
        d: 'ein dag',
        dd: '%d dagar',
        M: 'ein mnad',
        MM: '%d mnader'
      },
      productRec: {
        pricePreamble: 'fra',
        seeMore: 'snu for  se mer'
      }
    },
    sv: {
      caption: 'Svenska',
      errors: {
        'email-error': 'Vnligen ange en giltig e-postadress.',
        'required-error': 'Detta flt krvs.'
      },
      relativeTime: {
        s: 'ngra sekunder',
        ss: '%d sekunder',
        m: 'en minut',
        mm: '%d minuter',
        h: 'en timme',
        hh: '%d timmar',
        d: 'en dag',
        dd: '%d dagar',
        M: 'en mnad',
        MM: '%d mnader'
      },
      productRec: {
        pricePreamble: 'frn',
        seeMore: 'Vnd fr att se mer'
      }
    },
    nl: {
      caption: 'Nederlands',
      errors: {
        'email-error': 'Dit e-mailadres is ongeldig.',
        'required-error': 'Dit veld is verplicht.'
      },
      relativeTime: {
        s: 'een paar seconden',
        ss: '%d seconden',
        m: 'n minuut',
        mm: '%d minuten',
        h: 'n uur',
        hh: '%d uur',
        d: 'n dag',
        dd: '%d dagen',
        M: 'n maand',
        MM: '%d maanden'
      },
      productRec: {
        pricePreamble: 'van',
        seeMore: 'Klik om meer te zien'
      }
    },
    de: {
      caption: 'Deutsch',
      errors: {
        'email-error': 'Diese E-Mail ist nicht gltig.',
        'required-error': 'Dieses Feld ist ein Pflichtfeld.'
      },
      relativeTime: {
        s: 'ein paar Sekunden',
        ss: '%d Sekunden',
        m: processRelativeTime$2,
        mm: '%d Minuten',
        h: processRelativeTime$2,
        hh: '%d Stunden',
        d: processRelativeTime$2,
        dd: processRelativeTime$2,
        M: processRelativeTime$2,
        MM: processRelativeTime$2
      },
      productRec: {
        pricePreamble: 'ab',
        seeMore: 'Umblttern'
      }
    },
    fr: {
      caption: 'Franais',
      errors: {
        'email-error': 'Cette adresse e-mail n\u2019est pas valide.',
        'required-error': 'Ce champ est obligatoire.'
      },
      relativeTime: {
        future: 'dans %s',
        past: 'il y a %s',
        s: 'quelques secondes',
        ss: '%d secondes',
        m: 'une minute',
        mm: '%d minutes',
        h: 'une heure',
        hh: '%d heures',
        d: 'un jour',
        dd: '%d jours',
        M: 'un mois',
        MM: '%d mois',
        y: 'un an',
        yy: '%d ans'
      },
      productRec: {
        pricePreamble: 'de',
        seeMore: 'Retourner'
      }
    },
    it: {
      caption: 'Italiano',
      errors: {
        'email-error': 'Inserisci un indirizzo e-mail valido.',
        'required-error': 'Questo campo  obbligatorio'
      },
      relativeTime: {
        future: function (s) {
          return (/^[0-9].+$/.test(s) ? 'tra' : 'in') + ' ' + s;
        },
        past: '%s fa',
        s: 'pochi secondi',
        ss: '%d secondi',
        m: 'un minuto',
        mm: '%d minuti',
        h: 'un\'ora',
        hh: '%d ore',
        d: 'un giorno',
        dd: '%d giorni',
        M: 'un mese',
        MM: '%d mesi',
        y: 'un anno',
        yy: '%d anni'
      },
      productRec: {
        pricePreamble: 'da',
        seeMore: 'Gira per scoprire di pi'
      }
    },
    pt: {
      caption: 'Portugus',
      errors: {
        'email-error': 'Este e-mail no  vlido.',
        'required-error': 'Este campo  obrigatrio.'
      },
      relativeTime: {
        future: 'em %s',
        past: 'h %s',
        s: 'segundos',
        ss: '%d segundos',
        m: 'um minuto',
        mm: '%d minutos',
        h: 'uma hora',
        hh: '%d horas',
        d: 'um dia',
        dd: '%d dias',
        M: 'um ms',
        MM: '%d meses',
        y: 'um ano',
        yy: '%d anos'
      },
      productRec: {
        pricePreamble: 'de',
        seeMore: 'Virar para ver mais'
      }
    },
    es: {
      caption: 'Espaol',
      errors: {
        'email-error': 'Este correo electrnico no es vlido.',
        'required-error': 'Este campo es obligatorio.'
      },
      relativeTime: {
        future: 'en %s',
        past: 'hace %s',
        s: 'unos segundos',
        ss: '%d segundos',
        m: 'un minuto',
        mm: '%d minutos',
        h: 'una hora',
        hh: '%d horas',
        d: 'un da',
        dd: '%d das',
        M: 'un mes',
        MM: '%d meses',
        y: 'un ao',
        yy: '%d aos'
      },
      productRec: {
        pricePreamble: 'desde',
        seeMore: 'Gira para ver ms'
      }
    },
    ru: {
      caption: '',
      errors: {
        'email-error': ' e-mail.',
        'required-error': '    .'
      },
      relativeTime: {
        future: ' %s',
        past: '%s ',
        s: ' ',
        ss: relativeTimeWithPlural$3,
        m: relativeTimeWithPlural$3,
        mm: relativeTimeWithPlural$3,
        h: '',
        hh: relativeTimeWithPlural$3,
        d: '',
        dd: relativeTimeWithPlural$3,
        M: '',
        MM: relativeTimeWithPlural$3,
        y: '',
        yy: relativeTimeWithPlural$3
      },
      productRec: {
        pricePreamble: '',
        seeMore: ''
      }
    },
    pl: {
      caption: 'Polski',
      errors: {
        'email-error': 'Niepoprawny adres e-mail.',
        'required-error': 'To pole jest wymagane.'
      },
      relativeTime: {
        future: 'za %s',
        past: '%s temu',
        s: 'kilka sekund',
        ss: translate$8,
        m: translate$8,
        mm: translate$8,
        h: translate$8,
        hh: translate$8,
        d: '1 dzie',
        dd: '%d dni',
        M: 'miesic',
        MM: translate$8,
        y: 'rok',
        yy: translate$8
      },
      productRec: {
        pricePreamble: 'od',
        seeMore: 'odwr'
      }
    },
    ko: {
      caption: '',
      errors: {
        'email-error': '  ',
        'required-error': '  '
      },
      relativeTime: {
        future: '%s ',
        past: '%s ',
        s: ' ',
        ss: '%d',
        m: '1',
        mm: '%d',
        h: ' ',
        hh: '%d',
        d: '',
        dd: '%d',
        M: ' ',
        MM: '%d',
        y: ' ',
        yy: '%d'
      },
      productRec: {
        pricePreamble: '',
        seeMore: '  '
      }
    },
    ja: {
      caption: '',
      errors: {
        'email-error': '',
        'required-error': ''
      },
      relativeTime: {
        future: '%s',
        past: '%s',
        s: '',
        ss: '%d',
        m: '1',
        mm: '%d',
        h: '1',
        hh: '%d',
        d: '1',
        dd: '%d',
        M: '1',
        MM: '%d',
        y: '1',
        yy: '%d'
      },
      productRec: {
        pricePreamble: '',
        seeMore: ''
      }
    },
    jw: {
      caption: 'Javanese',
      errors: {
        'email-error': 'Email iki ora valid.',
        'required-error': 'Panggon iki kudu ono isine.'
      },
      relativeTime: {
        s: 'pira-pira detik',
        ss: '%d detik',
        m: 'semenit',
        mm: '%d menit',
        h: 'sejam',
        hh: '%d jam',
        d: 'sedina',
        dd: '%d dina',
        M: 'sesasi',
        MM: '%d sasi'
      },
      productRec: {
        pricePreamble: 'saka',
        seeMore: 'Walik kanggo ndelok'
      }
    },
    km: {
      caption: 'Central Khmer',
      errors: {
        'email-error': '',
        'required-error': '\u200B\u200B\u200B'
      },
      relativeTime: {
        s: '',
        ss: '%d ',
        m: '\u200B',
        mm: '%d ',
        h: '\u200B',
        hh: '%d ',
        d: '',
        dd: '%d ',
        M: '\u200B',
        MM: '%d '
      },
      productRec: {
        pricePreamble: '',
        seeMore: ''
      }
    },
    zh: {
      caption: 'Chinese',
      errors: {
        'email-error': 'E-mail ',
        'required-error': ''
      },
      relativeTime: {
        s: '',
        ss: '%d ',
        m: '',
        mm: '%d ',
        h: '',
        hh: '%d ',
        d: '',
        dd: '%d ',
        M: '',
        MM: '%d '
      },
      productRec: {
        pricePreamble: '',
        seeMore: ''
      }
    }
  };
  /*
  https://www.science.co.il/language/Locale-codes.php
  */
  var currencies = {
    usdollars: {
      caption: 'US Dollar',
      locale: 'en-US',
      currencyCode: 'USD'
    },
    gbpound: {
      caption: 'Great Britian Pound',
      locale: 'en-gb',
      currencyCode: 'GBP'
    },
    euro: {
      caption: 'Euro',
      locale: 'de-DE',
      currencyCode: 'EUR'
    },
    dkkrone: {
      caption: 'Danish Krone',
      locale: 'da-DK',
      currencyCode: 'DKK'
    },
    swkrone: {
      caption: 'Swedish Krone',
      locale: 'sv-SE',
      currencyCode: 'SEK'
    },
    nokrone: {
      caption: 'Norwegian Krone',
      locale: 'da-DK',
      currencyCode: 'DKK'
    }
  };
  return {
    replaceCountdownText: replaceCountdownText,
    list: list,
    select: select,
    currencyList: currencyList,
    selectCurrency: selectCurrency,
    findCurrencyData: findCurrencyData,
    timeStr: timeStr,
    relativeTime: relativeTime,
    exampleRelativeTime: exampleRelativeTime,
    createDateReplacer: createDateReplacer,
    replaceDateWithText: replaceDateWithText,
    errorMessage: errorMessage,
    productRecString: productRecString
  };
}(utils);
note_validation = function (B, U, CSS, errorTip, SleekNote, locale) {
  /*
  	if (!validateInputs(config, true)) return;
  	var config = noteObj.config;
  	var Y = noteObj.Y;
  */
  function validateInputs(noteObj, oldMethod) {
    var valid = true;
    oldMethod = oldMethod || false;
    errorTip.hide(noteObj);
    function message(what) {
      return locale.errorMessage(what);
    }
    function validateEmail(email) {
      var re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
      return re.test(email);
    }
    function getRequired(node, type, oldMethod) {
      return oldMethod && type == 'email' || node.getAttribute('data-required-field') == 'true' || node.getAttribute('data-user-required') == 'required' || node.getAttribute('data-user-required') == 'true' || node.getAttribute('data-required') == 'true' || node.getAttribute('data-required') == 'true' && node.getAttribute('data-required-field') != 'false';
    }
    var requiredRadioGroup = [];
    var selectedRadioGroup = [];
    U.qsa('input, textarea', noteObj.doc).forEach(function (node) {
      var type = node.getAttribute('type');
      if (type == 'hidden')
        return;
      var required = getRequired(node, type, oldMethod);
      var text = type == 'text' || type == 'number' || node.nodeName == 'TEXTAREA';
      if (required && type == 'email' && !validateEmail(node.value)) {
        errorTip.show(noteObj, node, message('email-error'));
        valid = false;
        return false;
      }
      if (text && required && !U.trim(node.value).length) {
        errorTip.show(noteObj, node, message('required-error'));
        valid = false;
        return false;
      }
      if (type == 'checkbox' && required && !node.checked) {
        errorTip.show(noteObj, node, message('required-error'));
        valid = false;
        return false;
      }
      if (type == 'radio' && required) {
        if (node.checked)
          selectedRadioGroup.push(node.name);
        if (!requiredRadioGroup.filter(function (e) {
            return e.name == node.name;
          }).length) {
          requiredRadioGroup.push({
            name: node.name,
            element: node
          });
        }
      }
    });
    requiredRadioGroup.forEach(function (val) {
      if (selectedRadioGroup.indexOf(val.name) == -1) {
        errorTip.show(noteObj, val.element, message('required-error'));
        valid = false;
        return false;
      }
    });
    U.qsa('select', noteObj.doc).forEach(function (node) {
      //default is always included and it is first (index 0), unselected is -1,
      if (getRequired(node, 'select', oldMethod) && node.selectedIndex < 1) {
        errorTip.show(noteObj, node, message('required-error'));
        valid = false;
        return false;
      }
    });
    return valid;
  }
  return validateInputs;
}(browser, utils, css, error_tip, core_common, locale);
(function () {
  var utf16 = {
    // The utf16-class is necessary to convert from javascripts internal character representation to unicode and back.
    decode: function (input) {
      var output = [], i = 0, len = input.length, value, extra;
      while (i < len) {
        value = input.charCodeAt(i++);
        if ((value & 63488) === 55296) {
          extra = input.charCodeAt(i++);
          if ((value & 64512) !== 55296 || (extra & 64512) !== 56320) {
            throw new RangeError('UTF-16(decode): Illegal UTF-16 sequence');
          }
          value = ((value & 1023) << 10) + (extra & 1023) + 65536;
        }
        output.push(value);
      }
      return output;
    },
    encode: function (input) {
      var output = [], i = 0, len = input.length, value;
      while (i < len) {
        value = input[i++];
        if ((value & 63488) === 55296) {
          throw new RangeError('UTF-16(encode): Illegal UTF-16 value');
        }
        if (value > 65535) {
          value -= 65536;
          output.push(String.fromCharCode(value >>> 10 & 1023 | 55296));
          value = 56320 | value & 1023;
        }
        output.push(String.fromCharCode(value));
      }
      return output.join('');
    }
  };
  //Default parameters
  var initial_n = 128;
  var initial_bias = 72;
  var delimiter = '-';
  var base = 36;
  var damp = 700;
  var tmin = 1;
  var tmax = 26;
  var skew = 38;
  var maxint = 2147483647;
  // decode_digit(cp) returns the numeric value of a basic code
  // point (for use in representing integers) in the range 0 to
  // base-1, or base if cp is does not represent a value.
  function decode_digit(cp) {
    return cp - 48 < 10 ? cp - 22 : cp - 65 < 26 ? cp - 65 : cp - 97 < 26 ? cp - 97 : base;
  }
  // encode_digit(d,flag) returns the basic code point whose value
  // (when used for representing integers) is d, which needs to be in
  // the range 0 to base-1. The lowercase form is used unless flag is
  // nonzero, in which case the uppercase form is used. The behavior
  // is undefined if flag is nonzero and digit d has no uppercase form.
  function encode_digit(d, flag) {
    return d + 22 + 75 * (d < 26) - ((flag !== 0) << 5);  //  0..25 map to ASCII a..z or A..Z
                                                          // 26..35 map to ASCII 0..9
  }
  //** Bias adaptation function **
  function adapt(delta, numpoints, firsttime) {
    var k;
    delta = firsttime ? Math.floor(delta / damp) : delta >> 1;
    delta += Math.floor(delta / numpoints);
    for (k = 0; delta > (base - tmin) * tmax >> 1; k += base) {
      delta = Math.floor(delta / (base - tmin));
    }
    return Math.floor(k + (base - tmin + 1) * delta / (delta + skew));
  }
  // encode_basic(bcp,flag) forces a basic code point to lowercase if flag is zero,
  // uppercase if flag is nonzero, and returns the resulting code point.
  // The code point is unchanged if it is caseless.
  // The behavior is undefined if bcp is not a basic code point.
  function encode_basic(bcp, flag) {
    bcp -= (bcp - 97 < 26) << 5;
    return bcp + ((!flag && bcp - 65 < 26) << 5);
  }
  // Main decode
  function decode(input, preserveCase) {
    // Dont use utf16
    var output = [];
    var case_flags = [];
    var input_length = input.length;
    var n, out, i, bias, basic, j, ic, oldi, w, k, digit, t, len;
    // Initialize the state:
    n = initial_n;
    i = 0;
    bias = initial_bias;
    // Handle the basic code points: Let basic be the number of input code
    // points before the last delimiter, or 0 if there is none, then
    // copy the first basic code points to the output.
    basic = input.lastIndexOf(delimiter);
    if (basic < 0)
      basic = 0;
    for (j = 0; j < basic; ++j) {
      if (preserveCase)
        case_flags[output.length] = input.charCodeAt(j) - 65 < 26;
      if (input.charCodeAt(j) >= 128) {
        throw new RangeError('Illegal input >= 0x80');
      }
      output.push(input.charCodeAt(j));
    }
    // Main decoding loop: Start just after the last delimiter if any
    // basic code points were copied; start at the beginning otherwise.
    for (ic = basic > 0 ? basic + 1 : 0; ic < input_length;) {
      // ic is the index of the next character to be consumed,
      // Decode a generalized variable-length integer into delta,
      // which gets added to i. The overflow checking is easier
      // if we increase i as we go, then subtract off its starting
      // value at the end to obtain delta.
      for (oldi = i, w = 1, k = base;; k += base) {
        if (ic >= input_length) {
          throw RangeError('punycode_bad_input(1)');
        }
        digit = decode_digit(input.charCodeAt(ic++));
        if (digit >= base) {
          throw RangeError('punycode_bad_input(2)');
        }
        if (digit > Math.floor((maxint - i) / w)) {
          throw RangeError('punycode_overflow(1)');
        }
        i += digit * w;
        t = k <= bias ? tmin : k >= bias + tmax ? tmax : k - bias;
        if (digit < t) {
          break;
        }
        if (w > Math.floor(maxint / (base - t))) {
          throw RangeError('punycode_overflow(2)');
        }
        w *= base - t;
      }
      out = output.length + 1;
      bias = adapt(i - oldi, out, oldi === 0);
      // i was supposed to wrap around from out to 0,
      // incrementing n each time, so we'll fix that now:
      if (Math.floor(i / out) > maxint - n) {
        throw RangeError('punycode_overflow(3)');
      }
      n += Math.floor(i / out);
      i %= out;
      // Insert n at position i of the output:
      // Case of last character determines uppercase flag:
      if (preserveCase) {
        case_flags.splice(i, 0, input.charCodeAt(ic - 1) - 65 < 26);
      }
      output.splice(i, 0, n);
      i++;
    }
    if (preserveCase) {
      for (i = 0, len = output.length; i < len; i++) {
        if (case_flags[i]) {
          output[i] = String.fromCharCode(output[i]).toUpperCase().charCodeAt(0);
        }
      }
    }
    return utf16.encode(output);
  }
  //** Main encode function **
  function encode(input, preserveCase) {
    //** Bias adaptation function **
    var n, delta, h, b, bias, j, m, q, k, t, ijv, case_flags;
    if (preserveCase) {
      // Preserve case, step1 of 2: Get a list of the unaltered string
      case_flags = utf16.decode(input);
    }
    // Converts the input in UTF-16 to Unicode
    input = utf16.decode(input.toLowerCase());
    var input_length = input.length;
    // Cache the length
    if (preserveCase) {
      // Preserve case, step2 of 2: Modify the list to true/false
      for (j = 0; j < input_length; j++) {
        case_flags[j] = input[j] != case_flags[j];
      }
    }
    var output = [];
    // Initialize the state:
    n = initial_n;
    delta = 0;
    bias = initial_bias;
    // Handle the basic code points:
    for (j = 0; j < input_length; ++j) {
      if (input[j] < 128) {
        output.push(String.fromCharCode(case_flags ? encode_basic(input[j], case_flags[j]) : input[j]));
      }
    }
    h = b = output.length;
    // h is the number of code points that have been handled, b is the
    // number of basic code points
    if (b > 0)
      output.push(delimiter);
    // Main encoding loop:
    //
    while (h < input_length) {
      // All non-basic code points < n have been
      // handled already. Find the next larger one:
      for (m = maxint, j = 0; j < input_length; ++j) {
        ijv = input[j];
        if (ijv >= n && ijv < m)
          m = ijv;
      }
      // Increase delta enough to advance the decoder's
      // <n,i> state to <m,0>, but guard against overflow:
      if (m - n > Math.floor((maxint - delta) / (h + 1))) {
        throw RangeError('punycode_overflow (1)');
      }
      delta += (m - n) * (h + 1);
      n = m;
      for (j = 0; j < input_length; ++j) {
        ijv = input[j];
        if (ijv < n) {
          if (++delta > maxint)
            return Error('punycode_overflow(2)');
        }
        if (ijv == n) {
          // Represent delta as a generalized variable-length integer:
          for (q = delta, k = base;; k += base) {
            t = k <= bias ? tmin : k >= bias + tmax ? tmax : k - bias;
            if (q < t)
              break;
            output.push(String.fromCharCode(encode_digit(t + (q - t) % (base - t), 0)));
            q = Math.floor((q - t) / (base - t));
          }
          output.push(String.fromCharCode(encode_digit(q, preserveCase && case_flags[j] ? 1 : 0)));
          bias = adapt(delta, h + 1, h == b);
          delta = 0;
          ++h;
        }
      }
      ++delta, ++n;
    }
    return output.join('');
  }
  function ToASCII(domain) {
    var domain_array = domain.split('.');
    var out = [];
    for (var i = 0; i < domain_array.length; ++i) {
      var s = domain_array[i];
      out.push(s.match(/[^A-Za-z0-9-]/) ? 'xn--' + encode(s) : s);
    }
    return out.join('.');
  }
  function ToUnicode(domain) {
    var domain_array = domain.split('.');
    var out = [];
    for (var i = 0; i < domain_array.length; ++i) {
      var s = domain_array[i];
      out.push(s.match(/^xn--/) ? decode(s.slice(4)) : s);
    }
    return out.join('.');
  }
  var exports = {
    encodePuny: ToASCII,
    decodePuny: ToUnicode
  };
  punycode = function () {
    return exports;
  }();
}.call(this));
location = function (U, P) {
  var win = this;
  var p = win.document.createElement('a');
  function Location() {
    var args = Array.isArray(arguments[0]) ? arguments[0] : arguments;
    this.set.apply(this, args);
  }
  Location.fromString = function (str) {
    p.href = P.decodePuny(str);
    return new Location(p.protocol, p.hostname, p.pathname, p.search, p.hash, p.port);
  };
  /*
  
  		str - loaction.search ( ?foo=bar )
  		noDecode - wether to pas call to decodeURIComponent() on
  		
  		returns {
  			foo: bar,
  			...
  		}
  
  	*/
  function queryParams(str, noDecode) {
    var params = {};
    var i;
    var pair;
    str = str.replace(/[?#]/, '');
    str = str.split('&').filter(function (entry) {
      return !U.empty(entry);
    });
    if (str[0]) {
      for (i = 0; i < str.length; i++) {
        pair = str[i].split('=', 2);
        params[pair[0]] = pair[1] ? noDecode ? pair[1] : U.decodeURIComponent(pair[1].replace(/\+/g, ' ')) : undefined;
      }
    }
    return params;
  }
  // whatever (if any) protocol we have in string 'url', replace it with 'protocol' or 'httop'
  function replaceProtocol(url, protocol) {
    p.href = addProtocolIf(url, protocol);
    return new Location(protocol, p.hostname, p.pathname, p.search, p.hash, p.port).toString();
  }
  // add 'protocol' if string 'url' does not have
  function addProtocolIf(url, protocol) {
    protocol || (protocol = 'http:');
    if (!/^\/\//i.test(url))
      protocol += '//';
    if (!/^https?:\/\//i.test(url))
      url = protocol + url;
    return url;
  }
  /*
  		removes stuff from 'url' that we dont need and that prevents us comparing
  		noHash - wether to cut off hash from'url' too
  	*/
  function cleanURL(url, noHash) {
    //p.href = '//' + url.replace(/^https?:\/\//i, '');
    p.href = url;
    var pathname = p.pathname.replace('.aspx', '').replace('.html', '').replace('.htm', '').replace('.php', '');
    var params = Location.prototype.queryParams.call(p, true);
    var hashQuery = !p.search && p.hash;
    var search = [];
    var param;
    for (param in params)
      if (params.hasOwnProperty(param)) {
        if (!param.indexOf('utm_') || !param.toLowerCase().indexOf('sndebug') || !param.toLowerCase().indexOf('snbranch') || !param.toLowerCase().indexOf('snreset') || !param.toLowerCase().indexOf('snsubscribed'))
          continue;
        search.push(param + (params[param] === undefined ? '' : ':' + params[param]));
      }
    search = search.join('&');
    url = new Location(p.protocol, p.hostname, pathname, hashQuery ? '' : search, hashQuery ? search : noHash ? '' : p.hash, p.port);
    url = url.toString().replace(/\/$/g, '');
    // we ignore www. everywhere now
    url = url.replace(/:\/\/www\./g, '://');
    return url;
  }
  Location.extractDomain = function (url) {
    if (U.typeStr(url) != 'string' || U.empty(url))
      return '';
    url = P.decodePuny(url);
    p.href = cleanURL(replaceProtocol(url, win.location.protocol), true);
    return p.hostname;
  };
  Location.prototype = {
    // true if this domain equals 'url' domain
    domainMatches: function (url) {
      url = P.decodePuny(url);
      p.href = cleanURL(replaceProtocol(url, this.protocol), true);
      return this.hostname == p.hostname;
    },
    // true if this equals 'url'
    matches: function (url) {
      url = P.decodePuny(url);
      url = cleanURL(replaceProtocol(url, this.protocol), true).toUpperCase();
      var that = cleanURL(this.toString(), true).toUpperCase();
      var wc = url.indexOf('*');
      var clean;
      if (~wc) {
        //Clean after * processing so we match browsers clean
        //specifically trailing slash vs not trailing slash after domain needs to eval as the same
        // PP - the above solution now takes over all trailing slashes, fixing:
        var part = url.split('*')[0];
        clean = cleanURL(part).toUpperCase();
        // do we have http://www.url.com/ OR http://www.url.com/foo/ as they are not treated the same
        if (part[part.length - 1] == '/' && part.split('/').length > 4) {
          // http://www.url.com/foo/ - add trailing slash back
          clean = clean + '/';
        }
        // we remove last / of this/that ...
        return that.indexOf(clean) === 0 || (that + '/').indexOf(clean) === 0;
      }
      return that == url;
    },
    // true if str is containted current url
    contains: function (str) {
      str = str || '';
      var that = cleanURL(this.toString(), true).toUpperCase();
      return that.indexOf(str.toUpperCase()) > -1;
    },
    // calls queryParams() with query string or hash (to support old-style single page apps)
    queryParams: function (noDecode) {
      var hashQuery = !this.search && this.hash;
      return hashQuery ? queryParams(this.hash, noDecode) : queryParams(this.search, noDecode);
    },
    // mimicing native location
    toString: function () {
      return this.href;
    },
    // fill all native location properties to this, all arguments are 1:1 to native location props
    set: function (protocol, hostname, pathname, search, hash, port) {
      protocol || (protocol = 'http:');
      hash = hash ? (hash.charAt(0) == '#' ? '' : '#') + hash : '';
      search = search ? (search.charAt(0) == '?' ? '' : '?') + search : '';
      port || (port = '');
      pathname || (pathname = '');
      // IE, add missing first slash
      if (pathname && pathname.charAt(0) != '/')
        pathname = '/' + pathname;
      hostname = (hostname || '').split(':')[0];
      if (port == 80 || port == 443)
        port = '';
      var origin = protocol + '//' + hostname + (port ? ':' + port : '');
      this.hash = hash;
      this.search = search;
      this.port = port || '';
      this.origin = origin;
      this.protocol = protocol;
      this.href = origin + pathname + search + hash;
      this.hostname = hostname;
      this.pathname = pathname;
      this.host = hostname;
      return this;
    }
  };
  function loc(SleekNote, reset) {
    if (reset)
      loc.loc = undefined;
    if (!loc.loc) {
      var local = SleekNote.local === String(SleekNote.local) ? Location.fromString(SleekNote.local) : win.location;
      loc.loc = new Location([
        'protocol',
        'hostname',
        'pathname',
        'search',
        'hash',
        'port'
      ].map(function (p) {
        var res;
        if (p == 'pathname' && local[p] == '/')
          return win.location[p];
        res = local[p] || win.location[p];
        if (p == 'hostname')
          res = res.replace(/^www\./, '');
        return res;
      }));
    }
    return loc.loc;
  }
  Location.get = loc;
  Location.reset = function resetLocation(SleekNote) {
    return loc(SleekNote, true);
  };
  return Location;
}(utils, punycode);
click = function (B, U) {
  function Click(elem, callback) {
    this.callback = callback;
    this.elem = elem;
    if ('body' in this.elem)
      this.elem = this.elem.body;
    console.log('listening', this.elem);
    U.listener(this.elem, 'add', this, true)('touchstart')('touchmove')('touchend')('touchcancel');
  }
  function squared(val) {
    return Math.pow(val, 2);
  }
  Click.prototype = {
    destroy: function () {
      this.elem && U.listener(this.elem, 'remove', this, true)('touchstart')('touchmove')('touchend')('touchcancel');
    },
    handleEvent: function (event) {
      console.log(event);
      switch (event.type) {
      case 'touchstart':
        this.moved = false;
        this.start = U.eventXY(event);
        break;
      case 'touchmove':
        var current = U.eventXY(event);
        if (!this.moved) {
          this.moved = squared(current.x - this.start.x) + squared(current.y - this.start.y) > squared(10);
        }
        break;
      case 'touchend':
      case 'touchcancel':
        if (!this.moved)
          this.callback(event);
        break;
      }
      return true;
    }
  };
  function listen(target, callback) {
    // 		if (B.is.ios && B.has.touch) {
    // 			var instance = new Click(target, callback);
    // 			return function () {
    // 				instance.destroy();
    // 			};
    // 		} else {
    U.listener(target, 'add', callback, true)('click');
    return function () {
      U.listener(target, 'remove', callback, true)('click');
    };  // 		}
  }
  return { listen: listen };
}(browser, utils);
event_emitter = function (B, U, LE) {
  var win = this;
  var doc = win.document;
  /*
  
  Event API
  
  event.type is 'sleekNote'
  
  Example test event listener:
  
  document.addEventListener('sleekNote', function (e) {
    console.log(e.data);
    if (e.data.type == 'load') window.command = e.data.command
  }, false);
  
  
  event.data is object 
  	{
  		type: custom event type (load, ready, exit, entry, submit)
  		... event data
   	}
  
  'load' - fired after Notesmanager as initialized e.g. we are ready to launch campaigns, it returns:
  	'command' which is the API function that should be called from now. triggerOnClick is depreceated
  	
  	supported calls:
  	
  	'reset' close all currently shown, kill timers - command('reset')
  	'close' close currently open box of campaign - command('close', campaignId)
  	'launch', same as triggerOnClick  - command('launch', campaignId, onlyShowPreloaded)
  	'open', open any box of preloaded campaign - command('open', campaignId, 'form')
  	
  
  'ready' - fired when campoaign is ready, returns
  	'campaignId'
  	'boxes' which is object that contains objects 
  		{
  			'name' box's name (teaser, form, success, etc)
  			'DOMNode'
   		}
  
  'entry'
  'exit' - fired after one box is shown or hidden, returns
  	'campaignId'
  	'box' which is object that
  		{
  			'name' box's name (teaser, form, success, etc)
  			'DOMNode'
   		}
  	
  'submit' - fired on data submit, returns
  	'campaignId'
  	'data' serialized form submit data
  
  
  */
  function makeData(type, obj, data) {
    switch (type) {
    case 'load':
      return {
        type: type,
        command: obj
      };
    case 'ready':
      obj = obj.origin;
      var DOMNodes = {};
      var boxes = {};
      var name;
      for (name in obj.notes) {
        boxes[name] = {
          name: name,
          DOMNode: obj.notes[name].config.DOMNode
        };
        DOMNodes[name] = obj.notes[name].config.DOMNode;
      }
      return {
        type: type,
        campaignId: obj.config.campaignId,
        boxes: boxes,
        DOMNodes: DOMNodes
      };
    case 'after':
      return {
        type: obj.action == 'close' ? 'exit' : 'entry',
        campaignId: obj.origin.config.campaignId,
        box: {
          name: obj.noteName,
          DOMNode: obj.origin.notes[obj.noteName].config.DOMNode
        }
      };
    case 'submit':
      return {
        type: type,
        campaignId: obj.campaignId,
        data: data
      };
    }
  }
  function emit(type, obj, data) {
    try {
      var event = doc.createEvent('Event');
      event.initEvent('sleekNote', true, true);
      event.data = makeData(type, obj, data);
      doc.dispatchEvent(event);
    } catch (error) {
      LE.error({
        message: 'crash',
        details: {
          url: String(win.location),
          nav: win.navigator.userAgent,
          error: 'emit:' + error.message
        }
      });
    }
  }
  return emit;
}(browser, utils, le);
storage = function (U) {
  /*
  		Goals:
  
  		- Use primarly cookie storage.
  		- Do not emulate expires on localStorage e.g. store indefinetely
  		- Have higher level abstraction methods available
  		
  		with cookies all keys are stored as is, all values are stored as JSON
  		with localstorage we save one object as JOSN as value to key 'SleekNote'
  
  
  	*/
  var win = this;
  var doc = win.document;
  var storageKey = 'SleekNote';
  var U;
  /*\
  	|*|
  	|*|  :: cookies.js ::
  	|*|
  	|*|  A complete cookies reader/writer framework with full unicode support.
  	|*|
  	|*|  Revision #1 - September 4, 2014
  	|*|
  	|*|  https://developer.mozilla.org/en-US/docs/Web/API/document.cookie
  	|*|  https://developer.mozilla.org/User:fusionchess
  	|*|
  	|*|  This framework is released under the GNU Public License, version 3 or later.
  	|*|  http://www.gnu.org/licenses/gpl-3.0-standalone.html
  	|*|
  	|*|  Syntaxes:
  	|*|
  	|*|  * docCookies.setItem(name, value[, end[, path[, domain[, secure]]]])
  	|*|  * docCookies.getItem(name)
  	|*|  * docCookies.removeItem(name[, path[, domain]])
  	|*|  * docCookies.hasItem(name)
  	|*|  * docCookies.keys()
  	|*|
  	\*/
  var docCookies = {
    getItem: function (sKey, noEncoding) {
      if (!sKey) {
        return null;
      }
      function decode(str, nope) {
        return nope ? str : U.decodeURIComponent(str);
      }
      function encode(str, nope) {
        return nope ? str : U.encodeURIComponent(str);
      }
      return decode(doc.cookie.replace(new RegExp('(?:(?:^|.*;)\\s*' + encode(sKey, noEncoding).replace(/[\-\.\+\*]/g, '\\$&') + '\\s*\\=\\s*([^;]*).*$)|^.*$'), '$1'), noEncoding) || null;
    },
    /*
    	vEnd: 	The max-age in seconds (e.g. 31536e3 for a year, Infinity for a never-expires cookie), or the expires date in GMTString format
    			or as Date object; if not specified the cookie will expire at the end of session (number  finite or Infinity  string, Date object or null).
    */
    setItem: function (sKey, sValue, vEnd, sPath, sDomain, bSecure, noEncoding) {
      if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) {
        return false;
      }
      var sExpires = '';
      if (vEnd) {
        switch (vEnd.constructor) {
        case Number:
          sExpires = vEnd === Infinity ? '; expires=Fri, 31 Dec 9999 23:59:59 GMT' : '; max-age=' + vEnd;
          break;
        case String:
          sExpires = '; expires=' + vEnd;
          break;
        case Date:
          sExpires = '; expires=' + vEnd.toUTCString();
          break;
        }
      }
      doc.cookie = (noEncoding ? sKey : U.encodeURIComponent(sKey)) + '=' + (noEncoding ? sValue : U.encodeURIComponent(sValue)) + sExpires + (sDomain ? '; domain=' + sDomain : '') + (sPath ? '; path=' + sPath : '') + (bSecure ? '; secure' : '') + '; SameSite=Lax';
      return true;
    },
    removeItem: function (sKey, sPath, sDomain) {
      if (!this.hasItem(sKey)) {
        return false;
      }
      doc.cookie = U.encodeURIComponent(sKey) + '=; expires=Thu, 01 Jan 1970 00:00:00 GMT' + (sDomain ? '; domain=' + sDomain : '') + (sPath ? '; path=' + sPath : '');
      return true;
    },
    hasItem: function (sKey) {
      if (!sKey) {
        return false;
      }
      return new RegExp('(?:^|;\\s*)' + U.encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, '\\$&') + '\\s*\\=').test(doc.cookie);
    },
    keys: function () {
      var aKeys = doc.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, '').split(/\s*(?:\=[^;]*)?;\s*/);
      for (var nLen = aKeys.length, nIdx = 0; nIdx < nLen; nIdx++) {
        aKeys[nIdx] = U.decodeURIComponent(aKeys[nIdx]);
      }
      return aKeys;
    }
  };
  var msInADay = 24 * 60 * 60 * 1000;
  function expireDaysToDate(days) {
    var date = new Date();
    days = +days || 0;
    if (days) {
      // returns date only when days > 0
      date.setTime(date.getTime() + days * msInADay);
      return date;
    }
  }
  function stringStartsWith(str, prefix) {
    str = String(str);
    return str.lastIndexOf(prefix, 0) === 0;
  }
  var hasLocalStorageSupport = function () {
    try {
      win.localStorage.setItem('test', '1');
      win.localStorage.removeItem('test');
      return 'localStorage' in win && win.localStorage !== null;
    } catch (error) {
      return false;
    }
  }();
  var hasSessionStorageSupport = function () {
    try {
      win.sessionStorage.setItem('test', '1');
      win.sessionStorage.removeItem('test');
      return 'sessionStorage' in win && win.sessionStorage !== null;
    } catch (error) {
      return false;
    }
  }();
  var dataStorage = {
    localStorage: 1,
    cookieStorage: 2,
    sessionStorage: 3
  };
  function Storage(options) {
    if (!(this instanceof Storage))
      return new Storage(options);
    this.useLocalStorage = false;
    this.useSessionStorage = false;
    this.cookiePath = '/';
    this.cookieDomain = undefined;
    this.cookieSecure = false;
    U.applyOptions.call(this, options);
    this.useLocalStorage = hasLocalStorageSupport && this.useLocalStorage;
    this.useSessionStorage = hasSessionStorageSupport && this.useSessionStorage;
    this.storageBacker = dataStorage.cookieStorage;
    var data;
    if (this.useSessionStorage && !this.dummyStorage) {
      // pass dummyStorage: true for editor where storage really is not needed
      try {
        data = U.JSON.parse(win.sessionStorage.getItem(storageKey));
        this.storageBacker = dataStorage.sessionStorage;
      } catch (e) {
      }
    }
    if (this.useLocalStorage && !this.dummyStorage) {
      // pass dummyStorage: true for editor where storage really is not needed
      try {
        data = U.JSON.parse(win.localStorage.getItem(storageKey));
        this.storageBacker = dataStorage.localStorage;
      } catch (e) {
      }
    }
    this.data = data || {};
    //check to see if we have a new session
    var sessionCookie = Storage.getCookie('SNS');
    if (!sessionCookie) {
      //If it's a new session then remove session specific info from persistent cookie
      this.resetSessionData();
      this.migrateOldCookiesIfNeed();
      this.setNewVisitor(this.newVisitorCheck());
      Storage.setCookie('SNS', 1, '', this.cookiePath, this.cookieDomain, this.cookieSecure, true);
    }
    //If undefined then newvisitor has never been set so we have a session that existed before we
    //tracked new visitor for the whole session but there is an session cookie
    if (this.getNewVisitor() === undefined) {
      this.setNewVisitor(false);
    }
    //New Visitor is a new visitor for the whole session
    this.newVisitor = this.getNewVisitor();
  }
  // private methods
  function setCookie(key, value, expireInDays, noEncoding) {
    return docCookies.setItem(key, value, expireDaysToDate(expireInDays), this.cookiePath, this.cookieDomain, this.cookieSecure, noEncoding);
  }
  function removeCookie(key) {
    return docCookies.removeItem(key, this.cookiePath, this.cookieDomain);
  }
  Storage.setCookie = docCookies.setItem.bind(docCookies);
  Storage.removeCookie = docCookies.removeItem.bind(docCookies);
  Storage.getCookie = docCookies.getItem.bind(docCookies);
  Storage.getCookieKeys = docCookies.keys.bind(docCookies);
  Storage.prototype = {
    // write always clones
    write: function (key, data, days, noCookieEncoding) {
      //console.log('Storage write:', key, data, days);
      if (data === undefined)
        return this.erase(key);
      this.data[key] = U.extend(data);
      if (this.useLocalStorage) {
        if (!this.dummyStorage)
          win.localStorage.setItem(storageKey, U.JSON.stringify(this.data));
      } else if (this.useSessionStorage) {
        if (!this.dummyStorage)
          win.sessionStorage.setItem(storageKey, U.JSON.stringify(this.data));
      } else {
        setCookie.call(this, key, U.JSON.stringify(this.data[key]), days, noCookieEncoding);
      }
    },
    // read always clones
    read: function (key, defaultValue, noCookieEncoding) {
      //console.log('Storage read:', key, defaultValue);
      if (!this.useLocalStorage && !this.useSessionStorage) {
        // assure that we have that key cached
        if (this.data[key] === undefined) {
          try {
            this.data[key] = U.JSON.parse(docCookies.getItem(key));
          } catch (e) {
            try {
              this.data[key] = U.JSON.parse('"' + docCookies.getItem(key, noCookieEncoding) + '"');
            } catch (e) {
              this.data[key] = defaultValue;
            }
          }
        }
      }
      return U.extend(defaultValue === undefined ? this.data[key] : this.data[key] || defaultValue);
    },
    erase: function (key) {
      //console.log('Storage erase:', key);
      delete this.data[key];
      if (this.useLocalStorage) {
        if (!this.dummyStorage)
          win.localStorage.setItem(storageKey, U.JSON.stringify(this.data));
      } else if (this.useSessionStorage) {
        if (!this.dummyStorage)
          win.sessionStorage.setItem(storageKey, U.JSON.stringify(this.data));
      } else {
        removeCookie.call(this, key);
      }
    },
    /*
    			for historical reasons, the names are whate they are:
    			- session cookie for specific sleeknote is SleekNoteSessionClosed...
    			- gobal session cookie for all sleeknotes is SleeknoteReferral
    			
    			- persistent cookie for show count is SleekNotecookie...
    			
    			- SleekNoteSubmitCookie
    			- SNSubscribed
    
    
    		The future is now .... moving to 1 cookie for persistance and 1 for session
    
    		readPersistentCookieByCampaignId: function(campaignId) {
    			return this.read('SleekNoteSessionClosed' + campaignId, {});
    		},
    
    		writePersistentCookieByCampaignId: function(campaignId, value) {
            	this.write('SleekNoteSessionClosed' + campaignId, value);
    		},
    
    		readPersistentCookie: function() {
    			return this.read('SleeknoteReferral', {});
    		},
    
    		writePersistanceCookie: function(value) {
            	this.write('SleeknoteReferral', value);
    		},
    
    				
    		*/
    readAndInitializeCompaignData: function (campaignId) {
      var cookieData = this.read('SNC', {}, true);
      cookieData.cs = cookieData.cs || {};
      return cookieData;
    },
    readPersistentCookieByCampaignId: function (campaignId) {
      var shortCompaignId = String(campaignId).substring(0, 4);
      var cookieData = this.readAndInitializeCompaignData(shortCompaignId);
      return cookieData.cs[shortCompaignId] || {};
    },
    writePersistentCookieByCampaignId: function (campaignId, value) {
      var shortCompaignId = String(campaignId).substring(0, 4);
      var cookieData = this.readAndInitializeCompaignData(shortCompaignId);
      if (U.empty(value)) {
        delete cookieData.cs[shortCompaignId];
      } else {
        cookieData.cs[shortCompaignId] = value;
      }
      this.write('SNC', cookieData, 365, true);
    },
    readPersistentCookie: function () {
      return this.read('SNC', {}, true);
    },
    writePersistanceCookie: function (value) {
      this.write('SNC', value, 365, true);
    },
    preserveIfNotExpired: function (dateValue) {
      //if it's not what we expected ... do no harm
      if (!(dateValue && dateValue.length >= 1))
        return dateValue;
      //If it's not expired return it else delete it
      if (Date.now() < dateValue[0]) {
        return dateValue;
      } else {
        return undefined;
      }
    },
    resetSessionData: function () {
      //Only reset if cookie exists
      if (doc.cookie.indexOf('SNC') >= 0) {
        var cookie = this.readPersistentCookie();
        delete cookie.r;
        delete cookie.g;
        delete cookie.gi;
        delete cookie.ssc;
        if (cookie.cs) {
          var campaign;
          for (var key in cookie.cs) {
            if (cookie.cs.hasOwnProperty(key)) {
              campaign = cookie.cs[key];
              if (!U.empty(campaign)) {
                // on session reset, the only items we want keep for the campaign are items that haven't expired yet
                var resetCampaign = {
                  i: this.preserveIfNotExpired(campaign.i),
                  b: this.preserveIfNotExpired(campaign.b),
                  pv: campaign.pv
                };
                //Remove if campaign will be empty .. don't want a bunch of empty keys in the list because it will grow too big
                if (U.empty(resetCampaign.i) && U.empty(resetCampaign.b) && U.empty(resetCampaign.pv)) {
                  delete cookie.cs[key];
                } else {
                  cookie.cs[key] = resetCampaign;
                }
              } else {
                //If empty delete it .. but this shouldn't happen because once it's empty it will be deleted
                delete cookie.cs[key];
              }
            }
          }
        }
        this.writePersistanceCookie(cookie);
      }
    },
    migrateOldCookiesIfNeed: function () {
      //Only migrate cookies if the new cookie doesn't exist
      //Cookies should be deleted after conversion so this is for safety
      if (doc.cookie.indexOf('SNC') < 0) {
        var campaignId;
        Storage.getCookieKeys().forEach(function (key) {
          var cookieData = this.read(key);
          var dataIsObject = U.typeStr(cookieData) == 'object';
          if (key == 'SleeknoteReferral') {
            if (dataIsObject && !U.empty(cookieData.referral))
              this.setReferral(cookieData.referral);
            if (dataIsObject && !U.empty(cookieData.newVisitor))
              this.setNewVisitorIf(+cookieData.newVisitor);
            this.erase(key);
          } else if (stringStartsWith(key, 'SleekNoteSubmitCookie')) {
            campaignId = key.replace(/SleekNoteSubmitCookie/g, '');
            if (!U.empty(cookieData)) {
              //assume half a year since we can't get the old expiration value from the cookie
              this.setEmail(campaignId, cookieData, 182);
            }
            this.erase(key);
          } else if (stringStartsWith(key, 'SleekNotecookie')) {
            campaignId = key.replace(/SleekNotecookie/g, '');
            //assume half a year since we can't get the old expiration value from the cookie
            this.setShowCount(campaignId, cookieData || 0, 182);
            this.erase(key);
          } else if (stringStartsWith(key, 'SleekNoteSessionClosed')) {
            campaignId = key.replace(/SleekNoteSessionClosed/g, '');
            var newCookie = this.readPersistentCookieByCampaignId(campaignId);
            // Only move cookies if there is a non-empty value
            if (dataIsObject && !U.empty(cookieData.close))
              newCookie.c = +cookieData.close;
            if (dataIsObject && !U.empty(cookieData.hide))
              newCookie.h = +cookieData.hide;
            if (dataIsObject && !U.empty(cookieData.Engaged))
              newCookie.e = +cookieData.Engaged;
            if (dataIsObject && !U.empty(cookieData.utm))
              newCookie.u = cookieData.utm;
            if (dataIsObject && !U.empty(cookieData.query))
              newCookie.q = cookieData.query;
            if (dataIsObject && !U.empty(cookieData.sequence)) {
              newCookie.s = this.encodeArrayValues(cookieData.sequence);
            }
            this.writePersistentCookieByCampaignId(campaignId, newCookie);
            this.erase(key);
          }
        }, this);
      }
    },
    encodeArrayValues: function (array) {
      if (Array.isArray(array)) {
        array.forEach(function (value, index, targetArray) {
          targetArray[index] = U.encodeURIComponent(value);
        });
      }
      return array;
    },
    decodeArrayValues: function (array) {
      if (Array.isArray(array)) {
        array.forEach(function (value, index, targetArray) {
          targetArray[index] = U.decodeURIComponent(value);
        });
      }
      return array;
    },
    forceResetSession: function (resetOption) {
      //Don't have to delete SNS since we're starting a new session right away and it doesn't have any session info in it
      //this.erase('SNS');
      //Since geoIds are captured in the boot process we can't deleted them because they will not be fetched again
      //If snreset=full it will deleted current setting and be refilled on next request
      var geoInfo;
      var pagesVisited;
      var ipAddress;
      if (resetOption != 'full') {
        geoInfo = this.getGeoInfo();
        ipAddress = this.getIPAddress();
        pagesVisited = this.getPagesVisitedCount();
      }
      this.erase('SNC');
      this.erase('SNSubscribed');
      //redo new visitor check which should be true now
      this.setNewVisitor(this.newVisitorCheck());
      this.newVisitor = this.getNewVisitor();
      if (geoInfo) {
        this.setGeoInfo(geoInfo);
      }
      if (pagesVisited) {
        this.setPagesVisitedCount(pagesVisited);
      }
      if (ipAddress) {
        this.setIPAddress(ipAddress);
      }
      //Restart Sesssion Time
      this.startSessionTime();
    },
    // Convinience Methods
    closeSession: function (campaignId) {
      var value = this.readPersistentCookieByCampaignId(campaignId);
      //c = close
      value.c = 1;
      this.writePersistentCookieByCampaignId(campaignId, value);
    },
    isSessionClosed: function (campaignId) {
      //c = close
      return !!this.readPersistentCookieByCampaignId(campaignId).c;
    },
    hideSession: function (campaignId) {
      var value = this.readPersistentCookieByCampaignId(campaignId);
      //h = hide
      value.h = 1;
      this.writePersistentCookieByCampaignId(campaignId, value);
    },
    isSessionHidden: function (campaignId) {
      //h = hide
      return !!this.readPersistentCookieByCampaignId(campaignId).h;
    },
    setEngaged: function (campaignId) {
      var obj = this.readPersistentCookieByCampaignId(campaignId);
      //e = engaged
      obj.e = 1;
      this.writePersistentCookieByCampaignId(campaignId, obj);
      this.recordGoalEngaged(campaignId);
    },
    isEngaged: function (campaignId) {
      //e = engaged
      return !!this.readPersistentCookieByCampaignId(campaignId).e;
    },
    convertSessionEvent: function (campaignId) {
      var obj = this.readPersistentCookieByCampaignId(campaignId);
      //z = converted
      obj.z = 1;
      this.writePersistentCookieByCampaignId(campaignId, obj);
    },
    hasConvertSessionEvent: function (campaignId) {
      //z = converted
      return !!this.readPersistentCookieByCampaignId(campaignId).z;
    },
    setUTMInclude: function (campaignId, value) {
      var obj = this.readPersistentCookieByCampaignId(campaignId);
      //u = utm
      obj.u = value;
      this.writePersistentCookieByCampaignId(campaignId, obj);
    },
    getUTMInclude: function (campaignId) {
      //u = utm
      return this.readPersistentCookieByCampaignId(campaignId).u;
    },
    setQueryInclude: function (campaignId, value) {
      var obj = this.readPersistentCookieByCampaignId(campaignId);
      //q = query
      obj.q = value;
      this.writePersistentCookieByCampaignId(campaignId, obj);
    },
    getQueryInclude: function (campaignId) {
      //q = query
      return this.readPersistentCookieByCampaignId(campaignId).q;
    },
    getSequence: function (campaignId) {
      //s = sequence
      return this.decodeArrayValues(this.readPersistentCookieByCampaignId(campaignId).s) || [];
    },
    setSequence: function (campaignId, value) {
      var obj = this.readPersistentCookieByCampaignId(campaignId);
      //s = sequence
      if (!U.empty(value)) {
        obj.s = this.encodeArrayValues(value);
      } else {
        delete obj.s;
      }
      this.writePersistentCookieByCampaignId(campaignId, obj);
    },
    getPagesVisitedCountPerSession: function (campaignId) {
      //pvs = pagesVisitedThisSession
      return this.readPersistentCookieByCampaignId(campaignId).pvs;
    },
    setPagesVisitedCountPerSession: function (campaignId, value) {
      var obj = this.readPersistentCookieByCampaignId(campaignId);
      //pvs = pagesVisitedThisSession
      if (!U.empty(value)) {
        obj.pvs = value;
      } else {
        delete obj.pvs;
      }
      this.writePersistentCookieByCampaignId(campaignId, obj);
    },
    getPagesVisitedCount: function (campaignId) {
      //pv = pagesVisited
      return this.readPersistentCookieByCampaignId(campaignId).pv;
    },
    setPagesVisitedCount: function (campaignId, value) {
      var obj = this.readPersistentCookieByCampaignId(campaignId);
      //pv = pagesVisited
      if (!U.empty(value)) {
        obj.pv = value;
      } else {
        delete obj.pv;
      }
      this.writePersistentCookieByCampaignId(campaignId, obj);
    },
    setSubscription: function () {
      this.write('SNSubscribed', true, 365);
    },
    isSubscribed: function () {
      return this.read('SNSubscribed', false);
    },
    setEmail: function (campaignId, value, expirationDays) {
      //moving to one global cookie
      //this.write('SleekNoteSubmitCookie' + campaignId, value, 365);
      expirationDays = +expirationDays || 365;
      var obj = this.readPersistentCookieByCampaignId(campaignId);
      if (expirationDays > 0) {
        obj.b = [
          expireDaysToDate(expirationDays).getTime(),
          value
        ];
      } else {
        delete obj.b;
      }
      this.writePersistentCookieByCampaignId(campaignId, obj);
    },
    getEmail: function (campaignId) {
      //return this.read('SleekNoteSubmitCookie' + campaignId, false);
      var obj = this.readPersistentCookieByCampaignId(campaignId);
      obj.b = obj.b || [];
      return obj.b[1] || '';
    },
    setShowCount: function (campaignId, value, expirationDays) {
      //moving to one global cookie
      expirationDays = +expirationDays || 365;
      var obj = this.readPersistentCookieByCampaignId(campaignId);
      obj.i = [
        expireDaysToDate(expirationDays).getTime(),
        value
      ];
      this.writePersistentCookieByCampaignId(campaignId, obj);  //this.write('SleekNotecookie' + campaignId, value, 365);
    },
    getShowCount: function (campaignId) {
      //return this.read('SleekNotecookie' + campaignId, 0);
      var obj = this.readPersistentCookieByCampaignId(campaignId);
      obj.i = obj.i || [];
      return obj.i[1] || 0;
    },
    incrementShowCount: function (campaignId) {
      this.setShowCount(campaignId, this.getShowCount(campaignId) + 1);
      this.incrementSessionShowCount();
      this.recordGoalShown(campaignId);
    },
    eraseShowCount: function (campaignId) {
      //return this.erase('SleekNotecookie' + campaignId);
      var obj = this.readPersistentCookieByCampaignId(campaignId);
      delete obj.i;
      this.writePersistentCookieByCampaignId(campaignId, obj);
    },
    cleanShowCount: function (campaignId) {
      if (this.getShowCount(campaignId) < 1)
        this.eraseShowCount(campaignId);
    },
    setSessionShowCount: function (value) {
      var obj = this.readPersistentCookie();
      obj.ssc = value;
      this.writePersistanceCookie(obj);
    },
    getSessionShowCount: function () {
      var obj = this.readPersistentCookie();
      return obj.ssc || 0;
    },
    incrementSessionShowCount: function () {
      this.setSessionShowCount(this.getSessionShowCount() + 1);
    },
    //PP: now we use that one as common session cookie and for other stuff aswell
    setReferral: function (value) {
      //moving to one global cookie
      var obj = this.readPersistentCookie();
      //obj.referral = value;
      obj.r = obj.r || {};
      obj.r.r = value;
      this.writePersistanceCookie(obj);
    },
    getReferral: function () {
      //return this.readPersistentCookie().referral||'';
      var obj = this.readPersistentCookie();
      obj.r = obj.r || {};
      return obj.r.r || '';
    },
    setNewVisitorIf: function (value) {
      //moving to one global cookie
      if (value) {
        this.setNewVisitor(true);
      }
    },
    setNewVisitor: function (value) {
      //moving to one global cookie
      var obj = this.readPersistentCookie();
      obj.r = obj.r || {};
      //obj.newVisitor = true;
      obj.r.n = +value;
      this.writePersistanceCookie(obj);
    },
    getNewVisitor: function () {
      //return !!this.readPersistentCookie().newVisitor;
      var obj = this.readPersistentCookie();
      obj.r = obj.r || {};
      return obj.r.n;
    },
    setVistorIdIf: function (visitorId) {
      var obj = this.readPersistentCookie();
      obj.v = obj.v ? obj.v : visitorId;
      this.writePersistanceCookie(obj);
      return obj.v;
    },
    getVistorId: function () {
      var obj = this.readPersistentCookie();
      if (!obj.v) {
        obj.v = U.guid_string();
        this.writePersistanceCookie(obj);
      }
      return obj.v;
    },
    hasVisitorId: function () {
      var obj = this.readPersistentCookie();
      return !U.empty(obj.v);
    },
    setGeoInfo: function (geoIds) {
      var obj = this.readPersistentCookie();
      obj.gi = geoIds;
      this.writePersistanceCookie(obj);
      return obj.gi;
    },
    getGeoInfo: function () {
      var obj = this.readPersistentCookie();
      return obj.gi;
    },
    setIPAddress: function (IPAddress) {
      var obj = this.readPersistentCookie();
      obj.ip = IPAddress;
      this.writePersistanceCookie(obj);
      return obj.ip;
    },
    getIPAddress: function () {
      var obj = this.readPersistentCookie();
      return obj.ip;
    },
    recordGoalShown: function (campaingId) {
      var obj = this.readPersistentCookie();
      obj.g = obj.g ? obj.g : {};
      obj.g.sc = obj.g.sc ? obj.g.sc : {};
      obj.g.sc[campaingId] = (obj.g.sc[campaingId] ? obj.g.sc[campaingId] : 0) + 1;
      this.writePersistanceCookie(obj);
      return obj.g.sc[campaingId];
    },
    getGoalShownList: function () {
      var obj = this.readPersistentCookie();
      obj.g = obj.g ? obj.g : {};
      return obj.g.sc || {};
    },
    recordGoalEngaged: function (campaingId) {
      var obj = this.readPersistentCookie();
      obj.g = obj.g ? obj.g : {};
      obj.g.e = obj.g.e ? obj.g.e : {};
      obj.g.e[campaingId] = 1;
      this.writePersistanceCookie(obj);
      return obj.g.e[campaingId];
    },
    getGoalEngageList: function () {
      var obj = this.readPersistentCookie();
      obj.g = obj.g ? obj.g : {};
      return obj.g.e || {};
    },
    resetGoal: function () {
      var obj = this.readPersistentCookie();
      delete obj.g;
      return this.writePersistanceCookie(obj);
    },
    startSessionTime: function () {
      var obj = this.readPersistentCookie();
      obj.a = obj.a || {};
      obj.a.s = new Date().getTime();
      obj.a.i = U.guid_string();
      this.writePersistanceCookie(obj);
    },
    getSessionStartTime: function () {
      var obj = this.readPersistentCookie();
      obj.a = obj.a || {};
      //If this is called we're obviously on a page so start session if it hasn't
      if (!obj.a.s) {
        obj.a.s = new Date().getTime();
        this.writePersistanceCookie(obj);
      }
      return new Date(obj.a.s);
    },
    endSessionTime: function () {
      var obj = this.readPersistentCookie();
      obj.a = obj.a || {};
      obj.a.e = new Date().getTime();
      delete obj.a.i;
      this.writePersistanceCookie(obj);
    },
    getLastSessionEndTime: function () {
      var obj = this.readPersistentCookie();
      obj.a = obj.a || {};
      return obj.a.e ? new Date(obj.a.e) : '';
    },
    getSessionId: function () {
      var obj = this.readPersistentCookie();
      obj.a = obj.a || {};
      if (!obj.a.i) {
        obj.a.i = U.guid_string();
        this.writePersistanceCookie(obj);
      }
      return obj.a.i;
    },
    newVisitorCheck: function () {
      return doc.cookie.indexOf('SNC') < 0;
    },
    setInTest: function (campaignId, value) {
      var obj = this.readPersistentCookieByCampaignId(campaignId);
      //obj.query = value;
      obj.t = obj.t || {};
      obj.t.i = value;
      this.writePersistentCookieByCampaignId(campaignId, obj);
    },
    getInTest: function (campaignId) {
      var obj = this.readPersistentCookieByCampaignId(campaignId);
      //obj.query = value;
      obj.t = obj.t || {};
      return obj.t.i || null;
    },
    setChosenCohort: function (campaignId, value) {
      var obj = this.readPersistentCookieByCampaignId(campaignId);
      //obj.query = value;
      obj.t = obj.t || {};
      obj.t.c = value;
      this.writePersistentCookieByCampaignId(campaignId, obj);
    },
    getChosenCohort: function (campaignId) {
      var obj = this.readPersistentCookieByCampaignId(campaignId);
      //obj.query = value;
      obj.t = obj.t || {};
      return obj.t.c || null;
    },
    cookieExists: function (key) {
      return docCookies.hasItem(key);
    },
    cookieMatches: function (key, value) {
      return docCookies.getItem(key) == value;
    }
  };
  return Storage;
}(utils);
storage_cache = function (Storage) {
  var cache = {};
  function createStorage(options) {
    //use local var ... it was overwriting global accidently
    var cachedStorage = new Storage(options);
    if (!cache[cachedStorage.storageBacker]) {
      cache[cachedStorage.storageBacker] = cachedStorage;
    }
    return cache[cachedStorage.storageBacker];
  }
  return { create: createStorage };
}(storage);
site_data = function (StorageCache, U) {
  var win = this;
  function addData(obj) {
    var sessionStorage = StorageCache.create({ useSessionStorage: true });
    var sessionData = sessionStorage.read('siteData') || {};
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        sessionData[key] = obj[key];
      }
    }
    sessionStorage.write('siteData', sessionData);
    this.manager.siteDataTriggerIf();
  }
  function SiteData(manager) {
    this.manager = manager;
    //if this is first time start up then process anything in the queue and replace function
    if (Array.isArray(win.sleeknoteSiteData)) {
      win.sleeknoteSiteData.forEach(addData, this);
      // redefine queue to call sitedate directly
      win.sleeknoteSiteData = { push: addData.bind(this) };
    }
  }
  SiteData.prototype = {
    addSession: function (name, value) {
      var obj = {};
      obj[name] = value;
      addData.call(this, obj);
    },
    getSession: function () {
      var sessionStorage = StorageCache.create({ useSessionStorage: true });
      return sessionStorage.read('siteData') || {};
    },
    matchSessionProperty: function (property, matchType, value) {
      var sessionValue = (this.getSession() || {})[property];
      return U.JITMatch(sessionValue, matchType, value);
    }
  };
  return SiteData;
}(storage_cache, utils);
font_loader = function (U) {
  var win = this;
  function loadAllFontStyleSheets(docum, hrefs, next) {
    var maxWait = 10 * 1000;
    var interval = 100;
    var l;
    var i;
    hrefs = U.extend(hrefs);
    U.qsa('[rel="stylesheet"]', docum).forEach(function (sheet) {
      var i = hrefs.indexOf(sheet.href);
      if (~i)
        hrefs.splice(i, 1);
    });
    if (!hrefs.length) {
      next(hrefs);
    } else {
      hrefs.forEach(function (href) {
        docum.head.insertAdjacentHTML('beforeend', '<link rel=stylesheet type=text/css href="' + href + '">');
      });
      var poll = win.setInterval(function () {
        maxWait -= interval;
        if (maxWait < 0) {
          win.clearInterval(poll);
          next(hrefs);
        } else {
          l = docum.styleSheets.length;
          while (l--) {
            i = hrefs.indexOf(docum.styleSheets.item(l).href);
            if (~i)
              hrefs.splice(i, 1);
          }
          if (!hrefs.length) {
            win.clearInterval(poll);
            next(hrefs);
          }
        }
      }, interval);
    }
  }
  function normalizeFontFamily(str) {
    return String(str).split(',')[0].toLowerCase().replace(/['"]+/g, '').replace(/^\s+|\s+$/g, '');
  }
  function loadFonts(docum, hrefs) {
    var families = U.slice(docum.querySelectorAll('[style*="font-family"]')).map(function (node) {
      return normalizeFontFamily(node.style.fontFamily);
    }).filter(function (value, index, array) {
      return array && array.indexOf(value) == index;
    }).filter(function (value) {
      // is that font family of external fontfile
      value = value.toLowerCase();
      return hrefs.some(function (href) {
        return href.toLowerCase().indexOf(value) > -1;
      });
    });
    //console.log(families);
    if ('Promise' in win) {
      return win.Promise.all(families.map(function (family) {
        return docum.fonts && docum.fonts.load('normal normal 400 16px/1.2\'' + family + '\'');
      }));
    } else {
      // return fake Promise object that "resolves" with timeout
      return {
        then: function (next) {
          win.setTimeout(next, families.length * 100);  // just reserve 100ms per font an thats all
        }
      };
    }
  }
  return {
    loadAllFontStyleSheets: loadAllFontStyleSheets,
    loadFonts: loadFonts
  };
}(utils);
excel_utils = function (U) {
  var win = this;
  var debug = false;
  function getFunction(name) {
    if (name[0] == '=')
      name = name.substr(1);
    switch (name) {
    case 'CONFIG':
      return function sleeknote(prop) {
        return this.config ? this.config[prop] : prop;
      };
    case 'GTMDL':
      return function gtmdl(prop) {
        return win.dataLayer ? U.findPropValue(win.dataLayer, prop) : prop;
      };
    case 'NOW':
      return function now() {
        return new Date();
      };
    case 'TEXT':
      return function formatDateTime(now, format) {
        var methods = [
          'getMonth',
          'getDate',
          'getHours',
          'getMinutes',
          'getSeconds',
          'getFullYear'
        ];
        var formats = [
          'MM',
          'DD',
          'hh',
          'mm',
          'ss',
          'YYYY'
        ];
        formats.forEach(function (part, index) {
          var val = now[methods[index]]();
          format = format.replace(part, index < 5 ? ('0' + val).substr(-2) : val);
        });
        return format;
      };
    }
    throw new Error('function ' + name + ' not found');
  }
  var methods = {
    toNumber: toNumber,
    trimEdges: trimEdges,
    invertNumber: invertNumber,
    throwError: function (errorName) {
      debug && console.log(errorName);
    },
    callVariable: function (variable) {
      debug && console.log('callVariable', variable);
      return variable;
    },
    callFunction: callFunction
  };
  function callFunction(name, params) {
    params || (params = []);
    const fn = getFunction(name);
    let value;
    if (fn) {
      debug && console.log('callFunction', name, params);
      value = fn.apply(this, params);
    }
    return value;
  }
  function trimEdges(string, margin) {
    if (margin === undefined)
      margin = 1;
    string = string.substring(margin, string.length - margin);
    return string;
  }
  function toNumber(number) {
    let result;
    if (typeof number === 'number') {
      result = number;
    } else if (typeof number === 'string') {
      result = number.indexOf('.') > -1 ? parseFloat(number) : parseInt(number, 10);
    }
    return result;
  }
  function invertNumber(number) {
    return -1 * toNumber(number);
  }
  return methods;
}(utils);
excel_parser_core = function (methods) {
  var o = function (k, v, o, l) {
      for (o = o || {}, l = k.length; l--; o[k[l]] = v);
      return o;
    }, $V0 = [
      1,
      5
    ], $V1 = [
      1,
      8
    ], $V2 = [
      1,
      6
    ], $V3 = [
      1,
      7
    ], $V4 = [
      1,
      9
    ], $V5 = [
      1,
      11
    ], $V6 = [
      1,
      12
    ], $V7 = [
      1,
      13
    ], $V8 = [
      1,
      15
    ], $V9 = [
      1,
      16
    ], $Va = [
      1,
      17
    ], $Vb = [
      1,
      18
    ], $Vc = [
      1,
      19
    ], $Vd = [
      1,
      20
    ], $Ve = [
      1,
      21
    ], $Vf = [
      1,
      22
    ], $Vg = [
      1,
      23
    ], $Vh = [
      5,
      9,
      10,
      11,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      23,
      24
    ], $Vi = [
      5,
      9,
      10,
      11,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      23,
      24,
      26
    ], $Vj = [
      5,
      9,
      10,
      11,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      23,
      24,
      28
    ], $Vk = [
      5,
      10,
      11,
      13,
      14,
      15,
      16,
      23,
      24
    ], $Vl = [
      5,
      10,
      13,
      14,
      15,
      23,
      24
    ], $Vm = [
      5,
      10,
      11,
      13,
      14,
      15,
      16,
      17,
      18,
      23,
      24
    ], $Vn = [
      13,
      23,
      24
    ];
  var parser = {
    trace: function trace() {
    },
    yy: {},
    symbols_: {
      error: 2,
      expressions: 3,
      expression: 4,
      EOF: 5,
      variableSequence: 6,
      number: 7,
      STRING: 8,
      '&': 9,
      '=': 10,
      '+': 11,
      '(': 12,
      ')': 13,
      '<': 14,
      '>': 15,
      '-': 16,
      '*': 17,
      '/': 18,
      '^': 19,
      FUNCTION: 20,
      expseq: 21,
      ARRAY: 22,
      ';': 23,
      ',': 24,
      VARIABLE: 25,
      DECIMAL: 26,
      NUMBER: 27,
      '%': 28,
      ERROR: 29,
      $accept: 0,
      $end: 1
    },
    terminals_: {
      5: 'EOF',
      8: 'STRING',
      9: '&',
      10: '=',
      11: '+',
      12: '(',
      13: ')',
      14: '<',
      15: '>',
      16: '-',
      17: '*',
      18: '/',
      19: '^',
      20: 'FUNCTION',
      22: 'ARRAY',
      23: ';',
      24: ',',
      25: 'VARIABLE',
      26: 'DECIMAL',
      27: 'NUMBER',
      28: '%',
      29: 'ERROR'
    },
    productions_: [
      0,
      [
        3,
        2
      ],
      [
        4,
        1
      ],
      [
        4,
        1
      ],
      [
        4,
        1
      ],
      [
        4,
        3
      ],
      [
        4,
        3
      ],
      [
        4,
        3
      ],
      [
        4,
        3
      ],
      [
        4,
        4
      ],
      [
        4,
        4
      ],
      [
        4,
        4
      ],
      [
        4,
        3
      ],
      [
        4,
        3
      ],
      [
        4,
        3
      ],
      [
        4,
        3
      ],
      [
        4,
        3
      ],
      [
        4,
        3
      ],
      [
        4,
        2
      ],
      [
        4,
        2
      ],
      [
        4,
        3
      ],
      [
        4,
        4
      ],
      [
        4,
        1
      ],
      [
        4,
        2
      ],
      [
        21,
        1
      ],
      [
        21,
        1
      ],
      [
        21,
        3
      ],
      [
        21,
        3
      ],
      [
        6,
        1
      ],
      [
        6,
        3
      ],
      [
        7,
        1
      ],
      [
        7,
        3
      ],
      [
        7,
        2
      ],
      [
        2,
        1
      ]
    ],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      /* this == yyval */
      var $0 = $$.length - 1;
      switch (yystate) {
      case 1:
        return $$[$0 - 1];
        break;
      case 2:
        this.$ = yy.callVariable($$[$0][0]);
        break;
      case 3:
        this.$ = yy.toNumber($$[$0]);
        break;
      case 4:
        this.$ = yy.trimEdges($$[$0]);
        break;
      case 5:
        this.$ = String($$[$0 - 2]) + String($$[$0]);
        break;
      case 6:
        this.$ = $$[$0 - 2] == $$[$0];
        break;
      case 7:
        this.$ = yy.toNumber($$[$0 - 2]) + yy.toNumber($$[$0]);
        break;
      case 8:
        this.$ = $$[$0 - 1];
        break;
      case 9:
        this.$ = $$[$0 - 3] <= $$[$0];
        break;
      case 10:
        this.$ = $$[$0 - 3] >= $$[$0];
        break;
      case 11:
        this.$ = $$[$0 - 3] != $$[$0];
        break;
      case 12:
        this.$ = $$[$0 - 2] > $$[$0];
        break;
      case 13:
        this.$ = $$[$0 - 2] < $$[$0];
        break;
      case 14:
        this.$ = $$[$0 - 2] - $$[$0];
        break;
      case 15:
        this.$ = $$[$0 - 2] * $$[$0];
        break;
      case 16:
        this.$ = $$[$0 - 2] / $$[$0];
        break;
      case 17:
        this.$ = Math.pow($$[$0 - 2], $$[$0]);
        break;
      case 18:
        var n1 = yy.invertNumber($$[$0]);
        this.$ = n1;
        if (isNaN(this.$)) {
          this.$ = 0;
        }
        break;
      case 19:
        var n1 = yy.toNumber($$[$0]);
        this.$ = n1;
        if (isNaN(this.$)) {
          this.$ = 0;
        }
        break;
      case 20:
        this.$ = yy.callFunction($$[$0 - 2]);
        break;
      case 21:
        this.$ = yy.callFunction($$[$0 - 3], $$[$0 - 1]);
        break;
      case 24:
      case 28:
        this.$ = [$$[$0]];
        break;
      case 25:
        this.$ = yy.trimEdges(yytext).split(',');
        break;
      case 26:
      case 27:
        $$[$0 - 2].push($$[$0]);
        this.$ = $$[$0 - 2];
        break;
      case 29:
        this.$ = Array.isArray($$[$0 - 2]) ? $$[$0 - 2] : [$$[$0 - 2]];
        this.$.push($$[$0]);
        break;
      case 30:
        this.$ = $$[$0];
        break;
      case 31:
        this.$ = ($$[$0 - 2] + '.' + $$[$0]) * 1;
        break;
      case 32:
        this.$ = $$[$0 - 1] * 0.01;
        break;
      case 33:
        this.$ = yy.throwError($$[$0]);
        break;
      }
    },
    table: [
      {
        2: 10,
        3: 1,
        4: 2,
        6: 3,
        7: 4,
        8: $V0,
        11: $V1,
        12: $V2,
        16: $V3,
        20: $V4,
        25: $V5,
        27: $V6,
        29: $V7
      },
      { 1: [3] },
      {
        5: [
          1,
          14
        ],
        9: $V8,
        10: $V9,
        11: $Va,
        14: $Vb,
        15: $Vc,
        16: $Vd,
        17: $Ve,
        18: $Vf,
        19: $Vg
      },
      o($Vh, [
        2,
        2
      ], {
        26: [
          1,
          24
        ]
      }),
      o($Vh, [
        2,
        3
      ], {
        28: [
          1,
          25
        ]
      }),
      o($Vh, [
        2,
        4
      ]),
      {
        2: 10,
        4: 26,
        6: 3,
        7: 4,
        8: $V0,
        11: $V1,
        12: $V2,
        16: $V3,
        20: $V4,
        25: $V5,
        27: $V6,
        29: $V7
      },
      {
        2: 10,
        4: 27,
        6: 3,
        7: 4,
        8: $V0,
        11: $V1,
        12: $V2,
        16: $V3,
        20: $V4,
        25: $V5,
        27: $V6,
        29: $V7
      },
      {
        2: 10,
        4: 28,
        6: 3,
        7: 4,
        8: $V0,
        11: $V1,
        12: $V2,
        16: $V3,
        20: $V4,
        25: $V5,
        27: $V6,
        29: $V7
      },
      {
        12: [
          1,
          29
        ]
      },
      o($Vh, [
        2,
        22
      ], {
        2: 30,
        29: $V7
      }),
      o($Vi, [
        2,
        28
      ]),
      o($Vj, [
        2,
        30
      ], {
        26: [
          1,
          31
        ]
      }),
      o([
        5,
        9,
        10,
        11,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        23,
        24,
        29
      ], [
        2,
        33
      ]),
      {
        1: [
          2,
          1
        ]
      },
      {
        2: 10,
        4: 32,
        6: 3,
        7: 4,
        8: $V0,
        11: $V1,
        12: $V2,
        16: $V3,
        20: $V4,
        25: $V5,
        27: $V6,
        29: $V7
      },
      {
        2: 10,
        4: 33,
        6: 3,
        7: 4,
        8: $V0,
        11: $V1,
        12: $V2,
        16: $V3,
        20: $V4,
        25: $V5,
        27: $V6,
        29: $V7
      },
      {
        2: 10,
        4: 34,
        6: 3,
        7: 4,
        8: $V0,
        11: $V1,
        12: $V2,
        16: $V3,
        20: $V4,
        25: $V5,
        27: $V6,
        29: $V7
      },
      {
        2: 10,
        4: 37,
        6: 3,
        7: 4,
        8: $V0,
        10: [
          1,
          35
        ],
        11: $V1,
        12: $V2,
        15: [
          1,
          36
        ],
        16: $V3,
        20: $V4,
        25: $V5,
        27: $V6,
        29: $V7
      },
      {
        2: 10,
        4: 39,
        6: 3,
        7: 4,
        8: $V0,
        10: [
          1,
          38
        ],
        11: $V1,
        12: $V2,
        16: $V3,
        20: $V4,
        25: $V5,
        27: $V6,
        29: $V7
      },
      {
        2: 10,
        4: 40,
        6: 3,
        7: 4,
        8: $V0,
        11: $V1,
        12: $V2,
        16: $V3,
        20: $V4,
        25: $V5,
        27: $V6,
        29: $V7
      },
      {
        2: 10,
        4: 41,
        6: 3,
        7: 4,
        8: $V0,
        11: $V1,
        12: $V2,
        16: $V3,
        20: $V4,
        25: $V5,
        27: $V6,
        29: $V7
      },
      {
        2: 10,
        4: 42,
        6: 3,
        7: 4,
        8: $V0,
        11: $V1,
        12: $V2,
        16: $V3,
        20: $V4,
        25: $V5,
        27: $V6,
        29: $V7
      },
      {
        2: 10,
        4: 43,
        6: 3,
        7: 4,
        8: $V0,
        11: $V1,
        12: $V2,
        16: $V3,
        20: $V4,
        25: $V5,
        27: $V6,
        29: $V7
      },
      {
        25: [
          1,
          44
        ]
      },
      o($Vj, [
        2,
        32
      ]),
      {
        9: $V8,
        10: $V9,
        11: $Va,
        13: [
          1,
          45
        ],
        14: $Vb,
        15: $Vc,
        16: $Vd,
        17: $Ve,
        18: $Vf,
        19: $Vg
      },
      o($Vk, [
        2,
        18
      ], {
        9: $V8,
        17: $Ve,
        18: $Vf,
        19: $Vg
      }),
      o($Vk, [
        2,
        19
      ], {
        9: $V8,
        17: $Ve,
        18: $Vf,
        19: $Vg
      }),
      {
        2: 10,
        4: 48,
        6: 3,
        7: 4,
        8: $V0,
        11: $V1,
        12: $V2,
        13: [
          1,
          46
        ],
        16: $V3,
        20: $V4,
        21: 47,
        22: [
          1,
          49
        ],
        25: $V5,
        27: $V6,
        29: $V7
      },
      o($Vh, [
        2,
        23
      ]),
      {
        27: [
          1,
          50
        ]
      },
      o($Vh, [
        2,
        5
      ]),
      o([
        5,
        10,
        13,
        23,
        24
      ], [
        2,
        6
      ], {
        9: $V8,
        11: $Va,
        14: $Vb,
        15: $Vc,
        16: $Vd,
        17: $Ve,
        18: $Vf,
        19: $Vg
      }),
      o($Vk, [
        2,
        7
      ], {
        9: $V8,
        17: $Ve,
        18: $Vf,
        19: $Vg
      }),
      {
        2: 10,
        4: 51,
        6: 3,
        7: 4,
        8: $V0,
        11: $V1,
        12: $V2,
        16: $V3,
        20: $V4,
        25: $V5,
        27: $V6,
        29: $V7
      },
      {
        2: 10,
        4: 52,
        6: 3,
        7: 4,
        8: $V0,
        11: $V1,
        12: $V2,
        16: $V3,
        20: $V4,
        25: $V5,
        27: $V6,
        29: $V7
      },
      o($Vl, [
        2,
        13
      ], {
        9: $V8,
        11: $Va,
        16: $Vd,
        17: $Ve,
        18: $Vf,
        19: $Vg
      }),
      {
        2: 10,
        4: 53,
        6: 3,
        7: 4,
        8: $V0,
        11: $V1,
        12: $V2,
        16: $V3,
        20: $V4,
        25: $V5,
        27: $V6,
        29: $V7
      },
      o($Vl, [
        2,
        12
      ], {
        9: $V8,
        11: $Va,
        16: $Vd,
        17: $Ve,
        18: $Vf,
        19: $Vg
      }),
      o($Vk, [
        2,
        14
      ], {
        9: $V8,
        17: $Ve,
        18: $Vf,
        19: $Vg
      }),
      o($Vm, [
        2,
        15
      ], {
        9: $V8,
        19: $Vg
      }),
      o($Vm, [
        2,
        16
      ], {
        9: $V8,
        19: $Vg
      }),
      o([
        5,
        10,
        11,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        23,
        24
      ], [
        2,
        17
      ], { 9: $V8 }),
      o($Vi, [
        2,
        29
      ]),
      o($Vh, [
        2,
        8
      ]),
      o($Vh, [
        2,
        20
      ]),
      {
        13: [
          1,
          54
        ],
        23: [
          1,
          55
        ],
        24: [
          1,
          56
        ]
      },
      o($Vn, [
        2,
        24
      ], {
        9: $V8,
        10: $V9,
        11: $Va,
        14: $Vb,
        15: $Vc,
        16: $Vd,
        17: $Ve,
        18: $Vf,
        19: $Vg
      }),
      o($Vn, [
        2,
        25
      ]),
      o($Vj, [
        2,
        31
      ]),
      o($Vl, [
        2,
        9
      ], {
        9: $V8,
        11: $Va,
        16: $Vd,
        17: $Ve,
        18: $Vf,
        19: $Vg
      }),
      o($Vl, [
        2,
        11
      ], {
        9: $V8,
        11: $Va,
        16: $Vd,
        17: $Ve,
        18: $Vf,
        19: $Vg
      }),
      o($Vl, [
        2,
        10
      ], {
        9: $V8,
        11: $Va,
        16: $Vd,
        17: $Ve,
        18: $Vf,
        19: $Vg
      }),
      o($Vh, [
        2,
        21
      ]),
      {
        2: 10,
        4: 57,
        6: 3,
        7: 4,
        8: $V0,
        11: $V1,
        12: $V2,
        16: $V3,
        20: $V4,
        25: $V5,
        27: $V6,
        29: $V7
      },
      {
        2: 10,
        4: 58,
        6: 3,
        7: 4,
        8: $V0,
        11: $V1,
        12: $V2,
        16: $V3,
        20: $V4,
        25: $V5,
        27: $V6,
        29: $V7
      },
      o($Vn, [
        2,
        26
      ], {
        9: $V8,
        10: $V9,
        11: $Va,
        14: $Vb,
        15: $Vc,
        16: $Vd,
        17: $Ve,
        18: $Vf,
        19: $Vg
      }),
      o($Vn, [
        2,
        27
      ], {
        9: $V8,
        10: $V9,
        11: $Va,
        14: $Vb,
        15: $Vc,
        16: $Vd,
        17: $Ve,
        18: $Vf,
        19: $Vg
      })
    ],
    defaultActions: {
      14: [
        2,
        1
      ]
    },
    // 		parseError: function parseError(str, hash) {
    // 			if (hash.recoverable) {
    // 				this.trace(str);
    // 			} else {
    // 				var error = new Error(str);
    // 				error.hash = hash;
    // 				throw error;
    // 			}
    // 		},
    parse: function parse(input) {
      var self = this, stack = [0],
        //tstack = [], // token stack
        vstack = [null],
        // semantic value stack
        lstack = [],
        // location stack
        table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0,
        //TERROR = 2,
        EOF = 1;
      var args = lstack.slice.call(arguments, 1);
      //this.reductionCount = this.shiftCount = 0;
      var lexer = Object.create(this.lexer);
      //             var sharedState = {
      //                 yy: {}
      //             };
      // copy state
      //             for (var k in this.yy) {
      //                 if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
      //                     sharedState.yy[k] = this.yy[k];
      //                 }
      //             }
      //lexer.setInput(input, sharedState.yy);
      lexer.setInput(input, this.yy);
      //             sharedState.yy.lexer = lexer;
      //             sharedState.yy.parser = this;
      //             if (typeof lexer.yylloc == 'undefined') {
      //                 lexer.yylloc = {};
      //             }
      var yyloc = lexer.yylloc;
      lstack.push(yyloc);
      var ranges = lexer.options && lexer.options.ranges;
      //             if (typeof sharedState.yy.parseError === 'function') {
      //                 this.parseError = sharedState.yy.parseError;
      //             } else {
      //			this.parseError = Object.getPrototypeOf(this).parseError;
      //}
      // 			function popStack(n) {
      // 				stack.length = stack.length - 2 * n;
      // 				vstack.length = vstack.length - n;
      // 				lstack.length = lstack.length - n;
      // 			}
      this.tokens = [];
      var lex = function () {
        var token;
        token = lexer.lex() || EOF;
        this.tokens.push({
          token: token,
          yytext: lexer.yytext
        });
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
          token = self.symbols_[token] || token;
        }
        return token;
      }.bind(this);
      var symbol, preErrorSymbol, state, action,
        //a,
        r, yyval = {},
        //p,
        len, newState;
      while (true) {
        // retreive state number from top of stack
        state = stack[stack.length - 1];
        // use default actions if available
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol === null || typeof symbol == 'undefined') {
            symbol = lex();
          }
          // read action for current state and first input
          action = table[state] && table[state][symbol];
        }
        /*
        				// handle parse error
        				_handle_error: if (typeof action === 'undefined' || !action.length || !action[0]) {
        					var error_rule_depth;
        					var errStr = '';
        
        					// Return the rule stack depth where the nearest error rule can be found.
        					// Return FALSE when no error recovery rule was found.
        					function locateNearestErrorRecoveryRule(state) {
        						var stack_probe = stack.length - 1;
        						var depth = 0;
        
        						// try to recover from error
        						for (;;) {
        							// check for error recovery rule in this state
        							if (TERROR.toString() in table[state]) {
        								return depth;
        							}
        							if (state === 0 || stack_probe < 2) {
        								return false; // No suitable error recovery rule available.
        							}
        							stack_probe -= 2; // popStack(1): [symbol, action]
        							state = stack[stack_probe];
        							++depth;
        						}
        					}
        
        					if (!recovering) {
        						// first see if there's any chance at hitting an error recovery rule:
        						error_rule_depth = locateNearestErrorRecoveryRule(state);
        
        						// Report error
        						expected = [];
        						for (p in table[state]) {
        							if (this.terminals_[p] && p > TERROR) {
        								expected.push("'" + this.terminals_[p] + "'");
        							}
        						}
        						if (lexer.showPosition) {
        							errStr =
        								'Parse error on line ' +
        								(yylineno + 1) +
        								':\n' +
        								lexer.showPosition() +
        								'\nExpecting ' +
        								expected.join(', ') +
        								", got '" +
        								(this.terminals_[symbol] || symbol) +
        								"'";
        						} else {
        							errStr =
        								'Parse error on line ' +
        								(yylineno + 1) +
        								': Unexpected ' +
        								(symbol == EOF ? 'end of input' : "'" + (this.terminals_[symbol] || symbol) + "'");
        						}
        						this.parseError(errStr, {
        							text: lexer.match,
        							token: this.terminals_[symbol] || symbol,
        							line: lexer.yylineno,
        							loc: yyloc,
        							expected: expected,
        							recoverable: error_rule_depth !== false,
        						});
        					} else if (preErrorSymbol !== EOF) {
        						error_rule_depth = locateNearestErrorRecoveryRule(state);
        					}
        
        					// just recovered from another error
        					if (recovering == 3) {
        						if (symbol === EOF || preErrorSymbol === EOF) {
        							throw new Error(errStr || 'Parsing halted while starting to recover from another error.');
        						}
        
        						// discard current lookahead and grab another
        						yyleng = lexer.yyleng;
        						yytext = lexer.yytext;
        						yylineno = lexer.yylineno;
        						yyloc = lexer.yylloc;
        						symbol = lex();
        					}
        
        					// try to recover from error
        					if (error_rule_depth === false) {
        						throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');
        					}
        					popStack(error_rule_depth);
        
        					preErrorSymbol = symbol == TERROR ? null : symbol; // save the lookahead token
        					symbol = TERROR; // insert generic error symbol as new lookahead
        					state = stack[stack.length - 1];
        					action = table[state] && table[state][TERROR];
        					recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
        				}
        
        				// this shouldn't happen, unless resolve defaults are off
        				if (action[0] instanceof Array && action.length > 1) {
        					throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        				}
        				*/
        switch (action[0]) {
        case 1:
          // shift
          //this.shiftCount++;
          stack.push(symbol);
          vstack.push(lexer.yytext);
          lstack.push(lexer.yylloc);
          stack.push(action[1]);
          // push state
          symbol = null;
          if (!preErrorSymbol) {
            // normal execution/no error
            yyleng = lexer.yyleng;
            yytext = lexer.yytext;
            yylineno = lexer.yylineno;
            yyloc = lexer.yylloc;
            if (recovering > 0) {
              recovering--;
            }
          } else {
            // error just occurred, resume old lookahead f/ before error
            symbol = preErrorSymbol;
            preErrorSymbol = null;
          }
          break;
        case 2:
          // reduce
          //this.reductionCount++;
          len = this.productions_[action[1]][1];
          // perform semantic action
          yyval.$ = vstack[vstack.length - len];
          // default to $$ = $1
          // default location, uses first token for firsts, last for lasts
          yyval._$ = {
            first_line: lstack[lstack.length - (len || 1)].first_line,
            last_line: lstack[lstack.length - 1].last_line,
            first_column: lstack[lstack.length - (len || 1)].first_column,
            last_column: lstack[lstack.length - 1].last_column
          };
          if (ranges) {
            yyval._$.range = [
              lstack[lstack.length - (len || 1)].range[0],
              lstack[lstack.length - 1].range[1]
            ];
          }
          //r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));
          r = this.performAction.apply(yyval, [
            yytext,
            yyleng,
            yylineno,
            this.yy,
            action[1],
            vstack,
            lstack
          ].concat(args));
          if (typeof r !== 'undefined') {
            return r;
          }
          // pop off stack
          if (len) {
            stack = stack.slice(0, -1 * len * 2);
            vstack = vstack.slice(0, -1 * len);
            lstack = lstack.slice(0, -1 * len);
          }
          stack.push(this.productions_[action[1]][0]);
          // push nonterminal (reduce)
          vstack.push(yyval.$);
          lstack.push(yyval._$);
          // goto new state = table[STATE][NONTERMINAL]
          newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
          stack.push(newState);
          break;
        case 3:
          // accept
          return true;
        }
      }
      return true;
    }
  };
  function Parser(tokens, context) {
    this.yy = methods;
    this.yy.callFunction = this.yy.callFunction.bind(context);
    this.lexer = {
      tokens: tokens,
      yylloc: {},
      setInput: function () {
      },
      lex: function lex() {
        var t = this.tokens.shift();
        this.yytext = t.yytext;
        return t.token;
      }
    };
  }
  Parser.prototype = parser;
  parser.Parser = Parser;
  return Parser;
}(excel_utils);
note2 = function (B, U, CSS, support, validateInputs, CONST, layout, SleekNote, behaviour, Location, click, emit, locale, LE, SiteData, fontLoader, excelParser, excelUtils) {
  //var editor = SleekNote.editor || SleekNote.preview;
  //var metaContent;
  var win = this;
  var doc = win.document;
  var noIFrames = SleekNote.CustomInitSettings.noIFrames;
  //var editorMobileWidth = 355;
  var debug = SleekNote.debugMessage('a');
  function openPopupIf(event, href, target) {
    if (target == '_blank') {
      var node = event.target.ownerDocument.body;
      node.insertAdjacentHTML('beforeend', '<a style="width:0;height:0" href="' + href + '" target="_blank" rel="noopener"></a>');
      U.click(node.lastElementChild, event);
    }
  }
  function domainParser(url) {
    return Location.extractDomain(url);
  }
  function evenValue(value) {
    return value % 2 ? value + 1 : value;
  }
  // 	function qsNode(node) {
  // 		if (node && node.nodeType == 11 && noIFrames) {
  //
  // 		}
  // 		return node;
  // 	}
  function qsa(node, selector) {
    return U.qsa(selector, node);
  }
  function qs(node, selector) {
    return U.qs(selector, node);
  }
  var sides = [
    'top',
    'left',
    'bottom',
    'right'
  ];
  var zeroPadding = {
    top: 0,
    left: 0,
    bottom: 0,
    right: 0
  };
  function paddingCSS(padding) {
    if (padding === 0)
      padding = zeroPadding;
    return {
      paddingTop: padding.top,
      paddingRight: padding.right,
      paddingBottom: padding.bottom,
      paddingLeft: padding.left
    };
  }
  /*
  	// document all config properties here
  	/*
  	var cfg = {
  		// runtime
  		base:
  		boxNode: 0,
  		DOMNode: 0,
  		formNode: 0,
  		images: 0,
  		current: 0,
  		next: 0,
  		reveal: 0,
  		bounds: 0,
  		width: 0,
  		height: 0,
  		boundsHeight: 0,
  		isHidden: 0,
  		submitted: 0,
  		counter: 0,
  		guid: 0,
  
  		// static
  
  		summaryId: 0, // used in mimir
  
  		id: 0, // box DOM id
  		type: 0, // form, teaser, success
  		noteType: 0, // goal - nwesletter, promote, etc
  		name: 0,
  		campaignId: 0,
  		customerId: 0,
  		version: 0,
  		position: 0,
  		placement: 0, // for sleekbar
  		profile: 0,
  		purpose: 0, // editor, preview, production
  
  		toggle: 0, // selector for toggleDOMNode
  		mobile: 0, // easy flag for old note-support and mimir, calculated in preprocessor
  
  		distanceFromEdge: 0,
  		relativeWidth: 0, // mangled in preprocessor ? is it even needed, as we do that in behaviour anyway
  		attach: 0, // 'left or 'right'
  
  		teaser: 0, // on form close box name
  		form: 0, // on teaser click box name
  		success: 0, // on form submit box name
  
  		redirect: 0,
  
  		teaserDelay: 0,
  
  		locale: 0,
  		timeZone: 0,
  
  		hostname: 0, // used for badge and for image links in clerk
  
  		width1: 0, // version 1 width
  		height1: 0, // version 2 width
  	};
  	*/
  // list of old sleeknotes inline click handlers
  // 	var methodList = [
  // 		'toggleForm',
  // 		'mimimizeForm',
  // 		'maximizeForm',
  // 		'redirectBox',
  // 		'openTeaser',
  // 		'outsideClick',
  //
  // 		// those are from version 1, cannot be changed
  // 		'hideBox',
  // 		'openSleeknote',
  // 		'socialSubmitSleeknoteBox',
  // 		'contactSubmitSleeknoteBox',
  // 		'submitSleeknoteBox',
  // 		'submitBlankSleeknoteBox',
  // 		'hideTeaserAndDontShowAgain',
  // 	];
  /*
  	'data-sn-custom-value'
  	'[data-sn-type="grid"]'
  	'[data-sn-type="sleeknote-wrapper"]'
  	'[data-sn-type="close"]>[image-type="content-svg"]'
  	'[data-sn-type="counter"] ['type', 'date', 'message', 'seconds', 'moment-unix', 'zero-logic']
  	'[data-sn-custom-step="toggleForm"]'
  	'[data-sn-type="close"], .sleeknoteMobileClose'
  	'[onclick]'
  	'[data-sn-type="button"]'
  	'.linkbutton, img, a, [data-sn-custom-action]'
  	'data-sn-custom-href'
  	'data-sn-custom-email'
  	'.inline-button')) {
  	var stepMap = { showTeaser: 'teaser', showTogglersBox: 'form', showForm: 'form', showTogglersSuccess: 'success', showSuccess: 'success' };
  	'data-click'
  	'data-id',
  	'data-track-id'
  	'[data-sn-type=close], .sleeknoteMobileClose'
  	'#sleeknoteBox'
  	'#sleeknote-form'
  	'href'
  	'target'
  	'data-section'
  	'data-sn-send-mimir-event'
  	'data-sn-custom-href'
  	'data-sn-custom-email'
  	'data-sn-custom-target'
  	'data-sn-custom-step'
  	'data-campaign'
  
  */
  function removeCSS(docum) {
    var fontsToLoad = [];
    qsa(docum, 'link').forEach(function (link) {
      var href = link.href.toLowerCase();
      if (~href.indexOf('font')) {
        fontsToLoad.push(link.href);
      }
      U.removeNode(link);
    });
    return fontsToLoad;
  }
  function head(docum) {
    return docum.querySelector('head');  //return docum.defaultView ? docum.head : docum.firstChild;
  }
  function body(docum) {
    switch (docum.nodeType) {
    case 9:
    case 11:
      return docum.querySelector('body');
    }
    return docum;  //return docum.defaultView ? docum.body : docum.lastChild;
  }
  function getDoc(docum) {
    switch (docum.nodeType) {
    case 9:
    case 11:
      return docum;
    }
    return docum.ownerDocument;
  }
  function addMobileCloseButton(docum, height) {
    if (U.contains(this.config.position, CONST.POS.HELLO, CONST.POS.HELLO2))
      return;
    var mobileCloseStyles = {
      position: 'absolute',
      left: 0,
      top: 0,
      zIndex: 9999,
      background: '#fff',
      width: '100%',
      textAlign: 'right',
      color: '#474747',
      fontFamily: '\'Helvetica Neue\', arial, sans-serif',
      fontStyle: 'italic',
      fontSize: 14,
      borderBottom: '1px solid #ddd',
      height: height
    };
    if (this.config.version == 2) {
      mobileCloseStyles.borderTopRightRadius = mobileCloseStyles.borderTopLeftRadius = 10;
      qsa(docum, 'form .row:first-child .column').forEach(function (node) {
        var p = parseInt(CSS.get(node, 'paddingTop'), 10);
        CSS.set(node, 'paddingTop', p + height);
      });
    }
    var closeIcon = '<img src="//sleeknoteimages.sleeknote.com/mobile-close' + (B.is.retina ? '_retina' : '') + '.png" class="mobile-close-icon" style="cursor:pointer;position:absolute;right:7px;top:7px;' + (B.is.retina ? 'width:26px;' : '') + '">';
    var mobileCloseButton = '<div class="sleeknoteMobileClose" style="' + CSS.inline(mobileCloseStyles, true) + '">' + closeIcon + '</div>';
    U.insertHTML(this.config.formNode, mobileCloseButton);
  }
  // TODO: in editor
  function setTabIndex(docum) {
    var formNode = this.config.formNode;
    var formElements = [];
    var topPosition = function (a, b) {
      return a.containerIndex * 100 + a.order - (b.containerIndex * 100 + b.order) || a.top - b.top || a.left - b.left;
    };
    var parentContainers = qsa(formNode, '.flex-container');
    function findContainerIndex(element) {
      var foundIndex = 0;
      parentContainers.forEach(function (parent, index) {
        if (parent.contains(element)) {
          foundIndex = index;
          return false;
        }
      });
      return foundIndex;
    }
    // SET TABINDEX
    qsa(formNode, '.form-element, .element').forEach(function (elem) {
      U.slice(elem.children).forEach(function (child, index) {
        if ((child.nodeName == 'INPUT' || child.nodeName == 'TEXTAREA' || child.nodeName == 'BUTTON') && child.getAttribute('type') != 'hidden') {
          // quick hack
          if (child.getAttribute('data-sn-custom-value'))
            child.setAttribute('value', child.getAttribute('data-sn-custom-value'));
          var index = findContainerIndex(child);
          var bounds = elem.getBoundingClientRect();
          formElements.push({
            obj: child,
            top: bounds.top,
            left: bounds.left,
            order: CSS.get(elem, 'order') || CSS.get(elem.parentElement, 'order'),
            containerIndex: index || 0
          });  // 					formElements.push({
               // 						obj: child,
               // 						top: CSS.get(elem, 'top') || CSS.get(elem.parentElement, 'top'),
               // 						left: CSS.get(elem, 'left') || CSS.get(elem.parentElement, 'left'),
               // 						order: CSS.get(elem, 'order') || CSS.get(elem.parentElement, 'order'),
               // 						containerIndex: index || 0,
               // 					});
        }
      });
    });
    formElements.sort(topPosition);
    formElements.forEach(function (elem, i) {
      elem.obj.setAttribute('tabindex', i + 1);
    });
  }
  function PNG2SVG(docum) {
    var cfg = this.config;
    var close123456 = '<svg xmlns="http://www.w3.org/2000/svg" style="width:100%;height:100%" viewBox="0 0 66 66"><circle cx="33" cy="33" r="30" fill="#444"/><path fill="#FFF" d="M33.485 26.414l4.95-4.95a5 5 0 0 1 7.071 7.072l-4.95 4.95 4.95 4.949a5 5 0 0 1-7.071 7.071l-4.95-4.95-4.95 4.95a5 5 0 0 1-7.07-7.071l4.95-4.95-4.95-4.95a5 5 0 1 1 7.07-7.07l4.95 4.95z"/></svg>';
    if (cfg.version > 3) {
      qsa(docum, 'img').forEach(function (img) {
        if (img.src.indexOf('sleeknote.com/template-images/123456_close_button.png') > 0) {
          var parent = img.parentNode;
          //var css = img.cssText;
          parent.innerHTML = close123456;
        }
      });
    }
  }
  function adjustTabletSleekbar(docum) {
    var cfg = this.config;
    var box = cfg.boxNode;
    var form = cfg.formNode;
    if (cfg.profile != CONST.PROFILE.TABLET || !behaviour.isSleekBar(cfg))
      return;
    // transform tablets sleekbar
    // 1. make close button tap area bigger
    // 2. allow 100% width
    // 3. move close button "inside"
    var box;
    var element;
    var closeWidth;
    //var padding;
    //var containerPadding = 0;
    //var closeSize;
    var marginLeft = 10;
    var marginRight = 10;
    var node = qsa(docum, '[data-sn-type="close"]>[image-type="content-svg"]')[0];
    if (node) {
      element = node.parentNode;
      box = element.parentNode;
      // which side close button is?
      var right = box.style.left == '';
      closeWidth = CSS.get(box, 'width');
      var margin = closeWidth * 3;
      marginLeft = right ? 10 : margin;
      marginRight = right ? margin : 10;
    }
    CSS.set(form, {
      width: 'auto',
      marginLeft: marginLeft,
      marginRight: marginRight
    });
    // this is HIGHLY opinionated, but the e-mail on tablets is TAD wide and button could be TAD squeezed, on portrait that is
    try {
      var email = qsa(docum, '[type="email"]')[0];
      var button = qsa(docum, '[data-sn-type="button"]')[0];
      if (email && button) {
        email = U.querySelectorClosest(email, '.flexbox');
        button = U.querySelectorClosest(button, '.flexbox');
        marginRight = win.getComputedStyle(email).marginRight;
        var emailWidth = parseInt(email.style.width.split('(')[1], 10) - 3;
        var buttonWidth = parseInt(button.style.width.split('(')[1], 10) + 3;
        email.style.width = 'calc(' + emailWidth + '% - ' + marginRight + ')';
        button.style.width = 'calc(' + buttonWidth + '% - ' + marginRight + ')';
      }
    } catch (e) {
    }
  }
  function fixVersion2DOM(docum) {
    var cfg = this.config;
    var box = cfg.boxNode;
    var grid;
    var wrap;
    if (cfg.version == 2) {
      var bounds = this.getBoxBounds(true);
      // figure out grid's free size, apply, take care of protruding elements like close buttons and stickers
      grid = box.querySelector('[data-sn-type="grid"]');
      wrap = box.querySelector('[data-sn-type="sleeknote-wrapper"]');
      CSS.set(grid, {
        overflow: 0,
        width: bounds.width,
        height: ''
      });
      CSS.set(wrap, {
        paddingTop: '',
        paddingRight: '',
        paddingBottom: '',
        paddingLeft: ''
      });
      qsa(box, '.row').forEach(function (row) {
        qsa(row, '.column-bg').forEach(function (bg) {
          CSS.set(bg, 'height', '');
        });
      });
      if (cfg.profile == CONST.PROFILE.MOBILE) {
        CSS.set(wrap, paddingCSS(0));
      } else {
        CSS.set(grid, {
          width: bounds.width,
          height: bounds.height
        });
        qsa(box, '.row').forEach(function (row) {
          var rowBounds = row.getBoundingClientRect();
          qsa(row, '.column-bg').forEach(function (bg) {
            CSS.set(bg, 'height', rowBounds.height);
          });
        });
      }
    }
  }
  function fixDOM(docum) {
    var cfg = this.config;
    var box = cfg.boxNode;
    var form = cfg.formNode;
    cfg.version = +cfg.version || 0;
    // unescep text
    qsa(body(docum), '.inline-editor *').forEach(function (span) {
      U.slice(span.childNodes).forEach(function (node) {
        if (node.nodeType == 3) {
          node.textContent = node.textContent.replace(/\\'/g, '\'');
        }
      });
    });
    if (!this.editor) {
      qsa(body(docum), '.flexbox [style*="display:none"], .flexbox[style*="display: none"]').forEach(function (node) {
        // in case user has left in inputs that are not accessible, convert them here for hidden form fields
        // the second one erases hidden mobile alternative close bar (its either close bar or toggle bar)
        qsa(node, 'input').forEach(function (input) {
          if (input.type == 'hidden')
            return;
          var val = U.parseNodeValue(input);
          var data = {};
          if (val !== undefined) {
            data[input.name] = val;
            this.insertOrReplaceHiddenInputs(docum, data);
          }
        }, this);
        U.removeNode(node);
      }, this);
    }
    /*
    CSS.set(body(docum), {
    	position: 'static',
    	height: B.is.genuineApple || B.is.genuineAndroid ? 'auto' : '100vh',
    	//minHeight: '100vh',
    });
    */
    //body(docum).setAttribute('data-campaign', cfg.campaignId);
    // 		if (cfg.relativeWidth) {
    // 			if (!this.isHello) {
    // 				CSS.set(form, {
    // 					width: this.editor ? editorMobileWidth : '100%',
    // 				});
    // 			}
    // 			CSS.set(box, {
    // 				width: '100%',
    // 			});
    // 		}
    CSS.set(box, {
      // 			left: 'auto',
      // 			bottom: 'auto',
      // 			top: 'auto',
      // 			right: 'auto',
      marginLeft: 0,
      marginTop: 0,
      marginBottom: 0,
      marginRight: 0,
      zIndex: '',
      display: 1,
      float: 'left'
    });
    if (cfg.profile == CONST.PROFILE.DESKTOP && !behaviour.isSleekBar(this.config)) {
      CSS.set(box, { width: 'auto' });
    }
    // leave space for auto-inserted mobile close box
    if (!this.editor && support && cfg.version > 2 && cfg.profile == CONST.PROFILE.MOBILE && !U.contains(cfg.position, CONST.POS.HELLO2, CONST.POS.HELLO) && U.contains(cfg.type, 'form', 'success')) {
      //TODO: we need to 'fix' that mobile close bar insertion properly one day
      CSS.set(form, { paddingTop: 40 });
      addMobileCloseButton.call(this, docum, 40);
    }
    if (behaviour.isSleekBar(this.config)) {
      this.setToggleIf(docum);  // 			CSS.set(box, {
                                // 				right: 0,
                                // 			});
    }
    // force the same as flexbox-model.js
    qsa(docum, 'li.flexbox').forEach(function (node) {
      CSS.set(node, { overflow: node.classList.contains('flex-container') ? 0 : 1 });
    }, this);
    // testing here first before resaving all sleeknotes
    // some texts do not flow exactly like we hope because line-height is bit different in Firefix and Chrome, Chrome does not
    // support fractional line-heights while FF does
    qsa(box, 'li.box').forEach(function (li) {
      CSS.set(li, { overflow: 1 });
    });  //setTabIndex.call(this, docum);
         //setLayout.call(this);
  }
  function insertCustomContent(docum) {
    var cc = SleekNote.CustomInitSettings.customContent;
    if (U.typeStr(cc) == 'object') {
      Object.keys(cc).forEach(function (key) {
        var nodes = qsa(docum, cc[key].selector);
        var node = nodes && nodes[nodes.length - 1];
        if (node) {
          if (cc[key].attr == 'textContent') {
            node.innerHTML = cc[key].content;
          } else {
            node.setAttribute(cc[key].attr, cc[key].content);
          }
        }
      }, this);
    }
  }
  function allowBackgroundClicks(docum) {
    qsa(docum, '.column-bg').forEach(function (node) {
      if (node.hasAttribute('data-click')) {
        docum.head.insertAdjacentHTML('beforeend', '<style>[data-sn-type="text"] {pointer-events: none!important;}</style>');
      }
    }, this);
  }
  function addClickAttribute(node, str) {
    var dataId;
    // 		if (func) {
    // 			this[str] = func;
    // 			this.methodList.push(str);
    // 		}
    if (str && str in this) {
      node.setAttribute('data-click', str);
      dataId = node.getAttribute('data-id') || node.parentElement && node.parentElement.getAttribute('data-id');
      dataId && node.setAttribute('data-track-id', dataId);
    }
  }
  function addClickAttributes(docum) {
    // new close buttons
    qsa(docum, '[data-sn-type="close"], .sleeknoteMobileClose').forEach(function (node) {
      if (U.contains(this.config.profile, CONST.PROFILE.MOBILE, CONST.PROFILE.TABLET)) {
        this.mobileButtons.push(node);
        return;
      }
      addClickAttribute.call(this, node, this.getCloseFunc());
      // apparently needed for IE, but should work for all
      if (!node.classList.contains('sleeknoteMobileClose') && this.config.profile == CONST.PROFILE.DESKTOP)
        CSS.set(node, {
          width: '100%',
          height: '100%',
          lineHeight: 0
        });
    }, this);
    // old sleeknotes onclick -> data-onclick
    qsa(docum, '[onclick]').forEach(function (node) {
      var func = node.getAttribute('onclick').replace('()', '').replace(';', '');
      node.removeAttribute('onclick');
      addClickAttribute.call(this, node, func == 'hideBox' ? this.getCloseFunc() : func);
    }, this);
    if (U.contains(this.config.profile, CONST.PROFILE.MOBILE, CONST.PROFILE.TABLET)) {
      addClickAttribute.call(this, noIFrames ? docum.querySelector('section') : body(docum), 'outsideClick');
    }
    if (this.config.type == 'teaser') {
      qsa(docum, this.config.id).forEach(function (node) {
        addClickAttribute.call(this, node, 'openSleeknote');
      }, this);
    }
    // submit buttons
    qsa(docum, '[data-sn-type="button"]').forEach(function (node) {
      var onClick;
      switch (this.config.noteType) {
      case 'social':
        onClick = 'socialSubmitSleeknoteBox';
        break;
      case 'newsletter':
        onClick = 'submitSleeknoteBox';
        break;
      case 'contact':
        onClick = 'contactSubmitSleeknoteBox';
        break;
      case 'blank':
      case 'promote':
      case 'guide':
        //Delete after 2018
        debug(this.config.noteType + ' should be used anymore');
        onClick = 'submitBlankSleeknoteBox';
        break;
      default:
        return;
      }
      addClickAttribute.call(this, node, onClick);
    }, this);
    // everything else
    //if (!this.editor) {
    qsa(docum, '.linkbutton, img, a, [data-sn-custom-action]').forEach(function (node) {
      if (node.tagName == 'IMG') {
        // only some images are clickable
        if (!(node.getAttribute('data-sn-custom-href') || node.getAttribute('data-sn-custom-email')))
          return;
      }
      if (this.config.profile == CONST.PROFILE.MOBILE && node.classList.contains('inline-button')) {
        this.mobileButtons.push(node);
        return;
      }
      addClickAttribute.call(this, node, 'redirectBox');
    }, this);  //}
  }
  function addEventListeners(docum) {
    if (this.editor && !noIFrames && this.controller.manager.editorVersion < 4) {
      U.listener(docum, 'add', function (e) {
        var synthEvent;
        if (U.contains(e.type, 'click', 'mousemove', 'mousedown', 'mouseup')) {
          synthEvent = new win.MouseEvent(e.type, e);
          try {
            SleekNote.editor.event('APP.INTERACTION', e.target);
          } catch (e) {
          }
        } else if (U.contains(e.type, 'keydown', 'keyup')) {
          synthEvent = new win.KeyboardEvent(e.type, e);
        } else if (U.contains(e.type, 'input')) {
          synthEvent = new win.InputEvent(e.type, e);
        } else if (U.contains(e.type, 'selectionchange')) {
          synthEvent = new win.Event(e.type, e);
        } else if (U.contains(e.type, 'input')) {
          synthEvent = new win.InputEvent(e.type, e);
        } else if (U.contains(e.type, 'focusin', 'focusout')) {
          synthEvent = new win.FocusEvent(e.type, e);
        }
        synthEvent.initialTarget = e.target;
        if (!win.top.document.documentElement.dispatchEvent(synthEvent))
          synthEvent.preventDefault();
      }, true)('keydown')('keyup')('input')('focusin')('focusout')('selectionchange')('click')('mousemove')('mousedown')('mouseup');
      U.listener(docum.defaultView, 'add', function (event) {
        var data;
        try {
          data = U.JSON.parse(event.data);
        } catch (e) {
          return;
        }
        if (data.fingerprint == 'SleekNote' && data.command == 'ping') {
          docum.defaultView.parent.postMessage(U.JSON.stringify({
            fingerprint: 'SleekNote',
            command: 'pong'
          }), '*');
        }
      })('message');
    }
  }
  function addResizeListeners(docum) {
    return;
    if (!this.editor)
      return;
    this.onResize = function () {
      if (!this.toggleDOMNode(docum)) {
        if (this.config.current == 'half')
          this.config.current = 'open';
      }
      this.calculateDimensions();
      this.createSpaceAround();
    }.bind(this);
    this.prevDims = {
      width: -1,
      height: -1
    };
    //PP: this is rather pointless now, i think we do not need resizehandler at all...
    var addResizeListener = function (node, execute) {
      var resizeHandler = function (event) {
        if (!this.visible)
          return;
        var b = node.getBoundingClientRect();
        // while page animations mobile window changes width, block resize events
        // TODOREL
        if (/*node.parentElement.style.width == '100%' ||*/
          ~~b.width == ~~this.prevDims.width && ~~b.height == ~~this.prevDims.height)
          return;
        this.prevDims.width = b.width;
        this.prevDims.height = b.height;
        if (this.animating)
          return;
        // save height to config on every resize event
        win.setTimeout(this.onResize, 0);
      }.bind(this);
      try {
        var w = U.getWindow(node);
      } catch (e) {
        return;
      }
      U.listener(w, 'add', resizeHandler)('resize');
      if (execute)
        resizeHandler({ target: node.ownerDocument.defaultView });
    }.bind(this);
    var mutationCallback = function (mutations) {
      mutations.forEach(function (mutation) {
        if (mutation.type = 'attributes' && mutation.attributeName == 'style') {
          // we only detect background elements now as only they have drop-shadows
          if (U.matchesSel(mutation.target, '[style*="box-shadow"]')) {
            this.prevDims = {
              width: -1,
              height: -1
            };
            this.onResize();
          }
        }
        if (mutation.type != 'childList')
          return;
        mutation.addedNodes.forEach(function (node) {
          node.classList && node.classList.contains('resize-listener') && addResizeListener(node, true);
        });
      }, this);
    }.bind(this);
    // we have object DIV in sleeknote which like iframe has contentWindow. We listen its resize events to retrieve always correct height for success and form
    // because sometimes we replace while form, the original listener gets lost, then we add it back with Mutation Observer
    new win.MutationObserver(mutationCallback).observe(body(docum), {
      childList: true,
      subtree: true,
      attributes: true,
      attributeOldValue: true,
      attributeFilter: ['style']
    });
    var resizeElement = qsa(docum, '.resize-listener');
    // TODO: probably not needed in bot after all anymore
    if (!resizeElement.length && this.editor && !this.preview) {
      this.config.boxNode.insertAdjacentHTML('afterbegin', '<object class="resize-listener" style="display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;" type="text/html" data="about:blank"></object>');
      resizeElement = [docum.querySelector('.resize-listener')];
    }
    win.setTimeout(function () {
      resizeElement.forEach(addResizeListener);
    }, 0);
  }
  function setLayout(docum) {
  }
  function fixFlexboxWidths(docum) {
    qsa(docum, '.flexbox').forEach(function (node) {
      if (U.empty(node.style.position) && U.empty(node.style.flex)) {
        var width = parseInt(node.style.width, 10);
        if (width < 100 && width > 0) {
          node.style.flex = '0 1 auto';
          node.style.width = 'calc(' + node.style.width + ' - ' + node.style.marginRight + ')';
        }
      }
    });
  }
  function removeNodesNotNeeded(docum) {
    var cfg = this.config;
    Array.prototype.slice.call(qs(docum, cfg.id).parentNode.children).forEach(function (node) {
      if ('#' + node.id != cfg.id)
        U.removeNode(node);
    }, this);
    qsa(docum, 'script, object, iframe, base').forEach(U.removeNode);
  }
  function fixEdge(docum) {
    if (B.is.edge) {
      qsa(docum, 'input').forEach(function (input) {
        input.style.height = '';
      });
    }
  }
  function Note(controller, options, oninserted) {
    this.name = 'Note';
    this.controller = controller;
    this.config = behaviour.defaults(options.config.type, options.config);
    if (!this.config.current)
      this.config.current = 'close';
    this.config.next = this.config.current;
    this.config.reveal = this.config.toggle ? 'half' : 'open';
    this.config.base = this.controller.manager.getBase();
    var fragment;
    var fontsToLoad = [];
    this.modules = {};
    this.afterrender = [];
    this.mobileButtons = [];
    this.useIFrame = false;
    // list of old sleeknotes inline click handlers
    this.methodList = [
      'toggleForm',
      'mimimizeForm',
      'maximizeForm',
      'redirectBox',
      'openTeaser',
      'outsideClick',
      // those are from version 1, cannot be changed
      'hideBox',
      'openSleeknote',
      'socialSubmitSleeknoteBox',
      'contactSubmitSleeknoteBox',
      'submitSleeknoteBox',
      'submitBlankSleeknoteBox',
      'hideTeaserAndDontShowAgain'
    ];
    this.updateCounter = this.updateCounter.bind(this);
    if (U.typeStr(options.html) == 'function') {
      // editor v4
      fragment = options.html;
    } else {
      // 			var element = win.document.createElement('html');
      // 			element.innerHTML = options.html;
      // 			fragment = win.document.createDocumentFragment();
      // 			while (element.hasChildNodes()) fragment.appendChild(element.firstChild);
      // the difference here is that we apply html into fragment, so no images start to load here
      // this works, but not intuitively e.g. it shouldn't: html.innerHTML = '<html>...' does the correct thing
      var template = doc.createElement('template');
      if ('content' in template) {
        fragment = template.content;
      } else {
        fragment = win.document.createDocumentFragment();
      }
      fragment.appendChild(win.document.createElement('html'));
      fragment.childNodes[0].innerHTML = options.html;
      this.getNodes(fragment);
      fixFlexboxWidths.call(this, fragment);
      removeNodesNotNeeded.call(this, fragment);
      PNG2SVG.call(this, fragment);
      //fixBaseTag.call(this, fragment);
      adjustTabletSleekbar.call(this, fragment);
      fixVersion2DOM.call(this, fragment);
      fixDOM.call(this, fragment);
      insertCustomContent.call(this, fragment);
      //allowBackgroundClicks.call(this, fragment);
      addClickAttributes.call(this, fragment);
      this.findModules(fragment, true);
      if (!noIFrames) {
        head(fragment).insertAdjacentHTML('beforeend', this.controller.manager.stylesheets[this.config.version].sheet);
      }
      fontsToLoad = removeCSS.call(this, fragment);
      this.loadExternalCSS(fragment);
      this.initializeCounter();
    }
    //var prevWidth;
    layout.insert({
      editor: this.editor,
      editorVersion: this.controller.manager.editorVersion,
      what: 'note',
      config: this.config,
      id: this.config.campaignId,
      content: fragment,
      onload: function (wrapNode, docum) {
        this.oninserted(wrapNode, docum, fontsToLoad, oninserted, options.name);
      }.bind(this),
      useDocumentWrite: !U.empty(this.modules)
    });
  }
  Note.prototype = {
    onWindowResize: function (first) {
      if (B.is.desktop || first)
        return;
      this.reposition(true);  //this.calculateDimensions();
    },
    setDOMNodeStyles: function (style) {
      if (noIFrames) {
        if ('width' in style && !this.config.relativeWidth)
          style.width = 'auto';
        if ('height' in style)
          style.height = 'auto';
      }
      layout.css(this.config, 'DOMNode', style);
      if (noIFrames)
        return;
      if (this.config.profile == CONST.PROFILE.DESKTOP || !this.production)
        return;
      // 			if (B.is.ie) return; // actually we should not set widths for desktop at all, but they work, so let them be
      // 			if (behaviour.isSleekBar(this.config) && this.config.profile == CONST.PROFILE.DESKTOP) return;
      if ('width' in style && this.config.boxNode) {
        var width = win.getComputedStyle(this.config.DOMNode).width;
        this.config.boxNode.style.width = this.config.boxNode.ownerDocument.documentElement.style.width = width;
      }
    },
    getNodes: function (docum) {
      this.config.boxNode = qs(docum, this.config.id);
      this.config.formNode = qs(this.config.boxNode, 'form') || this.config.boxNode;
    },
    oninserted: function (wrapNode, docum, fontsToLoad, oninserted, name) {
      this.config.DOMNode = wrapNode;
      this.getNodes(noIFrames ? this.config.DOMNode : docum);
      oninserted(name, this);
      if (!this.config.boxNode)
        return;
      var frameDoc = this.config.boxNode.ownerDocument;
      this.applyConfig();
      //console.log('inserted', this.config.name);
      //fixIOS(docum);
      fixEdge(docum);
      var htmlNode = noIFrames ? wrapNode : docum.documentElement;
      htmlNode.classList.add(this.controller.profileStr);
      if (this.controller.isTouch)
        htmlNode.classList.add('touch');
      //var maxHeight = 100 * layout.viewportUnitRatio() + 'vh';
      body(docum).setAttribute('data-campaign', this.config.campaignId);
      if (U.contains(this.config.profile, CONST.PROFILE.MOBILE, CONST.PROFILE.TABLET)) {
        addClickAttribute.call(this, body(docum), 'outsideClick');
      }
      if (this.editor) {
        this.findModules(docum, true);
        // 				if (!noIFrames) {
        // 					//head(docum).insertAdjacentHTML('beforeend', this.controller.manager.stylesheets[this.config.version].sheet);
        // 				}
        //fixBaseTag.call(this, docum);
        addEventListeners.call(this, docum);
        addResizeListeners.call(this, docum);
        fixDOM.call(this, docum);  //maxHeight = noIFrames ? '100%' : 'calc(' + maxHeight + ' + ' + this.spaceAmount() + 'px)';
      } else {
        allowBackgroundClicks.call(this, docum);
        if (this.production && this.config.version < 4)
          support.prepare(this);
        this.removeListener = click.listen(this.doc, this.onClick.bind(this));
        this.config.formNode.onsubmit = function () {
          return false;
        };
      }
      this.setDOMNodeStyles({ maxHeight: behaviour.DOMNodeScrolling(this.config, this.editor, this.controller.manager.editorVersion) });
      var imagesLoaded = false;
      var fontsLoaded = false;
      var ready = function () {
        //console.log(myname, 'ready');
        win.setTimeout(function () {
          this.ready = true;
          this.message({
            type: 'ready',
            id: this.controller.id,
            part: this.config.name
          });
        }.bind(this), 1000);
      }.bind(this);
      //var myname = this.config.name;
      fontLoader.loadAllFontStyleSheets(frameDoc, fontsToLoad, function (hrefs) {
        fontLoader.loadFonts(frameDoc, fontsToLoad).then(function () {
          fontsLoaded = true;
          //console.log(myname, 'fonts loaded');
          if (imagesLoaded)
            ready();
        }, function error() {
          console.log(arguments);  //debugger;
        });  //console.log(myname, 'stylesheets loaded');
      });
      this.controller.manager.loadNoteImages(this.config, this.loadExternalJS.bind(this, function () {
        imagesLoaded = true;
        if (fontsLoaded)
          ready();
      }));
    },
    rerender: function (binder) {
      binder(this.config.DOMNode);
      this.getNodes(this.config.DOMNode);
    },
    findModules: function (docum, first) {
      if (this.editor)
        return;
      docum || (docum = this.doc);
      // 			if (first) {
      // 				if (!this.modules.CSS) {
      // 					this.modules.CSS = {
      // 						type: 'css',
      // 						name: SleekNote.cssName ? SleekNote.cssName : 'sleeknote' + (this.config.version > 2 ? this.config.version : ''),
      // 					};
      // 					if (this.editor) {
      // 						this.modules.ECSS = {
      // 							type: 'css',
      // 							name: 'sleeknote-editor',
      // 						};
      // 					}
      // 				}
      // 			}
      if (/*!SleekNote.local &&*/
        (qs(docum, '.snclerk') || qs(docum, '.prod-rec')) && !this.modules.productrec) {
        this.modules.productrec = {
          // we need both js and css
          type: 'both',
          name: 'productrec'
        };
      }
    },
    onafterrender: function () {
      this.loadExternal(function () {
        this.afterrender.forEach(function (func) {
          func.call(this);
        }, this);
      });
    },
    callExternal: function (moduleName) {
      //var args = Array.prototype.slice.call(arguments, 1);
      this.loadExternal(function () {
        this.afterrender.forEach(function (func) {
          func.call(this);
        }, this);
      }.bind(this));
    },
    loadExternal: function (next, docum) {
      this.findModules(docum);
      this.loadExternalCSS(docum);
      this.loadExternalJS(next, docum);
    },
    loadExternalJS: function (next, docum) {
      docum || (docum = this.doc);
      docum = getDoc(docum);
      var waiting = 0;
      if (next)
        next = next.bind(this);
      if (this.editor && noIFrames) {
        // in editor we now have all externals loaded on notemanager init
        var externals = this.controller.manager.launchExternals;
        if (externals) {
          if (externals(this, // 							{
            // 								U: U,
            // 								LOC: locale,
            // 								SleekNote: SleekNote,
            // 								layout: layout,
            // 							},
            next))
            return;
        }
        next();
      }
      function bootStrap(key, next) {
        var module = this.modules[key];
        this.afterrender.push(docum.defaultView['load_' + module.name](this, {
          U: U,
          LOC: locale,
          SleekNote: SleekNote,
          layout: layout
        }, function () {
          waiting -= 1;
          if (!waiting && next)
            setTimeout(next, 0);
        }));
      }
      Object.keys(this.modules).forEach(function (key) {
        var module = this.modules[key];
        var id = module.name + '-js';
        if (U.contains(module.type, 'js', 'both') && !qs(docum, '#' + id)) {
          waiting += 1;
          var href;
          if (SleekNote.branch) {
            href = SleekNote.path + module.name + '-' + SleekNote.branch + '.js';
          } else {
            href = this.config.base + module.name + SleekNote.appendToFile + '.js';
          }
          U.loadScript(href + SleekNote.timestamp, bootStrap.bind(this, key, next), id, docum);
        }
      }, this);
      if (!waiting && next)
        next();
    },
    loadExternalCSS: function (docum) {
      if (this.editor && noIFrames)
        return;
      docum || (docum = this.doc);
      docum = getDoc(docum);
      var head = qs(docum, 'head');
      Object.keys(this.modules).forEach(function (key) {
        var module = this.modules[key];
        if (U.contains(module.type, 'css', 'both') && !qs(docum, '[data-css="' + module.name + '"]')) {
          var href;
          if (SleekNote.branch) {
            href = SleekNote.path + module.name + '-' + SleekNote.branch + '.css';
          } else {
            href = this.config.base + module.name + SleekNote.appendToFile + '.css';
          }
          head.insertAdjacentHTML('beforeend', '<link data-css="' + module.name + '" rel=stylesheet type=text/css href="' + href + SleekNote.timestamp + '"></link>');
        }
      }, this);
    },
    insertOrReplaceHiddenInputs: function (docum, data) {
      var prop;
      for (prop in data)
        if (data.hasOwnProperty(prop)) {
          var node = qsa(body(docum), '[name="' + prop + '"]')[0];
          if (node) {
            node.value = data[prop];
          } else {
            this.config.formNode.insertAdjacentHTML('beforeend', '<input type="hidden" name="' + prop + '", value="' + data[prop] + '">');
          }
        }
    },
    setToggleIf: function (docum) {
      if (behaviour.isSleekBar(this.config)) {
        var node = this.toggleDOMNode(this.config.boxNode || docum);
        if (node) {
          var order = U.contains(this.config.position, CONST.POS.HELLO2) ? 0 : 2;
          CSS.set(node, 'order', order);
        }
      }
    },
    applyConfig: function (config, callback) {
      if (config) {
        // only allow selected properties to change
        [
          'distanceFromEdge',
          'attach',
          'options',
          'placement',
          'position',
          'relativeWidth',
          'toggle'
        ].forEach(function (prop) {
          if (prop in config) {
            if (prop == 'toggle') {
              this.config[prop] = config[prop] ? '[data-type="toggle"]' : false;
            } else {
              this.config[prop] = config[prop];
            }
          }
        }, this);
      }
      this.setToggleIf();
      this.reposition(true);
      this.config.reveal = this.config.toggle ? 'half' : 'open';
    },
    toggleDOMNode: function (docum) {
      docum || (docum = this.doc);
      return this.config.toggle && qs(docum, this.config.toggle);
    },
    get isMobileForm() {
      return this.config.type == 'form' && this.config.profile == CONST.PROFILE.MOBILE;
    },
    get isHello() {
      return U.contains(this.config.position, CONST.POS.HELLO, CONST.POS.HELLO2);
    },
    get visible() {
      return !this.hidden && this.config.next;
    },
    get hidden() {
      return this.config.next == 'close';
    },
    get doc() {
      // without iFrames, 'doc' should be DOMNode, because we expect Note to be unique inside 'doc'
      return noIFrames ? this.config.DOMNode : this.config.boxNode.ownerDocument;
    },
    get win() {
      return (noIFrames ? this.config.DOMNode.ownerDocument : this.doc).defaultView;
    },
    get editor() {
      return this.controller.config.purpose == 'editor';
    },
    get preview() {
      return this.controller.config.purpose == 'preview';
    },
    get production() {
      return !this.preview && !this.editor;
    },
    isPrevented: function () {
      var counter = this.config.counter;
      if (!counter)
        return false;
      var now = new Date();
      return now > counter.date;
    },
    initializeCounter: function () {
      var cfg = this.config;
      if (!this.editor) {
        // do we have countdown elements?
        var counter = qsa(this.config.boxNode, '[data-sn-type="counter"]')[0];
        if (counter) {
          cfg.counter = {
            node: counter,
            text: []
          };
          var c = cfg.counter;
          [
            'type',
            'date',
            'message',
            'seconds',
            'moment-unix',
            'zero-logic'
          ].forEach(function (attr) {
            c[attr] = counter.firstElementChild.getAttribute('data-sn-custom-' + attr);
          });
          // 01/31/2019 00:00
          var ptime = c.date.replace(/[\/: ]/g, '-').split('-').map(function (x) {
            return parseInt(x, 10);
          });
          var now = new Date();
          if (c.type == 'daily') {
            ptime[2] = now.getFullYear();
            ptime[0] = now.getMonth() + 1;
            ptime[1] = now.getDate();
          }
          // to be removed
          var date;
          //old way that will hopefully die soon
          // copenhagen -60
          // tallinn -120
          var date = new Date(ptime[2], ptime[0] - 1, ptime[1], ptime[3], ptime[4]);
          var offset = new Date().getTimezoneOffset();
          date.setTime(date.getTime() + (cfg.timeZoneOffset - offset) * 60000);
          c.date = date;
          //
          c.arr = ptime;
          c.replacer = locale.createDateReplacer(c.node);
          this.updateCounter();
        }
      }
    },
    updateCounter: function () {
      var c = this.config.counter;
      if (!c)
        return;
      win.clearTimeout(this.countdownTimer);
      var now = new Date();
      var targetDate = c['moment-unix'] || c.date;
      // get total seconds between the times
      var delta = Math.abs(targetDate - now) / 1000;
      // calculate (and subtract) whole days
      var days = Math.floor(delta / 86400);
      delta -= days * 86400;
      // calculate (and subtract) whole hours
      var hours = Math.floor(delta / 3600) % 24;
      delta -= hours * 3600;
      // calculate (and subtract) whole minutes
      var minutes = Math.floor(delta / 60) % 60;
      delta -= minutes * 60;
      // what's left is seconds
      var seconds = Math.floor(delta % 60);
      // in theory the modulus is not required
      if (now < targetDate) {
        c.replacer([
          0,
          0,
          days,
          hours,
          minutes,
          seconds
        ]);
        this.countdownTimer = win.setTimeout(this.updateCounter, 1000);
      } else {
        if (c.message) {
          locale.replaceDateWithText(c.node, c.message);
        } else {
          c.replacer([
            0,
            0,
            0,
            0,
            0,
            0
          ]);  //this.controller.manager.command('close', this.controller.config.campaignId);
        }  // we are done
      }
    },
    afterAnimation: function () {
      this.createSpaceAround();
      if (this.hidden) {
        CSS.conceal(this.config.DOMNode);
      } else if (!this.editor) {
        this.updateCounter();
      }
    },
    /*
    				bounds.shadow - how much shadow we have on each side
    				bounds.other - how much portruding elements (stickers, close buttons) are outside of the main box
    				edge - how much we need to have space to the edges of the viewport
    
    				iframe padding therefore is Math.max(edge, other, shadow);
    
    				shadow will have free flow only from open sides, e.g. from these where edge is -1, on other sides we can cut it off to the edge
    				e.g shadow = Math.min(shadow, edge)
    
    				in case where Math.max(shadow, other) < edge && edge != -1 we can move iframe with translate: move = edge - Math.max(shadow, other)
    				and then padding can be deducted: padding = padding - move
    
    				for relativeWidth we need:
    				- calculate padding and edge's first, for that we need to get bounds, just for shadow
    				- then we need to set all paddings, calculate and apply correct width
    				- only then we can calculate correct height e.g. we need to run bounds calculation again
    
    				normally, with fixed width box, the width (and height) of the wrapping iframe is then:
    				bounds.width + (padding.left + padding.right)
    
    				in editor we set "editor padding" this is for dragging to work as with fast mouse movement we may end up otside of the iframe
    				and lose mousemove events. The amount of padding does not affect to positioning. Editor padding affects certain animations, therefore
    				we need to remove it before and apply again after animations.
    
    			*/
    getRawBoxBounds: function (justBox) {
      /*
      		bounds.shadow - how much shadow we have on each side
      		bounds.other - how much portruding elements (stickers, close buttons) are outside of the main box
      		bounds.width & height are elemWithDimensions width & height
      	*/
      var box = this.config.boxNode;
      var elemWithDimensions = this.config.formNode;
      // new
      // we need to know existing padding, as U.bounds() will get the results wrong if there is padding,
      // but we need it to be there when calculating relativeWidth
      //			var padding = {}
      //			sides.forEach(function(side) {
      //				padding[side] = parseInt(box.style.getPropertyValue['padding-'+side], 10)||0;
      //			});
      if (box.querySelector('.chat'))
        elemWithDimensions = elemWithDimensions.querySelector('ul');
      if (!elemWithDimensions) {
        elemWithDimensions = box;  // old
      }
      // this gives as main element dimensions with all the shadows portruding
      var nodeBounds = U.bounds(elemWithDimensions, '[style*="box-shadow"]').elem;
      // here top,left of elemWithDimensions is always 0,0
      var bounds = U.newDict({
        width: evenValue(nodeBounds.width),
        height: evenValue(nodeBounds.height)
      });
      if (!justBox) {
        // shadow and other only can change in editor, never in core
        bounds.shadow = U.newDict(nodeBounds, sides);
        var otherBox = elemWithDimensions.parentNode || elemWithDimensions;
        var padding = otherBox.style.padding;
        otherBox.style.padding = '';
        var otherBounds = U.bounds(otherBox, '.image-container, [data-sn-type="sticker"], .sleeknoteMobileClose, .SNCloseButton, [data-sn-type="close"]');
        // here we need to deduct the padding we apply, otherwise it multiplies on second calls
        bounds.other = U.newDict({
          top: otherBounds.elem.top,
          left: otherBounds.elem.left,
          bottom: otherBounds.elem.bottom,
          right: otherBounds.elem.right
        });
        otherBox.style.padding = padding;
      }
      return bounds;
    },
    getZeroBounds: function () {
      var zeroBounds = {
        x: 0,
        y: 0,
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        width: +this.config.width1 || 0,
        height: +this.config.height1 || 0
      };
      zeroBounds.shadow = U.newDict(zeroBounds);
      zeroBounds.other = U.newDict(zeroBounds);
      return U.newDict(zeroBounds);
    },
    getBoxBounds: function (justBox) {
      var bounds;
      if (!this.config.DOMNode || this.config.version == 1) {
        bounds = this.getZeroBounds();
      } else {
        bounds = CSS.flashRevealIf(this.config.DOMNode, function () {
          return this.getRawBoxBounds(justBox);
        }.bind(this));
      }
      return U.extend(this.config.bounds || {}, bounds);
    },
    preventResizeEvent: function () {
      return;
      if (this.editor) {
        var b = this.config.boxNode.getBoundingClientRect();
        this.prevDims.width = b.width;
        this.prevDims.height = b.height;
      }
    },
    calculateDimensionsNoIframes: function () {
      //var docum = this.config.boxNode.ownerDocument;
      // 			console.log(
      // 				'calculateDimensions',
      // 				this.config.name,
      // 				this.config.campaignId.substr(0, 4),
      // 				docum.body.children[0].style.width,
      // 				docum.documentElement.style.width
      // 			);
      var move = {
        x: 0,
        y: 0
      };
      if (SleekNote.CustomInitSettings.moveBox) {
        move = SleekNote.CustomInitSettings.moveBox(this.config, move);
      }
      var edge = behaviour.distanceFromEdges(this, true);
      var scale = layout.getFrameScale();
      sides.forEach(function (side) {
        if (edge[side] > 0) {
          move[U.contains(side, 'left', 'right') ? 'x' : 'y'] += evenValue(edge[side]);
        }
      }, this);
      var adjustment = 0;
      var width = 'auto';
      if (this.config.version > 1) {
        if (this.config.relativeWidth) {
          adjustment = -(~edge.right ? edge.right : 0) + (~edge.left ? edge.left : 0);
          var transWidth = behaviour.translateRelative(this.config);
          adjustment += behaviour.DOMNodeScrolling(this.config, this.editor, this.controller.manager.editorVersion).widthAdjustment;
          width = [
            transWidth.width / scale + transWidth.unit,
            ' + ' + adjustment + 'px'
          ];
        }
      } else {
      }
      this.dims = {
        width: width,
        height: 'auto',
        move: move
      };
      return this.dims;
    },
    calculateDimensions: function () {
      if (noIFrames)
        return this.calculateDimensionsNoIframes();
      //var docum = this.config.boxNode.ownerDocument;
      this.removeSpaceAround();
      var bounds = this.getBoxBounds();
      //console.log('calculateDimensions', this.config.name, this.config.campaignId.substr(0, 4), bounds.width);
      var edge = behaviour.distanceFromEdges(this, true);
      var scale = layout.getFrameScale();
      //var boundsHeight = bounds.height - Math.max(bounds.other.top, bounds.shadow.top) - Math.max(bounds.other.bottom, bounds.shadow.bottom);
      //console.log('calculateDimensions', this.config.name, this.config.campaignId.substr(0, 4), bounds);
      var move = {
        x: 0,
        y: 0
      };
      /* hook example, that adds 40px vertically on mobile forms and success
      	SleekNote.CustomInitSettings = {
      		moveBox: function(config, move) {
      			if ( config.campaignId == '...guid goes here...' ) {
      				move.y += 40;
      			}
      			return move;
      		}
      	}
      	*/
      if (SleekNote.CustomInitSettings.moveBox) {
        move = SleekNote.CustomInitSettings.moveBox(this.config, move);
      }
      var padding = {};
      var shadow = bounds.shadow;
      var other = bounds.other;
      sides.forEach(function (side) {
        var p = Math.max(other[side], shadow[side]);
        if (~edge[side]) {
          if (!edge[side]) {
            p = 0;
          } else {
            if (shadow[side] > edge[side]) {
              p = Math.max(other[side], edge[side]);
            } else {
              if (p < edge[side]) {
                move[U.contains(side, 'left', 'right') ? 'x' : 'y'] += evenValue(edge[side] - p);
              }
            }
          }
        }
        padding[side] = evenValue(p  /* * scale*/);
      }, this);
      // apply padding
      if (!U.contains(this.config.name, 'badge', 'cover')) {
        if (this.config.version > 1) {
          CSS.set(this.config.boxNode, paddingCSS(padding));
        } else {
          CSS.set(this.config.boxNode, {
            marginTop: ~edge.top ? edge.top : 0,
            marginRight: ~edge.right ? edge.right : 0,
            marginBottom: ~edge.bottom ? edge.bottom : 0,
            marginLeft: ~edge.left ? edge.left : 0
          });
        }
      }
      var adjustment = 0;
      var width = 0;
      if (this.config.version > 1) {
        if (this.config.relativeWidth) {
          adjustment = (~edge.right ? edge.right : 0) + (~edge.left ? edge.left : 0);
          var transWidth = behaviour.translateRelative(this.config);
          width = [
            transWidth.width / scale + transWidth.unit,
            ' - ' + adjustment + 'px'
          ];
          if (this.editor) {
          }
        } else {
          width = evenValue(bounds.width + (padding.left + padding.right));
        }
      } else {
        var right = ~edge.right ? edge.right : 0;
        var left = ~edge.left ? edge.left : 0;
        width = evenValue(bounds.width + (right + left > 10 ? right + left - 10 : 0));
      }
      this.setDOMNodeStyles({ width: width });
      //this.config.boxNode.style.width = this.config.boxNode.ownerDocument.documentElement.style.width = win.getComputedStyle(this.config.DOMNode).width;
      // now we can calculate correct height if we have relative width - box height depends of it
      var height = 0;
      var adjustment = this.config.version > 1 ? padding.top + padding.bottom : 0;
      var boundsHeight = this.config.formNode.getBoundingClientRect().height;
      if (this.config.relativeWidth) {
        bounds.height = boundsHeight;
      }
      height = bounds.height + adjustment;
      if (behaviour.isPopup(this.config)) {
        height = evenValue(height);
      }
      boundsHeight = boundsHeight * scale;
      this.setDOMNodeStyles({ height: height });
      move.x *= scale;
      move.y *= scale;
      this.dims = {
        scale: scale,
        padding: padding,
        move: move,
        width: this.config.width = width,
        height: this.config.height = height,
        bounds: bounds
      };
      this.config.boundsHeight = boundsHeight;
      this.preventResizeEvent();
      return this.dims;
    },
    dimensions: function () {
      return this.dims || {};
    },
    needSpaceAround: function (create) {
      if (noIFrames)
        return;
      // on mobile forms, I think, cover is always up now anyway
      var coverIsUp = create ? this.controller.manager.command('hasCover') : true;
      return this.editor || coverIsUp && this.isMobileForm;
    },
    /*
    			this space around concept is to add transparent space around box.
    			- main use is in editor, where it is needed to allow rapid resizing of the box as resize is rather slow operation to render
    			and if user moves mouse quickly, then the mouse pointer will be outside of the iframe, slow to respond, and as we listen to mouse
    			events inside iframe, then we miss a lot of eventsand resizing becomes extremely junky. Therefore I add padding/space around the box
    			that visually is not noticeable (same position), but it will increase iframe size enough, to capture all mouse events
    			- secodary use is on mobile forms where we allow scrolling and have overscrolling, so that when user scrolls all the way to bottom, we
    			will have additional 200px of space
    
    		*/
    spaceAmount: function () {
      return this.config.profile == CONST.PROFILE.MOBILE ? 200 : 500;
    },
    createSpaceAround: function () {
      if (!this.needSpaceAround(true))
        return;
      var padding = U.extend(this.dims.padding);
      var edge = behaviour.distanceFromEdges(this, true);
      var spaceAmount = this.spaceAmount();
      sides.forEach(function (side) {
        if (edge[side] < 0) {
          //padding[side] = evenValue(Math.max(spaceAmount, this.dims.padding[side]));
          if (spaceAmount > this.dims.padding[side]) {
            padding[side] = spaceAmount + this.dims.padding[side];
          }
        }
      }, this);
      var heightDiff = -this.dims.padding.top - this.dims.padding.bottom + padding.top + padding.bottom;
      var widthtDiff = -this.dims.padding.left - this.dims.padding.right + padding.right + padding.left;
      var width = U.extend([], this.config.width);
      if (Array.isArray(this.config.width)) {
        width.push(widthtDiff + 'px');
      } else {
        width += widthtDiff;
      }
      var height = this.config.height;
      if (Array.isArray(this.config.height)) {
        height.push(heightDiff + 'px');
      } else {
        height += heightDiff;
      }
      CSS.set(this.config.boxNode, paddingCSS(padding));
      //if (this.config.name == 'teaser') console.log('createSpaceAround', width);
      this.setDOMNodeStyles({
        width: width,
        height: height
      });
      this.preventResizeEvent();
    },
    removeSpaceAround: function () {
      if (!this.needSpaceAround() || !this.dims)
        return;
      //if (this.config.name == 'teaser') console.log('removeSpaceAround', this.config.width);
      CSS.set(this.config.boxNode, paddingCSS(this.dims.padding));
      this.setDOMNodeStyles({
        width: this.config.width,
        height: this.config.height
      });
      this.preventResizeEvent();
    },
    toggleToggleButton: function (pos) {
      var button = qs(this.doc, '[data-sn-custom-step="toggleForm"]');
      if (!button)
        return;
      button.classList.remove('toggle-arrow-up');
      button.classList.remove('toggle-arrow-down');
      var className;
      if (this.config.position == CONST.POS.HELLO) {
        className = pos == 'open' ? 'toggle-arrow-up' : 'toggle-arrow-down';
      } else {
        className = pos == 'open' ? 'toggle-arrow-down' : 'toggle-arrow-up';
      }
      button.classList.add(className);
    },
    reposition: function (full) {
      if (!this.ready)
        return;
      full && setLayout.call(this);
      this.calculateDimensions();
      this.setDOMNodeStyles(layout.createPositionStyles(behaviour.boxParameters(this, this.config.current), 'to'));
      this.createSpaceAround();
    },
    prepare: function (action, companion) {
      // 			if (this.config.name == 'teaser') {
      // 				console.log('prepare', action);
      // 				//if (action == 'open') debugger;
      // 			}
      var to;
      var from = this.config.current;
      switch (action) {
      case 'current':
        to = this.config.current;
        from = 'close';
        break;
      case 'maximize':
        to = 'open';
        break;
      case 'open':
      case 'reveal':
        // reveal is last open state, either maximized (open)  at this time
        this.onBeforeOpen();
        to = 'reveal';
        break;
      case 'minimize':
        to = 'half';
        break;
      default:
        to = 'close';
      }
      if (to == 'reveal') {
        // this is the case we want to show, but do not know what
        to = this.config.reveal || (behaviour.isSleekBar(this.config) ? 'half' : 'open');
      }
      if (to == from)
        return;
      // TODO
      if (to == 'half' || from == 'half') {
        if (!this.toggleDOMNode()) {
          if (to == 'half')
            to = 'open';
          if (from == 'half')
            from = 'close';  // that should never happen btw
        }
      }
      // PP: animations can not be interrupted, in principle current could be set to 'to' here ...
      this.config.next = to;
      // next time to show, we can use that
      if (to !== 'close')
        this.config.reveal = to;
      this.animating = true;
      this.toggleToggleButton(to);
      this.calculateDimensions();
      var param = behaviour.animationParameters(this, from, to, companion);
      return layout.createMotion(param, function (styles, first, last) {
        if (last) {
          this.config.current = this.config.next;
          setTabIndex.call(this, this.doc);
        }
        styles.visibility = 1;
        layout.css(this.config, 'DOMNode', styles);
      }.bind(this));
    },
    adjustForZoom: function () {
      var topDocum = win.top.document;
      try {
        this.config.boxNode.ownerDocument.documentElement.style.zoom = win.getComputedStyle(topDocum.head).zoom * win.getComputedStyle(topDocum.body).zoom;
      } catch (e) {
      }
    },
    getCloseFunc: function () {
      var func = 'hideBox';
      if (this.preview) {
        func = 'previewDummy';
        if (this.config.type == 'teaser')
          func = 'openSleeknote';
        if (this.config.type == 'form' && this.config.teaser)
          func = 'openTeaser';
        if (this.config.type == 'success') {
          var box = this.controller.getType('teaser')[0];
          if (box) {
            this.config.teaser = box.config.name;
            func = 'openTeaser';
          } else {
            this.config.form = this.controller.getType('form')[0].config.name;
            func = 'openSleeknote';
          }
        }
      } else {
        if (this.config.type == 'teaser')
          func = 'hideTeaserAndDontShowAgain';
        if (this.config.type == 'form' && this.config.teaser)
          func = 'openTeaser';
      }
      return func;
    },
    getJITData: function (str) {
      var val = str;
      var prop;
      var tokens;
      var parser;
      // 			str =
      // 				'=TOKENS=W3sidG9rZW4iOjIwLCJ5eXRleHQiOiI9VEVYVCJ9LHsidG9rZW4iOjEyLCJ5eXRleHQiOiIoIn0seyJ0b2tlbiI6MjAsInl5dGV4dCI6Ij1OT1cifSx7InRva2VuIjoxMiwieXl0ZXh0IjoiKCJ9LHsidG9rZW4iOjEzLCJ5eXRleHQiOiIpIn0seyJ0b2tlbiI6MjMsInl5dGV4dCI6IjsifSx7InRva2VuIjo4LCJ5eXRleHQiOiJcIkRELk1NLllZWVkgaGg6bW06c3NcIiJ9LHsidG9rZW4iOjEzLCJ5eXRleHQiOiIpIn0seyJ0b2tlbiI6NSwieXl0ZXh0IjoiIn1d';
      //
      if ((str + '').substr(0, 8) == '=TOKENS=') {
        try {
          tokens = win.JSON.parse(win.atob(str.substr(8)));
          parser = new excelParser(tokens, this);
          val = parser.parse();
          return val ? val : '';  // force empty string when falsy
        } catch (e) {
          if (parser) {
            return '';
          }
        }
      }
      // parse function 	=GTMDL(gender)
      str = str + '';
      try {
        var tokens = str.trim().match('^{{(.+)}}$');
        if (tokens) {
          prop = tokens[1].split(':');
          switch (prop[0].toLowerCase()) {
          case 'sitedata':
            this.siteData || (this.siteData = new SiteData());
            val = U.findPropValue(this.siteData.getSession(), prop[1]);
            break;
          default:
            val = str;
            break;
          }
        } else if (str.charAt(0) == '=') {
          var func = str.split('(')[0] + '';
          if (func.toLowerCase() == '=gtmdl') {
            try {
              prop = (str.split('(')[1] + '').replace(')', '');
              val = U.findPropValue(win.dataLayer, prop);
            } catch (e) {
            }
            if (!val)
              val = '';  // force empty string when falsy
          } else {
            val = '';
          }
        }
      } catch (e) {
      }
      if (!val)
        val = '';
      // force empty string when falsy
      return val;
    },
    message: function (data) {
      if (data.type == 'resize' && !this.visible)
        return;
      data.stepName = this.config.name;
      switch (data.type) {
      case 'aftersubmit':
        // here i change (add some more) the event data, this only works if forward to up is at the end of the handler
        data = this.onAfterSubmit(data);
        break;
      case 'redirect':
        if (data.target == '_blank' && this.config.profile == CONST.PROFILE.DESKTOP) {
          win.top.open(data.href);
        } else {
          win.top.location.href = data.href;
        }
        break;
      }
      // because of submit event this needs to be in the end
      data.origin = this;
      win.setTimeout(function (data) {
        this.controller.message(data);
      }.bind(this, data), 0);
    },
    setVisibility: function (visibility) {
      if (this.config.DOMNode) {
        this.config.isHidden = !visibility;
        this.setDOMNodeStyles({ visibility: visibility });
      }
    },
    isHidden: function () {
      if (!this.config.DOMNode)
        return;
      return this.config.isHidden;
    },
    onClick: function (event, target) {
      //ignore clicks on inputs and links
      if (event.target && U.contains(event.target.tagName, 'A', 'INPUT', 'SELECT', 'TEXTAREA') && !event.target.getAttribute('data-click'))
        return;
      if (this.editor) {
        event.preventDefault && event.preventDefault();  //if (!this.controller.manager.emulate) return;
      }
      // prevent clicks while animating as this may mess things up a little - f.e. when clicking on a teaser while trigger is launced
      if (this.controller.manager.showQueue.busy)
        return;
      var clickTarget;
      var clickFunc;
      if (target) {
        clickTarget = target;
        if (~this.mobileButtons.indexOf(clickTarget)) {
          return this.mobileButtonAction(event, clickTarget);
        }
      } else {
        clickTarget = U.querySelectorClosest(event.target, '[data-click]');
      }
      if (clickTarget) {
        clickFunc = clickTarget.getAttribute('data-click');
        if (clickFunc && ~this.methodList.indexOf(clickFunc) && clickFunc in this) {
          if (event.target)
            event.preventDefault();
          this[clickFunc](event, clickTarget);
        }
      }
    },
    destroy: function (complete) {
      if (!this.config.DOMNode)
        return;
      this.methodList.forEach(function (method) {
        if (this.win && method in this.win) {
          delete this.win[method];
        }
      }, this);
      //U.listener(this.win, 'remove', this.onLoad)('load');
      this.removeListener && this.removeListener();
      if (complete) {
        var node = this.config.DOMNode;
        U.removeNode(node);
      } else {
        // just detach DOMNode, but leave it there
        delete this.config.DOMNode;
      }
    },
    mobileButtonAction: function (event, node, passMobileDetect) {
      if (U.matchesSel(node, '[data-sn-type="close"], .sleeknoteMobileClose')) {
        this[this.getCloseFunc()](event, node, true);
      } else {
        this.redirectBox(event, node, passMobileDetect);
      }
    },
    detectMobileButtonClick: function (event, clickTarget) {
      // find out if we approximately clicked on some mobile close buttons
      var l = this.mobileButtons.length;
      var point = U.eventXY(event);
      if (noIFrames) {
        point.x = event.clientX;
        point.y = event.clientY;
      }
      // size of virtual touch area
      var width = 70;
      var height = 70;
      var min = 30;
      // minimum over;
      while (l--) {
        var node = this.mobileButtons[l];
        var bb = node.getBoundingClientRect();
        var bwd = Math.max(width - bb.right + bb.left, 2 * min) / 2;
        var bhd = Math.max(height - bb.bottom + bb.top, 0) / 2;
        var area = {
          left: bb.left - bwd,
          right: bb.right + bwd,
          top: bb.top - bhd,
          bottom: bb.bottom + bhd
        };
        if (point.x > area.left && point.x < area.right && point.y > area.top && point.y < area.bottom) {
          this.mobileButtonAction(event, node, true);
          return true;
        }
      }
    },
    outsideClick: function (event, clickTarget) {
      if (this.detectMobileButtonClick(event, clickTarget))
        return;
      var fa = this.config.formNode.getBoundingClientRect();
      if (!(event.clientX >= fa.left && event.clientX <= fa.right && event.clientY >= fa.top && event.clientY <= fa.bottom)) {
        if (!this.controller.manager.command('hasCover'))
          return;
        var closeButton = this.doc.querySelectorAll('[data-sn-type=close], .sleeknoteMobileClose')[0];
        if (closeButton)
          this.onClick(event, closeButton);
      }
    },
    // 		outsideClick: function (event, clickTarget) {
    // 			// find out if we approximately clicked on some mobile close buttons
    // 			var l = this.mobileButtons.length;
    // 			var point = U.eventXY(event);
    // 			// size of virtual touch area
    // 			var width = 70;
    // 			var height = 70;
    // 			var min = 30; // minimum over;
    // 			while (l--) {
    // 				var node = this.mobileButtons[l];
    // 				var bb = node.getBoundingClientRect();
    // 				var bwd = Math.max(width - bb.right + bb.left, 2 * min) / 2;
    // 				var bhd = Math.max(height - bb.bottom + bb.top, 0) / 2;
    // 				var area = {
    // 					left: bb.left - bwd,
    // 					right: bb.right + bwd,
    // 					top: bb.top - bhd,
    // 					bottom: bb.bottom + bhd,
    // 				};
    // 				if (point.x > area.left && point.x < area.right && point.y > area.top && point.y < area.bottom) {
    // 					this.mobileButtonAction(event, node);
    // 					// 					if (U.matchesSel(node, '[data-sn-type="close"], .sleeknoteMobileClose')) {
    // 					// 						this[this.getCloseFunc()](event, node);
    // 					// 					} else {
    // 					// 						this.redirectBox(event, node);
    // 					// 					}
    //
    // 					return;
    // 				}
    // 			}
    // 			var fa = this.config.formNode.getBoundingClientRect();
    // 			if (!(event.clientX >= fa.left && event.clientX <= fa.right && event.clientY >= fa.top && event.clientY <= fa.bottom)) {
    // 				if (!this.controller.manager.command('hasCover')) return;
    // 				var closeButton = this.doc.querySelectorAll('[data-sn-type=close], .sleeknoteMobileClose')[0];
    // 				if (closeButton) this.onClick(event, closeButton);
    // 			}
    // 		},
    onBeforeOpen: function () {
      // prefillers and custom functions support
      qsa(this.config.formNode, 'input,textarea,select').forEach(function (input) {
        switch (input.tagName) {
        case 'INPUT':
        case 'TEXTAREA':
          input.value = this.getJITData(input.value, input.type == 'hidden');
          break;
        case 'SELECT':
          break;
        }
      }, this);
    },
    onAfterSubmit: function (data) {
      // we must return data, this handler is passthrough
      if (!this.config.DOMNode)
        return;
      var customTrackerEvent;
      var closeSession = true;
      var setShown = true;
      var setSubscription;
      var setEngaged;
      var callback;
      var cconfig = this.controller.config;
      switch (cconfig.type) {
      case 'social':
        customTrackerEvent = 'social';
        break;
      case 'newsletter':
        customTrackerEvent = 'newsletter';
        setSubscription = true;
        setEngaged = true;
        break;
      case 'contact':
        customTrackerEvent = 'contact';
        setSubscription = true;
        setEngaged = true;
        break;
      case 'blank':
      case 'promote':
      case 'guide':
        customTrackerEvent = 'blank';
        closeSession = false;
        setEngaged = true;
        break;
      }
      // win.open is now fired at cta button handler
      if (data.href && data.target != '_blank') {
        callback = function () {
          win.top.location.href = data.href;
        };
      }
      if (data.isUserDefinedClick === undefined || data.isUserDefinedClick && U.contains(cconfig.type, 'promote', 'guide') && data.isForm) {
        // dummy is true when CTA pressed inside succes box
        //if (cconfig.successAction == 'redirect') {
        if (this.config.redirect) {
          data.href = this.config.redirect;
          callback = function () {
            win.top.location = data.href;
          };
        }
        data = U.extend(data, {
          closeSession: closeSession,
          setShown: setShown,
          setSubscription: setSubscription,
          setEngaged: setEngaged,
          customTrackerEvent: customTrackerEvent,
          mimirEvent: 'engaged',
          next: this.controller.getAfterSubmitStep(callback, this)
        });
        data.next.origin = this;  // extend will go to loop
      }
      if (callback) {
        var redirectWaitTime = 500;
        if ('redirectWaitTime' in SleekNote.CustomInitSettings) {
          redirectWaitTime = SleekNote.CustomInitSettings.redirectWaitTime;
        }
        win.setTimeout(function () {
          callback();
        }, redirectWaitTime);
      }
      return data;
    },
    previewDummy: function (event, clickTarget) {
    },
    openSleeknote: function (event, clickTarget, skipDetect) {
      if (!skipDetect && this.detectMobileButtonClick(event, clickTarget))
        return;
      this.message({
        type: 'open',
        noteName: this.config.form,
        openTrigger: 'teaserClick'
      });
    },
    openTeaser: function (event, clickTarget) {
      // we may have a situation where we disable teaser toggle afterwards
      if (this.controller.teaserExist) {
        this.message({
          type: 'open',
          noteName: this.config.teaser
        });
        this.message({
          eventName: 'closed',
          type: 'trackevent',
          noteName: 'teaser',
          closeTrigger: {
            type: event.target ? 'closebutton' : 'dismiss',
            elementDataId: clickTarget.getAttribute('data-track-id')
          }
        });
      } else {
        this.hideBox(event, clickTarget);
      }
    },
    hideBox: function (event, clickTarget) {
      this.message({
        type: 'close',
        noteName: this.config.name,
        closeTrigger: {
          isImage: clickTarget.nodeName == 'IMG',
          isLinkButton: clickTarget.classList.contains('linkbutton'),
          type: event.target ? 'closebutton' : 'dismiss',
          elementDataId: clickTarget.getAttribute('data-track-id')
        }
      });
    },
    hideTeaserAndDontShowAgain: function () {
      if (this.production) {
        this.message({
          type: 'close',
          noteType: this.config.type,
          noteName: this.config.name
        });
      }
    },
    toggleForm: function () {
      this.message({
        type: this.config.current == 'half' ? 'maximize' : 'minimize',
        noteName: this.config.name
      });
    },
    maximizeForm: function () {
      this.message({
        type: 'maximize',
        noteName: this.config.name
      });
    },
    minimizeForm: function () {
      this.message({
        type: 'minimize',
        noteName: this.config.name
      });
    },
    redirectBox: function (event, clickTarget, passMobileDetect) {
      var href;
      var step;
      var target;
      var isLink = false;
      var stepMap = {
        showTeaser: 'teaser',
        showTogglersBox: 'form',
        showForm: 'form',
        showTogglersSuccess: 'success',
        showSuccess: 'success'
      };
      function afterSubmitRedirect(event, href, target, clickData) {
        if (href) {
          openPopupIf(event, href, target);
          //PP only linkbutton inside form gets submitted, everything else just passthru
          this.message(U.extend({
            type: 'aftersubmit',
            href: href,
            target: target,
            submitTrigger: this.getSubmitTriggerInfo(event, clickTarget)
          }, clickData));
        }
      }
      if (!passMobileDetect && this.detectMobileButtonClick(event, clickTarget))
        return;
      var clickData = {
        isUserDefinedClick: true,
        isImage: clickTarget.nodeName == 'IMG',
        isLinkButton: clickTarget.classList.contains('linkbutton'),
        isForm: U.querySelectorClosest(clickTarget, '#sleeknoteBox') || U.querySelectorClosest(clickTarget, '#sleeknote-form'),
        name: clickTarget.innerText
      };
      if (clickTarget.tagName == 'A') {
        href = clickTarget.getAttribute('href');
        target = clickTarget.getAttribute('target');
        isLink = true;
        /* not support anymore should be gone after 2018 yep still do as of Oct 2018 */
        if (clickTarget.getAttribute('data-section') == 'CTA button' || clickTarget.getAttribute('data-sn-send-mimir-event')) {
          // do the popup thing right here, inside trusted event handler
          afterSubmitRedirect.call(this, event, href, target, clickData);
        } else {
          if (target == '_blank') {
            openPopupIf(event, href, target);
          } else {
            this.message({
              type: 'redirect',
              href: href,
              target: target
            });
          }
          isLink = true;
        }
      } else if (clickTarget.tagName == 'IMG' || clickTarget.classList.contains('linkbutton') || clickTarget.getAttribute('data-sn-type') == 'background') {
        href = clickTarget.getAttribute('data-sn-custom-href');
        if (href && !~href.indexOf('//'))
          href = '//' + href;
        var mailto = clickTarget.getAttribute('data-sn-custom-email');
        if (mailto && !~mailto.indexOf('mailto:'))
          mailto = 'mailto:' + mailto;
        href = href || mailto;
        target = clickTarget.getAttribute('data-sn-custom-target') || (mailto ? '_self' : '_blank');
        afterSubmitRedirect.call(this, event, href, target, clickData);
        step = clickTarget.getAttribute('data-sn-custom-step');
        step = stepMap[step] || step;
        if (step) {
          if (~this.methodList.indexOf(step) && step in this) {
            this[step](event, clickTarget);
          } else {
            this.message(U.extend({
              type: 'step',
              step: step
            }, clickData));
          }
        }
      }
      this.message(U.extend({
        eventName: 'link_clicked',
        type: 'trackevent',
        href: href,
        step: step,
        elementDataId: clickTarget.getAttribute('data-track-id'),
        target: target,
        isLink: isLink
      }, clickData));
    },
    submitWithIFrame: function (url) {
      if (this.production) {
        var data = U.serialize(this.config.formNode);
        emit('submit', this.config, data);
        U.insertHTML(layout.getAnchor().DOMNode, '<iframe src="' + U.appendToUrl(url, data) + '" style="display:none;"></iframe>');
        debug('submitWithIFrame', url, data);
      }
    },
    sendCustomTrackerData: function (event) {
      this.message({
        type: 'trackerCustomEvent',
        CustomEventData: {
          SleeknoteId: this.config.campaignId,
          CustomerId: this.config.customerId,
          SignupPage: Location.get(SleekNote).href,
          event: event || 'SleeknoteSubscriber',
          fieldData: U.parseForm(this.config.formNode, undefined, true)
        }
      });
      debug('sendCustomTrackerData', event);
    },
    getSubmitTriggerInfo: function (event, target) {
      return {
        type: event && event.type || '',
        elementDataId: target.getAttribute('data-id')
      };
    },
    contactSubmitSleeknoteBox: function (event, clickTarget) {
      this.submitBox('//contactform.sleeknote.com', { submitTrigger: this.getSubmitTriggerInfo(event, clickTarget) });
    },
    submitSleeknoteBox: function (event, clickTarget) {
      var email = this.config.formNode.querySelector('input[type="email"]');
      var data = { submitTrigger: this.getSubmitTriggerInfo(event, clickTarget) };
      if (email)
        data.email = U.trim(email.value);
      this.submitBox('//subscribe.sleeknote.com', data);
    },
    submitBox: function (ourURL, successParams) {
      if (this.production && !validateInputs(this, true))
        return;
      var action = this.config.formNode.getAttribute('action') || ourURL;
      var domain = domainParser(action);
      //Make sure SignupPage is up to date ... it can sometime change from load in SPA
      //setup system fields
      this.insertOrReplaceHiddenInputs(this.doc, {
        guid: this.config.guid,
        SleeknoteId: this.config.campaignId,
        CustomerId: this.config.customerId,
        SignupPage: Location.get(SleekNote).href,
        UserAgent: win.navigator.userAgent
      });
      //Custom integration we don't handle the post action but make sure we still store the subscriber and if they changed to POST
      //if (action.indexOf('sleeknote.com') == -1) {
      if (!U.empty(domain) && domain.indexOf('sleeknote.com') < 0) {
        //for testing: noteFrame.win.GetElqCustomerGUID = function() { return 'hack'; }
        // HACK
        //On all custom integrations check if GetElqCustomerGUID() returns GUID, and if so pass it along with post/get to name field elqCustomerGUID".
        //				if (this.config.elqCustomerGUID) {
        //					this.config.formNode.insertAdjacentHTML(
        //						'afterbegin',
        //						'<input type="hidden" name="elqCustomerGUID", value="' + this.config.elqCustomerGUID + '">'
        //					);
        //				}
        //always save into our database
        this.submitWithIFrame(ourURL, this.config);
        var formMethod = ((this.config.formNode.hasAttribute('custom-method') ? this.config.formNode.getAttribute('custom-method') : this.config.formNode.getAttribute('method')) || 'GET').toUpperCase();
        if (formMethod == 'POST' && this.production) {
          U.insertHTML(this.config.boxNode, '<iframe id="dummyIframe" name="dummyIframe" style="width:0px;height:0px;visibility:hidden;display:block;border:0;position:absolute"></iframe>');
          this.config.formNode.setAttribute('target', 'dummyIframe');
          this.config.formNode.setAttribute('method', 'post');
          this.config.formNode.submit();
        } else {
          this.submitWithIFrame(action, this.config);
        }
      } else {
        this.submitWithIFrame(action, this.config);
      }
      // since something will get submitted send gtm data with SleeknoteSubscriber event
      this.sendCustomTrackerData('SleeknoteSubscriber');
      // we probably should wire this to submitting iframe onload, but yeah,
      this.config.submitted = true;
      successParams || (successParams = {});
      successParams.formData = U.parseForm(this.config.formNode, false, true);
      successParams.type = 'aftersubmit';
      successParams.name = this.config.name;
      this.message(successParams);
    }
  };
  return Note;
}(browser, utils, css, note_support, note_validation, constants, layout2, core_common, behaviour, location, click, event_emitter, locale, error, site_data, font_loader, excel_parser_core, excel_utils);
note_controller2 = function (B, U, CSS, Animator, Note, CONST, SleekNote, emit) {
  var win = this;
  var doc = win.document;
  // document all variables in controller config here
  /*
  	var cfg = {
  		// set in preprocessor
  		options: [], //advOptions
  		type: 0,
  		customerId: 0,
  		summaryId: 0,
  
  		// runtime, set
  		ready: 0,
  		stepName: 0, //??
  		trackData: 0,
  		smartIndex: 0,
  
  		// static, used
  		html: 0,
  		version: 0,
  		purpose: 0,
  		profile: 0,
  		url: 0,
  		campaignId: 0,
  		hidden: 0,
  		scroll: 0,
  		exit: 0,
  		wait: 0,
  		onClick: 0,
  		position: 0,
  
  		splitTestId: 0,
  		siteData: 0,
  
  		steps: [], // array of Note's configs
  	};
  	*/
  function unescape(str) {
    return str.replace(/&quot;/g, '"').replace(/&gt;/g, '>').replace(/&lt;/g, '<').replace(/&amp;/g, '&');
  }
  function NoteController(manager, config) {
    this.manager = manager;
    this.name = 'NoteController';
    this.config = config;
    if (SleekNote.preview)
      this.config.purpose = 'preview';
    if (SleekNote.editor)
      this.config.purpose = 'editor';
    this.notes = {};
    this.waiting = 0;
    this.guid = U.guid_string();
    this.next = undefined;
    // this is to launch something -after- animation has ended, it is difficult to pass callback, queue sends message to manager, manager looks here
    // in version 4 and up and in editor HTML is just one, previously still toggler and teaser part
    if (this.purposeNotProduction && ('html' in config || SleekNote.editor)) {
      if (config.html) {
        // editor v4
        this.onLoad(config.html);
      } else {
        this.profile = SleekNote.editor.profile;
        this.onLoad(unescape(win.SleekNote.editor.HTML));
      }
    } else {
      // fetch stuff;
      if (this.config.version > 3) {
        U.fetch(this.url('toggler'), function (request) {
          this.onLoad(request.responseText);
        }.bind(this));
      } else {
        this.waiting = 2;
        var html = {};
        var next = function (prop, text) {
          this.waiting -= 1;
          html[prop] = text;
          if (!this.waiting)
            this.onLoad(html);
        }.bind(this);
        U.fetch(this.url('toggler'), function (request) {
          next('toggler', request.responseText);
        });
        U.fetch(this.url('teaser'), function (request) {
          next('teaser', request.responseText);
        });
      }
    }
  }
  NoteController.prototype = {
    get purposeNotProduction() {
      return 'purpose' in this.config && this.config.purpose != 'production';
    },
    get profileStr() {
      return this.config.profile == CONST.PROFILE.MOBILE ? 'mobile' : 'desktop';
    },
    url: function (str) {
      if (this.config.url) {
        return this.config.version > 3 ? this.config.url : this.config.url[str];
      }
      var profile = 'desktop';
      if (this.config.version > 2 && (this.config.profile == CONST.PROFILE.MOBILE || this.config.profile == CONST.PROFILE.TABLET && SleekNote.tabletUsesMobile)) {
        profile = 'mobile';
      }
      return '//sleeknotestaticcontent.sleeknote.com/editorv2/' + profile + str + '/' + this.config.campaignId + '.html';
    },
    get isTouch() {
      // phones and tablets only
      return this.config.profile == CONST.PROFILE.MOBILE || this.config.profile == CONST.PROFILE.TABLET;
    },
    get isHello() {
      // there is always ate least one form
      var form = this.getType('form')[0];
      return form && form.isHello;  //return this.notes.form.isHello;
    },
    destroy: function (complete) {
      if (!this.config.ready)
        return;
      var names = Object.keys(this.notes);
      var l = names.length;
      while (l--)
        this.notes[names[l]] = this.notes[names[l]].destroy(complete);
      this.config.ready = false;
    },
    querySelectorAll: function (selector) {
      var names = Object.keys(this.notes);
      var l = names.length;
      var res = [];
      var n;
      while (l--) {
        n = this.notes[names[l]];
        if (n.doc)
          res = res.concat(Array.prototype.slice.call(n.doc.querySelectorAll(selector)));
      }
      return res;
    },
    get id() {
      return this.config.campaignId;
    },
    releaseNote: function (name) {
      try {
        if (name in this.notes && this.notes[name].animating) {
          this.notes[name].animating = false;
          this.notes[name].afterAnimation();
        }
      } catch (e) {
      }
      return this;
    },
    prepareNote: function (name, action, companion, resetDimensions) {
      if (U.typeStr(this.notes[name]) == 'object' && this.notes[name].ready) {
        resetDimensions && this.notes[name].dimensions(true);
        return this.notes[name].prepare(action, companion);
      }
    },
    get visible() {
      return Object.keys(this.notes).reduce(function (result, name) {
        return this.notes[name].visible && name || result;
      }.bind(this), false);
    },
    onafterrender: function () {
      Object.keys(this.notes).forEach(function (name) {
        if (U.typeStr(this.notes[name]) == 'object' && this.notes[name].ready)
          this.notes[name].onafterrender();
      }, this);
    },
    onLoad: function (param) {
      var html;
      U.Objectkeys(this.config.steps).forEach(function (name) {
        if (this.config.version > 3) {
          if (U.typeStr(param) == 'string') {
            html = param;
          } else if (name in param) {
            html = param[name];
          }
        } else {
          html = name == 'teaser' ? param.teaser : param.toggler;
        }
        this.notes[name] = {
          config: {},
          ready: false
        };
        new Note(this, {
          config: this.config.steps[name],
          html: html,
          name: name
        }, this.noteInserted.bind(this));
      }, this);
    },
    noteInserted: function (name, note) {
      if (note.config.boxNode) {
        this.notes[name] = note;
        note.config.guid = this.guid;
      }
    },
    message: function (data) {
      if (!data.origin)
        data.origin = this;
      if (data.stepName) {
        this.config.stepName = data.stepName;
      }
      // If there is an openTrigger then process it for events
      if (data.openTrigger) {
        this.processOpenTrigger(data.openTrigger);
      }
      if (data.closeTrigger) {
        this.processCloseTrigger(data.closeTrigger);
      }
      if (data.submitTrigger) {
        this.processSubmitTrigger(data.submitTrigger);
      }
      if (data.isUserDefinedClick) {
        this.processUserDefinedClicks(data);
      }
      this.manager.message(data);
      function ready(name) {
        return this.notes[name].ready;
      }
      switch (data.type) {
      case 'aftersubmit':
        // transfer all form values as hidden to the next form
        if (data.next && data.next.type == 'open' && this.notes[data.next.noteName].config.type == 'form') {
          var note = this.notes[data.next.noteName];
          note.insertOrReplaceHiddenInputs(note.doc, data.formData || {});
        }
        break;
      case 'after':
        this.releaseNote(data.noteName);
        emit('after', data);
        break;
      case 'ready':
        if (!this.config.ready && Object.keys(this.notes).every(ready, this)) {
          this.config.ready = true;
          // this helps hiding a teaser forever
          if (this.getType('teaser').length && !this.config.hidden) {
            // sync with launchTeaser()
            this.teaserExist = true;  // setting that to false helps softly keep teaser later hidden
          }
          var delay = this.notes.teaser && this.notes.teaser.config.teaserDelay;
          if (delay && delay > 0 && !SleekNote.editor) {
            (function (self) {
              setTimeout(function () {
                self.manager.message({
                  type: 'ready',
                  id: self.id,
                  origin: self
                });
              }, self.notes.teaser.config.teaserDelay * 1000);
            }(this));
          } else {
            this.manager.message({
              type: 'ready',
              id: this.id,
              origin: this
            });
          }
        }
        break;
      }
    },
    getType: function (type) {
      return U.filterMap(Object.keys(this.notes), function (name) {
        if (this.notes[name].config.type == type)
          return this.notes[name];
      }, this);
    },
    canBeLaunched: function () {
      if (SleekNote.editor)
        return true;
      // check if we are able to launch this campaign, this is Just In Time check after campaign is ready
      return !U.filterMap(Object.keys(this.notes), function (name) {
        return this.notes[name].isPrevented();
      }, this).length;
    },
    setVisibility: function (noteName, visibility) {
      if (!this.config.ready)
        return;
      var note = this.notes[noteName];
      note && note.setVisibility(visibility);
    },
    ifTrigger: function (name) {
      if (!this.config.ready)
        return;
      switch (name) {
      case 'scroll':
        if (this.config.scroll && B.scroll.pct() > this.config.scroll)
          return this.tameTriggers(name);
        break;
      case 'exit':
        if (this.config.exit) {
          return this.tameTriggers(name);
        }
        break;
      case 'timer':
        if (this.config.wait)
          return this.tameTriggers(name);
        break;
      }
    },
    launchTriggers: function (callback) {
      if (this.config.wait != 0) {
        this.timer = win.setTimeout(function () {
          if (this.ifTrigger('timer'))
            callback('timer', this);
        }.bind(this), Math.max(this.config.wait + 1000, 0));
      }
      if (this.config.onClick) {
        U.listener(doc, 'add', function (event) {
          if (U.querySelectorClosest(event.target, this.config.onClick.selector)) {
            this.manager.triggerOnClick(this.config.campaignId, this.config.onClick.triggerOnce, 'click');
          }
        }.bind(this))('click');
      }
      if (U.contains(this.getType('form')[0].config.position, CONST.POS.HELLO, CONST.POS.HELLO2))
        callback('notification', this);
    },
    tameTeaser: function () {
      // we do not show teaser anymore
      this.teaserExist = false;
      this.tameTriggers();
    },
    // make sure this not is not going to be pop up without calling triggerOnClick
    tameTriggers: function (name) {
      if (this.timer)
        win.clearTimeout(this.timer);
      this.processOpenTrigger(name);
      // reject all triggers, if enabled ... manual override everything
      this.config.hidden = true;
      this.config.wait = 0;
      this.config.exit = false;
      this.config.scroll = 0;
      return true;
    },
    processOpenTrigger: function (event) {
      if (event) {
        var TriggerEvent = {};
        switch (event) {
        case 'timer':
          TriggerEvent.name = '1_sleeknote_trigger_shown_after';
          TriggerEvent.value = this.config.wait / 1000;
          break;
        case 'scroll':
          TriggerEvent.name = '2_sleeknote_trigger_scroll';
          TriggerEvent.value = this.config.scroll;
          break;
        case 'exit':
          TriggerEvent.name = '3_sleeknote_exit_intent';
          break;
        case 'manual':
          TriggerEvent.name = '4_sleeknote_trigger_manual';
          break;
        case 'teaserClick':
          TriggerEvent.name = '5_sleeknote_teaser_clicked';
          break;
        case 'click':
          TriggerEvent.name = '13_sleeknote_trigger_click';
          break;
        case 'sitedata':
          TriggerEvent.name = '14_sleeknote_trigger_sitedata';
          break;
        default:
          TriggerEvent.name = event;
          break;
        }
        this.config.trackData = this.config.trackData || {};
        this.config.trackData.openTriggerEvent = TriggerEvent;
      }
    },
    processCloseTrigger: function (event) {
      if (event) {
        var TriggerEvent = {};
        switch (event.type) {
        case 'closebutton':
          if (event.isLinkButton) {
            TriggerEvent.name = '12_sleeknote_linkbutton_clicked';
          } else {
            TriggerEvent.name = '8_sleeknote_closebutton_clicked';
          }
          break;
        case 'dismiss':
          TriggerEvent.name = '9_sleeknote_dismissed';
          break;
        default:
          TriggerEvent.name = event.type;
          break;
        }
        TriggerEvent.elementDataId = event.elementDataId;
        this.config.trackData = this.config.trackData || {};
        this.config.trackData.closeTriggerEvent = TriggerEvent;
      }
    },
    processSubmitTrigger: function (event) {
      if (event) {
        var TriggerEvent = {};
        switch (event.type) {
        case 'click':
        case 'touchend':
        case 'touchcancel':
          TriggerEvent.name = '6_sleeknote_submitbutton_clicked';
          break;
        case 'keypress':
          //Right now just a place holder since sumbit can only be clicked
          TriggerEvent.name = '7_sleeknote_submitbutton_enterpress';
          break;
        default:
          TriggerEvent.name = event.type;
          break;
        }
        TriggerEvent.elementDataId = event.elementDataId;
        this.config.trackData = this.config.trackData || {};
        this.config.trackData.submitTriggerEvent = TriggerEvent;
      }
    },
    processUserDefinedClicks: function (data) {
      if (data) {
        /*
        var stepTranslator = {
        	showTeaser: 'teaser',
        	showTogglersSuccess: 'success',
        	showSuccess: 'success',
        	showForm: 'form',
        	showTogglersBox: 'form'
        };
        */
        var clickEvent = {};
        // if there is already an event then the click has already been categorized
        if (data.mimirEvent === undefined) {
          data.mimirEvent = 'link_clicked';
          clickEvent.linkDestination = data.href || data.step;
          clickEvent.linkDestinationType = data.href ? '1_url' : '2_sleeknotestep';
          if (data.isImage) {
            clickEvent.linkType = '1_imagelink';
          } else if (data.isLinkButton) {
            clickEvent.linkType = '3_linkbutton';
          } else if (data.isLink) {
            clickEvent.linkType = '2_textlink';
          }
          clickEvent.linkName = data.name;
          clickEvent.elementDataId = data.elementDataId;
          this.config.trackData = this.config.trackData || {};
          this.config.trackData.userDefinedClickEvent = clickEvent;
        }
      }
    },
    getAfterSubmitStep: function (redirected, note) {
      //TODO into behaviour
      if (!redirected && note.config.success) {
        return {
          type: 'open',
          noteName: note.config.success
        };
      } else {
        return {
          type: 'close',
          noteName: note.config.name
        };
      }
    }
  };
  return NoteController;
}(browser, utils, css, animator, note2, constants, core_common, event_emitter);
visibility = function (browser) {
  var win = this;
  function Visibility(options) {
    options || (options = {});
    if (this.onStateChanged = options.onStateChanged) {
      this.context = options.context || this;
      if (browser.has.touch) {
        // as pageshow event fires on initial page load, this flag prevents firing restore event in that case
        var appHasLoaded = false;
        win.addEventListener('pageshow', function () {
          if (!appHasLoaded) {
            appHasLoaded = true;
            return;
          }
          this.signalVisibilityChange(false);
        }.bind(this));
        win.addEventListener('pagehide', this.signalVisibilityChange.bind(this, true));
      } else {
        win.document.addEventListener('visibilitychange', function () {
          this.signalVisibilityChange(win.document.hidden);
        }.bind(this));
      }
    }
  }
  Visibility.prototype.signalVisibilityChange = function (wasHidden) {
    if (wasHidden) {
      this.onStateChanged.call(this.context, 'suspend');
    } else {
      // give browser some time to update DOM etc
      setTimeout(this.onStateChanged.bind(this.context, 'restore'), 100);
    }
  };
  return Visibility;
}(browser);
spacer = function (B, U, CSS, layout, SleekNote, behaviour) {
  // 	var win = this;
  // 	var doc = win.document;
  var instances = {};
  var next = {};
  // mocking the object, like Note, we pass to behaviour
  function Mock(note) {
    this.note = note;
    this.config = behaviour.defaults('spacer', note.config);
    this.dimensions = function () {
      return {
        width: this.config.style.width,
        height: this.config.height
      };
    };
  }
  function Spacer(layout) {
    this.layout = layout;
    this.reset();
  }
  //	function insert(controller, id, def) {
  //		// TODO: support multiple DOMParents
  //		var target = controller.notes[Object.keys(controller.notes)[0]].DOMParent;
  //		var style = U.extend({}, def.style, def.hidden);
  //		var dom = U.insertHTML(
  //			target,
  //			U.template('<span class={className} style="{style}"></span>', {
  //				className: pallet.sleeknoteWrap,
  //				id: id,
  //				style: style
  //			}),
  //			def.insert
  //		);
  //		return {
  //			dom: dom,
  //			style: style
  //		};
  //	}
  function insert(mock) {
    var config = mock.config;
    var target = U.qsa(config.selector, this.layout.getDocument())[0];
    config.DOMNode = U.insertHTML(target, U.template('<span class={className} style="{style}"></span>', {
      className: layout.sleeknoteWrap,
      id: config.id,
      style: CSS.inline(config.style)
    }), config.insert);
    return mock;
  }
  Spacer.prototype = {
    /*
    	show spacer if anyone needs it, hide spacer if no-one needs it
    	if nothing and we need to show - create
    	if shown and not needed - destroy
    */
    reset: function () {
      next = {};
      return this;
    },
    set: function (note) {
      var mock = new Mock(note);
      var hide = mock.config.next == 'close';
      if (!hide || !next[mock.config.id]) {
        // only add hide if first
        next[mock.config.id] = mock;
      }
      return this;
    },
    execute: function (repeat) {
      var prop;
      for (prop in instances)
        if (instances.hasOwnProperty(prop)) {
          if (next[prop]) {
            this.create(next[prop]);
            delete next[prop];
          } else {
            if (!repeat)
              this.destroy(instances[prop]);
          }
        }
      // new ones
      for (prop in next)
        if (next.hasOwnProperty(prop)) {
          this.create(next[prop]);
          delete next[prop];
        }
      return this;
    },
    reposition: function () {
      var prop;
      var mock;
      for (prop in instances) {
        if (instances.hasOwnProperty(prop)) {
          mock = instances[prop];
          mock.config = U.extend(mock.config, behaviour.defaults('spacer', mock.note.config));
          this.layout.css(mock.config, 'DOMNode', { height: mock.dimensions().height });
        }
      }
    },
    css: function (mock, params) {
      this.layout.css(mock.config, 'DOMNode', U.extend({}, params.to.animate, mock.config.style));
    },
    // TODO: animate instead of set CSS
    create: function (mock) {
      var id = mock.config.id;
      if (!instances[id]) {
        instances[id] = insert.call(this, mock);
        CSS.reveal(instances[id].config.DOMNode);
      } else {
        // this is not very elegant, but works for now
        var DOMNode = instances[id].config.DOMNode;
        instances[id] = mock;
        instances[id].config.DOMNode = DOMNode;
      }
      var params = behaviour.animationParameters(instances[id], 'close', 'open', instances[id].note);
      this.css(instances[id], params);
    },
    destroy: function (mock) {
      var id = mock.config.id;
      if (!instances[id])
        return;
      var params = behaviour.animationParameters(instances[id], 'open', 'close', instances[id].note);
      if (instances[id].config.kind == 'shared') {
        // just apply initial style, do not destroy dom
        this.css(instances[id], params);
      } else {
        U.removeNode(instances[id].config.DOMNode);
        delete instances[id];
      }
    }
  };
  return Spacer;
}(browser, utils, css, layout2, core_common, behaviour);
show_queue2 = function (B, U, Animator, SleekNote, Visibility, Spacer, behaviour, layout) {
  var win = this;
  //var doc = win.document;
  var debug = 0;
  //var editor = SleekNote.editor || SleekNote.preview;
  //	var preview = SleekNote.preview;
  function Entry(controller, type, noteName, callback) {
    if (!(this instanceof Entry))
      return new Entry(controller, type, noteName, callback);
    if (controller instanceof Entry) {
      this.controller = controller.controller;
      this.type = controller.type;
      this.noteName = controller.noteName;
      this.callback = controller.callback;
    } else {
      this.controller = controller;
      this.type = type;
      this.noteName = noteName;
      this.callback = callback;
    }
  }
  function ShowQueue(manager, context) {
    this.manager = manager;
    this.visibles = {};
    this.queue = [];
    this.busy = false;
    this.after = this.after.bind(this);
    this.actions = [];
    this.spacer = new Spacer(layout, context);
    layout.onReposition = function () {
      this.repositionIf(false, true);
    }.bind(this);
  }
  ShowQueue.prototype = {
    observeVisibility: function () {
      debug && console.log('observing visibility');
      // launch app state changes monitor
      new Visibility({
        context: this,
        onStateChanged: function (currentAppState) {
          if (currentAppState == 'restore') {
            debug && console.log(currentAppState);
            var id;
            var motion;
            win.setTimeout(function () {
              this.repositionIf(false, true);
            }.bind(this), 0);
            /* do we still need this?*/
            for (id in this.visibles) {
              motion = this.visibles[id].controller.prepareNote(this.visibles[id].noteName, 'current', false, true);
              motion.frame(1, false, true);
            }  //this.animator && this.animator[this.busy ? 'ffwd' : 'playLastFrame']();
          }
        }
      });
      this.observeVisibility = function () {
      };
    },
    get empty() {
      return !Object.keys(this.visibles).length;
    },
    // return visible form entry
    get stopper() {
      var id;
      for (id in this.visibles) {
        if (this.visibles.hasOwnProperty(id)) {
          if (this.isStopper(this.visibles[id]))
            return this.visibles[id];
        }
      }
    },
    getBoxType: function (entry) {
      var boxType = entry.controller ? entry.controller.notes[entry.noteName].config.type : '';
      return boxType;
    },
    isStopper: function (entry) {
      //if (editor) return true;
      //if (editor) return false;
      if (!entry || entry.controller.isHello)
        return false;
      return !this.concurrent || U.contains(this.getBoxType(entry), 'form', 'success');
    },
    get concurrent() {
      return this.manager.mode == 'concurrent';
    },
    addToVisibles: function (controller, noteName) {
      var entry = this.visibles[controller.id];
      if (entry) {
        entry.noteName = noteName;
      } else {
        entry = this.visibles[controller.id] = Entry(controller, '', noteName);
      }
      return entry;
    },
    removeFromVisibles: function (entry) {
      var entry = this.visibles[entry.controller.id];
      if (entry)
        delete this.visibles[entry.controller.id];
    },
    extractCloseRequest: function () {
      var l = this.queue.length;
      var entry;
      while (l--) {
        if (this.queue[l].type == 'close') {
          entry = this.queue[l];
          this.queue.splice(l, 1);
          return entry;
        }
      }
    },
    positionIsOccupied: function (controller) {
      var id;
      var visible;
      for (id in this.visibles) {
        if (this.visibles.hasOwnProperty(id)) {
          visible = this.visibles[id];
          if (visible.controller.config.position == controller.config.position)
            return visible;
        }
      }
    },
    extractHello: function () {
      var l = this.queue.length;
      var entry;
      while (l--) {
        entry = this.queue[l];
        // check if visible type is
        if (entry.controller.isHello && entry.type != 'close' && this.getBoxType(entry) == 'form' && !this.positionIsOccupied(entry.controller)) {
          this.queue.splice(l, 1);
          return entry;
        }
      }
    },
    /*
    	close is alwas a single operation only - close teaser, close box, close success, all of them just close, if toggling is needed, use open, as
    	open teaser will close form, open success will close foem (this logic is built in in next())
    	closing a box (form or success) will check if there is another box to open at the top of the queue, if it is, it will be opened
    	close can be picked from queue anytime (actually all closes can)
    	open may be multiple operation - if something from controller is visible, then this must be closed
    	if another box is visible and we need to open a box, then this visible box is to be closed and put into the queue as next
    	if we are closing (directly or indirectly) a box, then we need to look, whether there is next box to open in queue, if yes, it can be opened
    	
    */
    // next is called only after we have determined that we need to pick something from the queue, no decision of 'if' here
    // form is open, click to open its teaser, form is now closed, if no boxes
    next: function (now, ffwd) {
      var entry;
      var next;
      //var companion;
      var currentUp;
      var nextUp;
      var res;
      if (!this.queue.length || this.busy)
        return;
      this.actions = [];
      //close can be picked from queue anytime (actually all closes can)
      while (entry = this.extractCloseRequest()) {
        this.actions.push(entry);
        this.removeFromVisibles(entry);
      }
      // hello
      while (entry = this.extractHello()) {
        this.actions.push(entry);
        this.addToVisibles(entry.controller, entry.noteName);
      }
      // is there an open request left in the queue ?
      do {
        if (this.queue.length) {
          // should we replace box?
          if (!now && this.stopper && this.isStopper(this.queue[0]))
            break;
          // not more than one hello
          if (this.queue[0].controller.isHello) {
            entry = this.positionIsOccupied(this.queue[0].controller);
            if (entry && entry.controller != this.queue[0].controller)
              break;
          }
          next = this.queue.shift();
          // is next already open?
          entry = this.visibles[next.controller.id];
          if (entry && entry.noteName == next.noteName && U.contains(next.type, 'open', 'reveal'))
            break;
          // nothing to do
          this.actions.push(next);
          if ((entry = this.visibles[next.controller.id]) && U.contains(next.type, 'open', 'reveal')) {
            // this controller has another component visible, we need to close that one
            entry.type = 'close';
            currentUp = entry.noteName;
            this.actions.push(entry);
            this.removeFromVisibles(entry);
          }
          // if we have another box visible right now and we open a box, then we need to temporarily close it
          if (this.isStopper(next) && (entry = this.stopper)) {
            // we need to close that box and put it to the top of the queue
            entry.type = 'close';
            this.actions.push(entry);
            this.removeFromVisibles(entry);
            if (!this.manager.editor) {
              this.add('unshift', entry.controller, 'open', entry.noteName);
            }
          }
          // finally mark next one as visible
          this.addToVisibles(next.controller, next.noteName);
        }
        break;
      } while (1);
      if (!this.actions.length)
        return;
      var motions = [];
      this.spacer.reset();
      var motion;
      function addMotion() {
        if (motion) {
          motions = motions.concat(motion);
          motion = false;
          return true;
        }
      }
      /*
      	- if we need badge and no badge create open motion by 'next', add delay so badge appears solid last
      	- when creating badge motion, badge saves the note config used
      	- if we need badge and there is badge, update link by 'next'
      	- if we do not need badge and badge is up, create close motion
      
      	- if next needs cover and there is no cover create cover open motion
      	- if cover is up and we do not need it create cover close motion
      	- create other motions, if 'next' then apply badge in distance calculations
      	- if next is box and we have cover motion (any) then delay box slightly
      	- if we close a box and cover is up, then delay box slightly
      
      
      */
      var badge = this.manager.badge;
      var nextNote = next && next.controller.notes[next.noteName];
      // badge first as the position of badge will affect the next Box
      if (badge) {
        if (this.isStopper(next) && behaviour.needs.badge(nextNote.config)) {
          // we need badge to open or be open
          motion = badge.prepare('open', nextNote);
        } else {
          // close badge if open
          motion = badge.prepare('close');
        }
      }
      addMotion();
      if (nextNote && behaviour.needs.cover(nextNote.config)) {
        // open cover (if already open, nothing happens)
        motion = this.manager.cover.prepare('open', nextNote);
      } else {
        // next does not need, but is there any visibles that do?
        var stopper = this.stopper;
        if (stopper && behaviour.needs.cover(stopper.controller.notes[stopper.noteName].config)) {
        } else {
          // close
          motion = this.manager.cover.prepare('close');
        }
      }
      addMotion();
      //console.log(next && next.noteName, curr && curr.noteName);
      var nextUp = next && next.noteName;
      var actionNote;
      this.actions.forEach(function (action) {
        var companion;
        if (next && action.controller == next.controller) {
          companion = action.noteName == next.noteName ? currentUp : nextUp;
        }
        motion = action.controller.prepareNote(action.noteName, action.type, companion);
        actionNote = action.controller.notes[action.noteName];
        if (addMotion() && action.type != 'close' && behaviour.needs.spacer(actionNote.config)) {
          this.spacer.set(actionNote);
        }
      }, this);
      //TODO
      for (var id in this.visibles) {
        actionNote = this.visibles[id].controller.notes[this.visibles[id].noteName];
        if (behaviour.needs.spacer(actionNote.config)) {
          this.spacer.set(actionNote);
        }
      }
      this.spacer.execute();
      this.busy = true;
      res = this.actions.length;
      layout.prepareForAnimation(motions);
      this.animator = new Animator();
      this.animator.add(motions);
      this.observeVisibility();
      if (ffwd) {
        this.animator.playLastFrame();
        this.after();
      } else {
        this.animator.play(this.after);
      }
      return res;
    },
    after: function () {
      this.busy = false;
      //TODO
      //			this.manager.cover.after();
      if (this.manager.editor) {
        if ('onVisible' in this.manager) {
          // editor v4
          this.manager.onVisible(this.visibles[Object.keys(this.visibles)[0]]);
        } else {
          try {
            !this.empty && SleekNote.editor.event('CORE.NOTES_STATUS', this.visibles[Object.keys(this.visibles)[0]]);
          } catch (e) {
          }
        }
      }
      // iterate over all actions (what just happened)
      var l = this.actions.length;
      var entry;
      while (l--) {
        entry = this.actions[l];
        entry.controller.message({
          type: 'after',
          origin: entry.controller,
          action: entry.type,
          noteName: entry.noteName
        });
        win.setTimeout(function () {
          entry.callback && entry.callback('after');  //console.log('after', entry.noteName, entry.type);
        }, 0);
      }
      // in editor when user clicks on steps too fast we end up in situation where after animation
      // we have another request in queue and that blocks any subsequent switching of steps in editor
      // as by default, when something is in the queue, then the visible step must close before, but when
      // switching we do not call 'close', we call 'open'. This little change now forces showQueue to empty
      // its content in editor. Whatever the user pressed, however fast. The last click is now always executed
      this.next(this.manager.editor);
    },
    add: function (func, controller, type, noteName, callback, moveIfExist) {
      var index = this.queue.length;
      if (!controller.notes[noteName])
        return;
      var id = controller.config.campaignId;
      if (id in this.visibles && this.visibles[id].noteName == noteName) {
        // this one is already visible
        var current = this.visibles[id].controller.notes[noteName].visible;
        if (current == type)
          return;
        if (current == 'half' && type == 'minimize')
          return;
      }
      //if (type != 'close' && id in this.visibles && this.visibles[id].noteName == noteName) return;
      while (index--)
        if (this.queue[index].controller == controller)
          break;
      if (~index) {
        // TODO, this is Stage hack right now, we need to allow box to close properly
        if (this.queue[index].type == 'close' && type == 'open') {
          this.queue[func](Entry(controller, type, noteName, callback));
          return true;
        }
        //
        if (this.manager.editor)
          moveIfExist = true;
        if (moveIfExist) {
          this.queue.splice(index, 1);
          return this.add(func, controller, type, noteName, callback);
        }
        return func == 'unshift' && index === 0;
      } else {
        this.queue[func](Entry(controller, type, noteName, callback));
        return true;
      }
    },
    indexOf: function (controller) {
      var l = this.queue.length;
      while (l--) {
        if (this.queue[l].controller == controller)
          return l;
      }
      return -1;
    },
    push: function (controller, type, noteName, moveIfExist, callback) {
      if (this.add('push', controller, type, noteName, callback, moveIfExist)) {
        this.next();
        return true;
      }
    },
    closeIf: function (controller, callback, ffwd) {
      var entry = controller && this.visibles[controller.id];
      if (entry) {
        if (this.add('unshift', entry.controller, 'close', entry.noteName, callback))
          return this.next(1, ffwd);
      } else {
        callback && callback('none');
      }
    },
    now: function (controller, type, noteName, moveIfExist, callback) {
      if (this.add('unshift', controller, type, noteName, callback, moveIfExist))
        return this.next(1);
    },
    state: function (controller) {
      if (controller) {
        //if (~this.indexOf(controller)) return 1;
        if (this.visibles[controller.id])
          return 2;
      }
      return 0;
    },
    reset: function (keep) {
      if (keep === undefined)
        keep = '';
      var l = this.queue.length;
      keep = String(keep);
      //console.log('reset', l, this.queue, keep);
      while (l--) {
        if (keep.indexOf(this.queue[l].controller.id) < 0) {
          this.queue.splice(l, 1);
        }
      }
      var id;
      for (id in this.visibles) {
        if (this.visibles.hasOwnProperty(id) && keep.indexOf(id) < 0) {
          this.add('unshift', this.visibles[id].controller, 'close', this.visibles[id].noteName);
        }
      }
      return this.next(1);
    },
    repositionIf: function (controller, hard) {
      // if no controller, reposition all
      var note;
      var badge;
      var entry;
      var id;
      this.animator && this.animator.ffwd();
      for (id in this.visibles) {
        if (this.visibles.hasOwnProperty(id)) {
          if (controller && id != controller.id)
            continue;
          entry = this.visibles[id];
          note = entry.controller.notes[entry.noteName];
          note.reposition(hard);
          if (this.isStopper(entry)) {
            badge = this.manager.badge;
            badge && badge.reposition(note.config);
            this.manager.cover.reposition(note.config);
          }
        }
      }
      this.spacer.reposition();
    }
  };
  return ShowQueue;
}(browser, utils, animator, core_common, visibility, spacer, behaviour, layout2);
mimir = function (U, B, StorageCache, SleekNote) {
  var win = this;
  var doc = win.document;
  //var debug = SleekNote.debugMessage('m');
  var mimirImgURL = 'https://analytics.sleeknote.com/';
  var staticData = {};
  function getStaticData(customerId) {
    var data = {};
    data['s1'] = customerId || '';
    data['s2'] = doc.title;
    data['s3'] = win.location.hostname || '';
    data['s4'] = win.location.href || '';
    data['s9'] = win.location.protocol || '';
    data['s11'] = win.location.pathname || '';
    data['s12'] = win.location.search || '';
    data['s13'] = win.location.hash || '';
    data['c1'] = B.user.timezoneOffSet() || '';
    data['s7'] = B.user.language();
    data['v5'] = B.userAgent();
    data['v22'] = B.is.name;
    data['v23'] = B.is.version;
    data['v24'] = B.is.platform;
    data['v26'] = B.is.device;
    return data;
  }
  function formatDate(date) {
    return date.toISOString().split('.')[0] + 'Z';
  }
  function getTransactionData() {
    var storage = StorageCache.create({ useLocalStorage: false });
    var data = {};
    var currentDate = new Date();
    var sessionStartTime = storage.getSessionStartTime();
    var sessionDuration = Math.round((currentDate.getTime() - sessionStartTime.getTime()) / 1000);
    data['v0'] = storage.getVistorId();
    data['v3'] = formatDate(currentDate);
    data['v4'] = doc.referrer;
    data['v6'] = formatDate(sessionStartTime);
    //put here in case the first click is on the sleeknote and the session has closed/started since page was loaded
    var lastSessionTime = storage.getLastSessionEndTime();
    if (!U.empty(lastSessionTime)) {
      data['v7'] = formatDate(lastSessionTime);
    }
    //If the lastSessionTime is empty then there has no previous sessions so new visitor
    data['v20'] = U.empty(lastSessionTime) ? 'true' : 'false';
    data['v21'] = storage.getSessionId();
    data['v25'] = B.isLandscape() ? 'true' : 'false';
    data['v27'] = sessionDuration;
    return data;
  }
  function buildImg(url) {
    var img = doc.createElement('img');
    img.width = 1;
    img.height = 1;
    img.src = url;
    return img;
  }
  function sendImg(url, queryString, callback) {
    var img = buildImg(U.appendToUrl(url, queryString));
    img.onload = img.onerror = function () {
      img.onload = null;
      img.onerror = null;
      callback();
    };
  }
  function sendData(data, callback) {
    callback = callback || function () {
    };
    if (!B.is.bot) {
      var queryString = U.buildQueryString(data);
      sendImg(mimirImgURL, queryString, callback);  // U.httpRequest('GET', mimirXHRURL, data, callback, callback);
    }
  }
  function Mimir(customerId) {
    staticData = getStaticData(customerId);
  }
  var eventMapping = {
    pagereload: '1_pagereload',
    pageview: '2_pageview',
    shown: '3_sleeknote_shown',
    engaged: '4_sleeknote_engaged',
    closed: '5_sleeknote_closed',
    link_clicked: '6_sleeknote_link_clicked',
    goal_converted: '7_goal_converted',
    teaser_closed: '8_sleeknote_teaser_closed',
    substep_engaged: '11_sleeknote_substep_engaged'
  };
  var noteTypeMapping = {
    newsletter: '1_Newsletter',
    promote: '2_Promote',
    contact: '3_Contact',
    blank: '2_Promote'
  };
  Mimir.prototype = {
    trackPageView: function () {
      var eventData = { v8: eventMapping[win.performance && win.performance.navigation.type == 1 ? 'pagereload' : 'pageview'] || 'pageview' };
      sendData(U.extend(eventData, getTransactionData(), staticData));
    },
    trackEvent: function (eventName, noteConfig, callback) {
      noteConfig = noteConfig || {};
      noteConfig.trackData = noteConfig.trackData || {};
      var eventData = {
        v8: eventMapping[eventName] || eventName,
        v1: noteConfig && noteConfig.campaignId,
        v12: noteTypeMapping[noteConfig.type] || noteConfig.type,
        v33: noteConfig.stepName
      };
      if (noteConfig.summaryId) {
        eventData['v34'] = noteConfig.summaryId;
      }
      var openTriggerEvent = noteConfig.trackData.openTriggerEvent;
      if (openTriggerEvent) {
        eventData['v9'] = openTriggerEvent.name;
        if (openTriggerEvent.value) {
          eventData['v10'] = openTriggerEvent.value;
        }
      }
      var closeTriggerEvent = noteConfig.trackData.closeTriggerEvent;
      if (closeTriggerEvent) {
        eventData['v9'] = closeTriggerEvent.name;
        eventData['v32'] = closeTriggerEvent.elementDataId;
      }
      var submitTriggerEvent = noteConfig.trackData.submitTriggerEvent;
      if (submitTriggerEvent && eventName == 'engaged') {
        eventData['v9'] = submitTriggerEvent.name;
        eventData['v32'] = submitTriggerEvent.elementDataId;
        delete noteConfig.trackData.submitTriggerEvent;
      }
      var userDefinedClickEvent = noteConfig.trackData.userDefinedClickEvent;
      if (userDefinedClickEvent) {
        eventData['v28'] = userDefinedClickEvent.linkDestination;
        eventData['v29'] = userDefinedClickEvent.linkType;
        eventData['v30'] = userDefinedClickEvent.linkDestinationType;
        eventData['v31'] = userDefinedClickEvent.linkName;
        eventData['v32'] = userDefinedClickEvent.elementDataId;
      }
      if (noteConfig.smartIndex) {
        eventData['v11'] = 'true';
      }
      var splitTestId = noteConfig.splitTestId;
      //splitTestId has to be an int as well... this will not be the case when smart trigger which also uses split test id
      if (splitTestId && !isNaN(splitTestId)) {
        eventData['v19'] = splitTestId;
      }
      var position = noteConfig.position || noteConfig.form && noteConfig.form.position;
      if (position) {
        eventData['v13'] = position;
      }
      sendData(U.extend(eventData, getTransactionData(), staticData), callback);
      //Cleanup
      //after sending we don't need events anymore
      noteConfig.trackData && delete noteConfig.trackData;
    },
    trackGoal: function (event, idGoal) {
      var storage = StorageCache.create({ useLocalStorage: false });
      var eventData = {
        v8: eventMapping[event] || event,
        g1: idGoal,
        v15: 'true'
      };
      eventData['g2'] = Object.keys(storage.getGoalEngageList()).join(',');
      eventData['g3'] = Object.keys(storage.getGoalShownList()).join(',');
      sendData(U.extend(eventData, getTransactionData(), staticData));
      // remove tracking data after send
      storage.resetGoal();
    }
  };
  return Mimir;
}(utils, browser, storage_cache, core_common);
tracker = function (U, SleekNote, Mirmir, StorageCache) {
  var win = this;
  var doc = win.document;
  var mimirTracker;
  var debug = SleekNote.debugMessage('t');
  var editor = SleekNote.editor || SleekNote.preview;
  function Tracker(customerId, callback) {
    mimirTracker = new Mirmir(customerId);
    mimirTracker.trackPageView();
    this.isGoalMatch();
  }
  function GAEvent(category, a, b) {
    //bail if GA is disabled in the config
    if (SleekNote.CustomInitSettings.DisableGA) {
      debug('GA disabled in config', SleekNote.CustomInitSettings.DisableGA);
      return;
    }
    if (SleekNote.CustomInitSettings.DisableGAEvents) {
      if (~SleekNote.CustomInitSettings.DisableGAEvents.indexOf(a))
        return;
    }
    var ga = win.ga;
    var _gat = win._gat;
    var _gaq = win._gaq;
    var _gaTracker = win.__gaTracker;
    var sent = 0;
    // it was reported that using ublock _getTrackers() returns 'undefined'
    // to be sure, added try catch here as there may be other unexpected happenings
    try {
      b = b.toString();
      if (_gat && _gat._getTrackers) {
        _gat._getTrackers().forEach(function (tracker) {
          tracker._trackEvent(category, a, b, undefined, 1);
        });
        sent++;
      } else if (_gaq && _gaq.push) {
        _gaq.push([
          '_trackEvent',
          category,
          a,
          b,
          undefined,
          1
        ]);
      } else if (_gaTracker) {
        _gaTracker('send', 'event', category, a, b, undefined, 1);
      }
      if (ga && ga.getAll) {
        ga.getAll().forEach(function (ad) {
          ga(ad.get('name') + '.send', 'event', category, a, b, { nonInteraction: true });
        });
        sent++;
      }
      // google analytics blocked
      if (!sent) {
        debug('google blocked');
      }
    } catch (e) {
      debug(e);
    }
  }
  //	function FBEvent(eventName, sleeknoteId) {
  //		//bail if GA is disabled in the config
  //		if (SleekNote.CustomInitSettings && SleekNote.CustomInitSettings.DisableFBPE) {
  //			debug('FB pixel events disabled in config', SleekNote.CustomInitSettings.DisableFBPE);
  //			return;
  //		}
  //
  //		//send to facebook
  //		if (win.fbq) {
  //			//send to facebook if it exists as well
  //			//same event names as google
  //			var customData = {
  //				event: eventName,
  //				sleeknoteID: sleeknoteId
  //			};
  //
  //			win.fbq('track', 'Lead', customData);
  //		}
  //	}
  Tracker.prototype = {
    event: function (event, noteConfig, callback) {
      !editor && mimirTracker && mimirTracker.trackEvent(event, noteConfig, callback);  //			callback && callback(); //handled in mimir send data
    },
    shown: function (noteConfig) {
      //Track the box is shown
      this.event('shown', noteConfig, null);
      this.customTrackerEvent('boxShown', noteConfig.campaignId);
      debug('closeSession');
    },
    cohortEvent: function (testName, cohort, eventName) {
      if (editor)
        return;
      GAEvent('cohorts', testName, cohort + ' | ' + eventName);
    },
    //3rd party tracker integration
    customTrackerEvent: function (type, sleeknoteId) {
      sleeknoteId = sleeknoteId || 'unknown';
      debug('customTrackerEvent', type);
      function track(eventName, sleeknoteId) {
        GAEvent('Sleeknote', eventName, sleeknoteId);  //FBEvent(eventName, sleeknoteId);
      }
      switch (type) {
      case 'boxShown':
        track('Sleeknote shown', sleeknoteId);
        break;
      case 'newsletter':
        track('New Subscriber', sleeknoteId);
        break;
      case 'contact':
        track('New Contact Request', sleeknoteId);
        break;
      case 'blank':
        track('Blank Click', sleeknoteId);
        break;
      case 'social':
        track('New Social Follower', sleeknoteId);
        break;
      default:
        debug('customTrackerEvent', 'unknown');
        break;
      }
    },
    isGoalMatch: function () {
      if (editor)
        return;
      var i;
      var j;
      var currentUrl = doc.location.href;
      var goalUrls;
      var goalStorage;
      if (!SleekNote.SleeknoteGoals)
        return;
      goalStorage = StorageCache.create({ useLocalStorage: true });
      if (goalStorage.read('location') == currentUrl) {
        return;
      } else {
        goalStorage.write('location', currentUrl);
      }
      //Need this as a For loop so we can break out of it. I've tried to refactor this one too many times :)
      for (i = 0; i < SleekNote.SleeknoteGoals.length; i++) {
        goalUrls = SleekNote.SleeknoteGoals[i].urls;
        for (j = 0; j < goalUrls.length; j++) {
          if (~currentUrl.indexOf(goalUrls[j].url)) {
            mimirTracker.trackGoal('goal_converted', SleekNote.SleeknoteGoals[i].goalId);
            break;
          }
        }
      }
    }
  };
  return Tracker;
}(utils, core_common, mimir, storage_cache);
evaluator = function (U, Location, SleekNote, SiteData, C) {
  var edebug = SleekNote.debug ? function (conf, name, matchType, value, result) {
    if (!conf.CampaignId)
      debugger;
    var id = (conf.CampaignId + '').split('-')[0];
    if (result === Boolean(result))
      result = result ? 'YES' : 'NO';
    var arr = [
      id,
      ' ',
      name,
      ' [',
      matchType,
      ', "',
      value,
      '"]'
    ];
    if (result !== undefined) {
      arr.push(' ->');
    }
    console.log(arr.join(''), result === undefined ? '' : result);
  } : function () {
  };
  /*
  		This is submodule for preprocessor.js, it is unlikely you ever need to call any of it's methods directly or from elsewhere
  	
  	*/
  /*
  		this is needed to have a current location modified, e.g. when testing, the current window.location is not
  		suitable and we need to set it to something else
  		
  		also we need to slightly modify window.location and properties to our liking
  		
  		therefore:
  			- whenever you need something from window.location here, you should call Location.get(SleekNote) which returns instance of Location ( see location.js )
  			- whenever you need to compare urls, you need to use Loaction methods for this: domainMatches(), matches()
  			- whenever you need params, use queryParams()
  			- whenever you need window.location as String, use String(Location.get(SleekNote))
  
  	*/
  //############################################################################################
  //####################### METHODS FOR VERSION 1, VERSION 2 KEEP SCROLLING ####################
  //############################################################################################
  // parameters are 1:1 from init script
  // conf is full object of one sleeknote definition ( it is added later for debug info only )
  // storage is instance of storage.js object
  function isCorrectDomain(hostNamePunycode, hostName, conf) {
    if (SleekNote.local === true || hostName === undefined)
      return true;
    var isCorrect = Location.get(SleekNote).domainMatches(hostName);
    /*|| Location.get(SleekNote).domainMatches(SleekNote.puny.decodePuny(hostNamePunycode))*/
    edebug(conf, 'CorrectDomain', 'is', hostNamePunycode ? hostNamePunycode + ',' + hostName : hostName, isCorrect);
    return isCorrect;
  }
  function excludedOrIncludedFromThisReferral(includeExclude, includeExcludeReferrals, originalReferrer, conf) {
    var showOnThisPage = true;
    var domainBeforeStar;
    if (includeExclude === undefined || !Array.isArray(includeExcludeReferrals)) {
      edebug(conf, 'excludedOrIncludedFromThisReferral', 'not evaluated');
      return showOnThisPage;
    }
    if (includeExclude == 'exclude') {
      for (var i = 0; i < includeExcludeReferrals.length; i++) {
        var excludedReferral = includeExcludeReferrals[i];
        excludedReferral = U.cleanUpReferral(excludedReferral);
        if (excludedReferral) {
          if (excludedReferral.indexOf('*') != -1) {
            //case of *.sleeknote
            domainBeforeStar = excludedReferral.replace('*', '');
            if (originalReferrer.indexOf(domainBeforeStar) != -1) {
              showOnThisPage = false;
            }
          } else if (originalReferrer == excludedReferral) {
            showOnThisPage = false;
          }
        }
      }
    } else {
      showOnThisPage = false;
      for (var j = 0; j < includeExcludeReferrals.length; j++) {
        var includedReferral = includeExcludeReferrals[j];
        includedReferral = U.cleanUpReferral(includedReferral);
        if (includedReferral) {
          if (includedReferral.indexOf('*') != -1) {
            domainBeforeStar = includedReferral.replace('*', '');
            if (originalReferrer.indexOf(domainBeforeStar) != -1) {
              showOnThisPage = true;
            }
          } else if (originalReferrer == includedReferral) {
            showOnThisPage = true;
          }
        }
      }
    }
    edebug(conf, 'excludedOrIncludedFromThisReferral', 'is', showOnThisPage);
    return showOnThisPage;
  }
  // this func is an exception and call ver2 appropriate evaluation function
  function excludedOrIncludedOnThisPage(includeExclude, includeExcludeURLs, conf) {
    return evaluateArraySome(evaluateURL, includeExclude, includeExcludeURLs || [], conf);
  }
  // return true for sleeknote to show
  function includeOnThisUTM(UTM, storage, campaignId, conf) {
    function showOnThisPageByUTM(UTMCondition, success) {
      // no condition - show
      if (!Array.isArray(UTMCondition)) {
        edebug(conf, 'includeOnThisUTM', 'not evaluated');
        return true;
      }
      edebug(conf, 'includeOnThisUTM', 'evaluating', JSON.stringify(UTMCondition));
      var valuesFromQuery;
      var i;
      var j;
      var match;
      if (Array.isArray(UTMCondition)) {
        for (i = 0; i < UTMCondition.length; i++) {
          // getQueryVarByName always return string
          valuesFromQuery = U.getQueryVarByName(UTMCondition[i].UTMName).toLowerCase().split(',');
          // match is at least one
          match = false;
          for (j = 0; j < valuesFromQuery.length; j++) {
            if (UTMCondition[i].matchType == 'contains') {
              match = ~valuesFromQuery[j].indexOf(UTMCondition[i].value);
            } else {
              match = valuesFromQuery[j] == UTMCondition[i].value;
            }
            if (match)
              break;
          }
          if (!match)
            return !success;  /*
                              if (UTMCondition[i].matchType == 'contains') {
                              	if ( valueFromQuery.indexOf(UTMCondition[i].value) < 0 ) return !success;
                              } else if ( valueFromQuery != UTMCondition[i].value ) {
                              	return !success;
                              }
                              */
        }
      }
      return success;
    }
    // test if we have a cookie set
    var cookie = storage.getUTMInclude(campaignId);
    if (cookie) {
      edebug(conf, 'includeOnThisUTM', 'cookie', cookie > 0);
      return cookie > 0;  // cookie is either -1 (false) or 1 (true)
    }
    if (!UTM) {
      edebug(conf, 'includeOnThisUTM', 'not evaluated');
      return true;
    }
    if (!Array.isArray(UTM.Exclude) && !Array.isArray(UTM.Include)) {
      edebug(conf, 'includeOnThisUTM', 'not evaluated');
      return true;  // if no conditions specified bail out quickly and do not set a cookie too
    }
    // if include matches then show, if exclude matches then not
    if (showOnThisPageByUTM(UTM.Exclude, false) && showOnThisPageByUTM(UTM.Include, true)) {
      // if we actually had conditions, save that result to cookie
      storage.setUTMInclude(campaignId, 1);
      edebug(conf, 'includeOnThisUTM', 'is', true);
      return true;
    }
    storage.setUTMInclude(campaignId, -1);
    edebug(conf, 'includeOnThisUTM', 'is', false);
  }
  //############################################################################################
  //####################### HERE, METHODS FOR VERSION 2 AND UP #################################
  //############################################################################################
  function isAnyConditions2(conf) {
    var groups = conf.rules && conf.rules.groups || [];
    var i = 0;
    for (; i < groups.length; i++) {
      if (groups[i].conditions && groups[i].conditions.length)
        return true;
    }
    return false;
  }
  // returns a boolean indicating if the campaign should be shown
  function includeNote2(conf, storage) {
    var unsorted = conf.rules && conf.rules.groups || [];
    var i = 0;
    var include = false;
    var result = true;
    var groups = [];
    for (i = 0; i < unsorted.length; i++) {
      groups[unsorted[i].conditionAnd ? 0 : 1] = unsorted[i];
    }
    for (i = 0; i < groups.length; i++) {
      include = !!this.evaluateGroup(groups[i].conditions, groups[i].conditionAnd, conf, storage);
      // right now groupAnd can never be false, so it always does result && include
      result = groups[i].groupAnd ? result && include : result || include;
    }
    return result;
  }
  // groups are Include and Exclude, we need to evaluate the conditions in both of them separately
  function evaluateGroup(conditions, and, conf, storage) {
    var i = 0;
    var condition;
    var final = and;
    var result;
    var matchType;
    var value;
    if (!conditions) {
      return true;
    }
    edebug(conf, '--Conditions--', and ? 'AND' : 'OR', conditions.length);
    if (!conditions.length) {
      return true;
    }
    for (; i < conditions.length; i++) {
      condition = conditions[i];
      var getConditionValue = this.evaluatorFunctions[condition.type].formatValue;
      var evaluateCondition = this.evaluatorFunctions[condition.type].evaluate;
      if (U.typeStr(condition) != 'object')
        continue;
      value = getConditionValue ? getConditionValue(condition.value) : condition.value;
      matchType = condition.matchType;
      // we evaluate URLs together with exclude/include,and then condition.matchType is 'none'
      result = evaluateCondition(and, matchType, value, conf, storage);
      final = and ? final && result : final || result;
    }
    return final;
  }
  /*
  		As each condition is evaluated and it's value formatted differently, 
  		all the behaviours are defined in this lookup object
  		
  		arguments for all evaluator functions:
  
  		and: 		ruleset groups and/or
  		matchType: 	include, exclude
  		value: 		value in whatever format given
  		conf: 		current sleeknote config oject (unprocessed e.g. PascalCase one, that is in init.js)
  		storage: 	current Sleeknote storage instance
  	
  	
  	*/
  var evaluatorFunctions = {
    1: {
      evaluate: evalSequence,
      formatValue: getArrayOfValuesFromJson
    },
    2: {
      evaluate: evalNewsletterSubscriber,
      formatValue: getNewsletterSubscriberValue
    },
    3: { evaluate: evalNewVisitor },
    4: {
      evaluate: evaluateIncludeExclude(evaluateURL),
      formatValue: getIncludeExcludeObject
    },
    5: {
      evaluate: evalSpecificQuery,
      formatValue: getIncludeExcludeObject
    },
    6: {
      evaluate: evalSpecificReferral,
      formatValue: getArrayOfValuesFromJson
    },
    7: {
      evaluate: evalUTMCampaign,
      formatValue: getObjectFromJSON
    },
    8: { evaluate: evalShowCount },
    9: {
      evaluate: evalSpecificCookie,
      formatValue: getIncludeExcludeObject
    },
    10: {
      evaluate: evaluateIncludeExclude(containsURL),
      formatValue: getIncludeExcludeObject
    },
    11: {
      evaluate: evaluateIncludeExclude(containsGEOID),
      formatValue: getIncludeExcludeObject
    },
    12: {
      evaluate: evaluateIncludeExclude(evalateHtmlElementValue),
      formatValue: getObjectFromJSON
    },
    13: {
      evaluate: evalSiteDataDetection,
      formatValue: getObjectFromJSON
    },
    14: { evaluate: evalPagesVisitedCount },
    15: {
      evaluate: evaluateIncludeExclude(containsIPAddress),
      formatValue: getIncludeExcludeObject
    }
  };
  // specific for conditions that can have both inclusion or exclusion parameters
  function evaluateIncludeExclude(evaluatorFunction) {
    return function (and, matchType, value, conf, storage) {
      var result = evaluateArraySome(evaluatorFunction, 'exclude', value.exclude, conf, storage);
      if (result) {
        result = evaluateArraySome(evaluatorFunction, 'include', value.include, conf, storage);
      } else {
        // hoist that exlusion, exclude wins
        if (!and)
          matchType = 'exclude';
      }
      return result;
    };
  }
  function evalSequence(and, matchType, value, conf, storage) {
    var arr = storage.getSequence(conf.CampaignId);
    // unprocessed config here
    edebug(conf, 'Current Sequence', 'is', U.JSON.stringify(arr));
    if (arr.length < value.length) {
      if (evaluateURL('include', value[arr.length], conf, storage)) {
        // next sequence matched
        arr.push(1);  // if same as previous URL don't stop the sequence... probably a refresh
      } else if (!(arr.length - 1 >= 0 && evaluateURL('include', value[arr.length - 1], conf, storage))) {
        // failure, clear sequence, start over
        arr.length = 0;
      }
    }
    storage.setSequence(conf.CampaignId, arr);
    if (arr.length == value.length) {
      // all matched
      edebug(conf, 'evalSequence', matchType, value, true);
      return match(matchType, true);
    } else {
      if (matchType == 'exclude')
        return true;
    }
    edebug(conf, 'evalSequence', matchType, value, false);
  }
  function evalNewsletterSubscriber(and, matchType, value, conf, storage) {
    //value: "{"value":true,"extraParam":"foo=blaah"}" || boolean
    var subscribed = storage.isSubscribed() || U.getQueryVarByName('SNSubscribed') == 'true';
    edebug(conf, 'Current Subscribe', 'saved', subscribed);
    if (!subscribed && value.extraParam) {
      subscribed = ~String(Location.get(SleekNote)).indexOf(value.extraParam);
    }
    if (value.value) {
      subscribed = subscribed && value.value;
    } else {
      subscribed = subscribed && value;
    }
    var result = match(matchType, subscribed);
    edebug(conf, 'evalNewsletterSubscriber', matchType, value.value ? value.value : value, result);
    return result;
  }
  function evalNewVisitor(and, matchType, value, conf, storage) {
    var result = match(matchType, storage.newVisitor);
    edebug(conf, 'evalNewVisitor', matchType, value, result);
    return result;
  }
  function evaluateURL(matchType, value, conf, storage) {
    var result = match(matchType, Location.get(SleekNote).matches(value));
    edebug(conf, 'evaluateURL', matchType, value, result);
    return result;
  }
  function evalSpecificQuery(and, matchType, value, conf, storage) {
    function evaluateQueries(and, matchType, value, conf, storage) {
      function evaluateQuery(and, matchType, arr, conf, storage) {
        var params = Location.get(SleekNote).queryParams();
        // all arr conditions must presentn in query for match
        var result = 0;
        if (arr.length) {
          arr.forEach(function (obj) {
            //value.include/exclude.value is always array with only one member [{"value":[{"key":"test1","value":"1"}]
            var key = obj[0].key;
            var value = obj[0].value;
            var r = key in params && params[key] == value;
            edebug(conf, 'evalSpecificQuery', and ? 'and' : 'or', matchType, '?' + key + '=' + value + ' ' + r, 0);
            if (r) {
              result++;
            }
          });
          if (result == arr.length) {
            result = matchType == 'include' ? 1 : -1;
            edebug(conf, 'evaluateQuery', matchType, arr, true);
            return result;
          } else {
            result = 0;
            edebug(conf, 'evaluateQuery', matchType, [], false);
          }
        }
        return result;
      }
      var exclude;
      var include;
      var cookie = storage.getQueryInclude(conf.CampaignId);
      // unprocessed config here
      exclude = evaluateQuery(and, 'exclude', value.exclude || [], conf, storage);
      include = evaluateQuery(and, 'include', value.include || [], conf, storage);
      if (!exclude && !include) {
        // no rules evaluated to true, no need to set cookie (?)
        if (cookie)
          edebug(conf, 'Query cookie', 'is set', cookie, true);
        return {
          result: cookie ? cookie > 0 : (value.include || []).length ? false : true,
          matchType: matchType
        };
      }
      if (exclude) {
        // excluding this sleeknote
        if (!and)
          matchType = 'exclude';
        storage.setQueryInclude(conf.CampaignId, exclude);
        return {
          result: false,
          matchType: matchType
        };
      }
      if (include) {
        storage.setQueryInclude(conf.CampaignId, include);
        return {
          result: true,
          matchType: matchType
        };
      }
    }
    var cookie = storage.getQueryInclude(conf.CampaignId);
    // unprocessed config here
    if (U.empty(Location.get(SleekNote).queryParams()) && cookie) {
      edebug(conf, 'Query cookie', 'is set', cookie, true);
      return cookie > 0;  // cookie is either -1 (exclude sleeknote) or 1 (include sleeknote)
    } else {
      var result = evaluateQueries(and, matchType, value, conf, storage);
      matchType = result.matchType;
      return result.result;
    }
  }
  function evalSpecificReferral(and, matchType, value, conf, storage) {
    var lowerReferral = storage.getReferral();
    // empty string if nothing!
    edebug(conf, 'stored referral is', lowerReferral);
    var referred = lowerReferral && value.some(function (referList) {
      var valueArray = referList.split(',');
      return valueArray.some(function (referValue) {
        //return U.cleanUpReferral(referValue).toLowerCase() == U.cleanUpReferral(lowerReferral).toLowerCase();
        // stored referral is already cleaned up when stored, double cleanup is not working as expected with urls (noop)
        return U.cleanUpReferral(referValue).toLowerCase() == lowerReferral.toLowerCase();
      });
    });
    var result = match(matchType, referred);
    edebug(conf, 'evalSpecificReferral', matchType, value, result);
    return result;
  }
  function evalUTMCampaign(and, matchType, value, conf, storage) {
    function evaluateValues(param, arr) {
      var i;
      var j;
      var matchType;
      var params = param.split(',');
      for (i = 0; i < arr.length; i++) {
        matchType = arr[i].matchType;
        // inside array, only one match is needed
        for (j = 0; j < params.length; j++) {
          if (matchType == 'exactMatch') {
            if (arr[i].value == params[j])
              return true;
          } else if (matchType == 'contains') {
            if (~params[j].indexOf(arr[i].value))
              return true;
          }
        }
      }
    }
    function evaluateUTM(params, obj) {
      var p;
      var noMatch;
      var param;
      for (p in obj)
        if (obj.hasOwnProperty(p)) {
          noMatch = true;
          for (param in params) {
            if (p.toLowerCase() == param.toLowerCase()) {
              noMatch = false;
              //if it exists in params but the value is not right then fail
              if (!evaluateValues(params[param], obj[p]))
                return false;
            }
          }
          //if we're looking for it and it's not in params then we fail to find a match
          if (noMatch)
            return false;
        }
      //All the objects existed in params and the value matched
      return true;
    }
    var params = Location.get(SleekNote).queryParams();
    var cookie = storage.getUTMInclude(conf.CampaignId);
    // unprocessed config here
    if (cookie) {
      edebug(conf, 'UTM cookie', 'is set', cookie, false);
      return cookie > 0;  // cookie is either -1 (false) or 1 (true)
    }
    var matchUTM = evaluateUTM(params, value);
    var result = match(matchType, matchUTM);
    storage.setUTMInclude(conf.CampaignId, result ? 1 : -1);
    edebug(conf, 'evalUTMCampaign', matchType, JSON.stringify(value), result);
    return result;
  }
  function evalShowCount(and, matchType, value, conf, storage) {
    if (conf.hiddenSleeknote) {
      // show no matter what
      edebug(conf, 'evalShowCount', 'hidden Sleeknote');
      return true;
    }
    var showed = storage.getShowCount(conf.CampaignId);
    var result = match(matchType, showed >= value);
    edebug(conf, 'evalShowCount', matchType, value, result);
    return result;
  }
  function evalSpecificCookie(and, matchType, value, conf, storage) {
    function evaluateCookies(matchType, value, conf, storage) {
      function evaluateCookie(matchType, value, conf, storage) {
        var segments = value.split('=');
        var result;
        if (segments.length > 1) {
          // Check if cookie exists and if value matches
          result = storage.cookieMatches(segments[0], segments[1]);
        } else {
          // Check if cookie exists
          result = storage.cookieExists(segments[0]);
        }
        result = match(matchType, result);
        edebug(conf, 'evaluateCookie', matchType, value, result);
        return result;
      }
      value || (value = []);
      var l = value.length;
      if (!l)
        return true;
      // nothing to evaluate, include
      if (matchType == 'include') {
        while (l--)
          if (!evaluateCookie(matchType, value[l], conf, storage))
            break;
        if (l == -1)
          return true;
      } else {
        while (l--)
          if (!evaluateCookie(matchType, value[l], conf, storage))
            return false;
        return true;
      }
    }
    var result = evaluateCookies('exclude', value.exclude, conf, storage);
    if (result) {
      result = evaluateCookies('include', value.include, conf, storage);
    } else {
      // hoist that exlusion, exclude wins
      if (!and)
        matchType = 'exclude';
    }
    return result;
  }
  function containsURL(matchType, value, conf, storage) {
    var result = match(matchType, Location.get(SleekNote).contains(value && value.toString()));
    //value should never be something different than string, but due to a bug in editor we need to convert it here for customer's affected
    edebug(conf, 'containsURL', matchType, value, result);
    return result;
  }
  function containsGEOID(matchType, value, conf, storage) {
    function inBoundingBox(sw, ne, p) {
      // in case longitude 180 is inside the box
      var isLongInRange = ne.lng < sw.lng ? p.lng >= sw.lng || p.lng <= ne.lng : p.lng >= sw.lng && p.lng <= ne.lng;
      return p.lat >= sw.lat && p.lat <= ne.lat && isLongInRange;
    }
    value = value || {};
    var geoInfo = storage.getGeoInfo() || {};
    var result;
    if (value.sw) {
      result = match(matchType, inBoundingBox(value.sw, value.ne, {
        lat: geoInfo.lt,
        lng: geoInfo.lg
      }));
    } else {
      result = match(matchType, geoInfo.gi.indexOf(value.geoname_id) > -1);
    }
    edebug(conf, 'containsGEOID', matchType, JSON.stringify(value), result);
    return result;
  }
  function containsIPAddress(matchType, value, conf, storage) {
    function checkIpaddrInRange(ipaddr, start, end) {
      var num = atoi(ipaddr);
      return num >= atoi(start) && num <= atoi(end);
    }
    function atoi(addr) {
      var parts = addr.trim().split('.');
      var result = (parts[0] ? parts[0] * Math.pow(256, 3) : 0) + (parts[1] ? parts[1] * Math.pow(256, 2) : 0) + (parts[2] ? parts[2] * Math.pow(256, 1) : 0) + parts[3];
      if (result < 0) {
        throw new Error(addr + ' is not a legal host ipaddr');
      }
      return result;
    }
    value = value || {};
    var ipAddress = storage.getIPAddress() || {};
    var startIPAddress, endIPAddress;
    var ipAddressRangeValues = value.split('-');
    startIPAddress = ipAddressRangeValues[0];
    endIPAddress = ipAddressRangeValues[1] || startIPAddress;
    var result = match(matchType, checkIpaddrInRange(ipAddress, startIPAddress, endIPAddress));
    edebug(conf, 'containsIPAddress', matchType, value, result);
    return result;
  }
  function evalateHtmlElementValue(matchType, value, conf, storage) {
    var targetElement = U.gid(value.target);
    //check element exists or not first
    if (U.empty(targetElement)) {
      var result = match(matchType, value.matchType == 'notExists');
      edebug(conf, 'evalateHtmlElementValue', matchType, result);
      //only return if we are checking on it's non existence and it's empty
      return result;
    }
    var eleValue = U.parseNodeValue(targetElement);
    var result = match(matchType, U.JITMatch(eleValue, value.matchType, value.value));
    edebug(conf, 'evalateHtmlElementValue', matchType, value.target + ' ' + value.matchType + ' ' + value.value + ' -> ' + result);
    return result;
  }
  function evalSiteDataDetection(and, matchType, value, conf, storage) {
    function evalateSiteDataValue(matchType, condition, conf, storage) {
      var siteData = new SiteData();
      var result = match(matchType, siteData.matchSessionProperty(condition.target, condition.matchType, condition.value));
      edebug(conf, 'evalateSiteDataValue', matchType, result);
      return result;
    }
    function evaluateArrayEvery(evaluatorFunction, matchType, valueArray, conf, storage) {
      valueArray = valueArray || [];
      if (!valueArray.length)
        return true;
      var r = valueArray.every(function (value) {
        var result = evaluatorFunction(matchType, value, conf, storage);
        return matchType == 'include' ? result : !result;
      });
      return matchType == 'include' ? r : !r;
    }
    var result = evaluateArrayEvery(evalateSiteDataValue, 'exclude', value.exclude, conf, storage);
    if (result) {
      result = evaluateArrayEvery(evalateSiteDataValue, 'include', value.include, conf, storage);
    } else {
      // hoist that exlusion, exclude wins
      if (!and)
        matchType = 'exclude';
    }
    return result;
  }
  function evalPagesVisitedCount(and, matchType, value, conf, storage) {
    function getCookie(option, CampaignId, value) {
      if (option == C.CONDITIONS.PAGESVISITEDOPTIONS.ONESESSION) {
        return storage.getPagesVisitedCountPerSession(CampaignId) || 0;
      } else {
        return storage.getPagesVisitedCount(CampaignId) || 0;
      }
    }
    function setCookie(option, CampaignId, pagesVisitedCount) {
      if (option == C.CONDITIONS.PAGESVISITEDOPTIONS.ONESESSION) {
        storage.setPagesVisitedCountPerSession(CampaignId, pagesVisitedCount);
      } else {
        storage.setPagesVisitedCount(CampaignId, pagesVisitedCount);
      }
    }
    var objValue = U.typeStr(value) != 'object' ? U.JSON.parse(value) : value;
    var pagesVisitedCount = getCookie(objValue.option, conf.CampaignId);
    pagesVisitedCount += 1;
    setCookie(objValue.option, conf.CampaignId, pagesVisitedCount);
    edebug(conf, 'Current Number of Pages Visited', 'is', pagesVisitedCount);
    var result = match(matchType, objValue.value <= pagesVisitedCount);
    edebug(conf, 'evalPagesVisitedCount', matchType, value, result);
    return result;
  }
  // array is evaluated for include or exclude branch, one success is needed (e.g. array of values is evaluated as or)
  function evaluateArraySome(evaluatorFunction, matchType, value, conf, storage) {
    var l = (value || []).length;
    var r = false;
    if (!l)
      return true;
    while (l--) {
      r = evaluatorFunction(matchType, value[l], conf, storage);
      if (matchType == 'include') {
        // first true means include
        if (r)
          return true;
      } else {
        // first false means exclude
        if (!r)
          return false;
      }
    }
    return r;
  }
  //Functions to format the value comming from JSON (from the editor)
  function getArrayOfValuesFromJson(value) {
    var arr = [];
    var l;
    // '[{"value":"blaah.ee","caption":"blaah.ee"},{"value":"foo.ee","caption":"foo.ee"}]'
    if (!Array.isArray(value))
      value = U.JSON.parse(value);
    l = value.length;
    while (l--)
      arr.unshift(value[l].value);
    return arr;
  }
  function getIncludeExcludeObject(value) {
    var obj = {};
    if (U.typeStr(value) == 'string')
      value = U.JSON.parse(value);
    //"value":'{"include":[{"value":[{"key":"adadada"}],"caption":[{"key":"adadada"}]}],"exclude":[{"value":[{"key":"sdasdasd"}],"caption":[{"key":"sdasdasd"}]}]}',"id":"27709909"},
    if (value.include)
      obj.include = getArrayOfValuesFromJson(value.include);
    if (value.exclude)
      obj.exclude = getArrayOfValuesFromJson(value.exclude);
    return obj;
  }
  function getObjectFromJSON(value) {
    if (U.typeStr(value) == 'string')
      value = U.JSON.parse(value);
    return value;
  }
  function getNewsletterSubscriberValue(value) {
    // The value can be a boolean or a Url identifier
    if (U.typeStr(value) != 'boolean') {
      value = U.JSON.parse(value);
    }
    return value;
  }
  // simple match reverter, on exclude true/false needs to be converted to false/true
  function match(matchType, result) {
    return matchType == 'exclude' ? !result : result;
  }
  return {
    // for v1 sleeknotes
    isCorrectDomain: isCorrectDomain,
    excludedOrIncludedFromThisReferral: excludedOrIncludedFromThisReferral,
    excludedOrIncludedOnThisPage: excludedOrIncludedOnThisPage,
    includeOnThisUTM: includeOnThisUTM,
    // for v2 and up sleeknotes
    includeNote2: includeNote2,
    isAnyConditions2: isAnyConditions2,
    // public for testing purposes
    evaluateArraySome: evaluateArraySome,
    evaluateGroup: evaluateGroup,
    evaluatorFunctions: evaluatorFunctions,
    evaluateURL: evaluateURL,
    containsURL: containsURL,
    containsGEOID: containsGEOID,
    containsIPAddress: containsIPAddress,
    evalateHtmlElementValue: evalateHtmlElementValue,
    match: match
  };
}(utils, location, core_common, site_data, constants);
cohorts = function (U, SleekNote) {
  var win = this;
  var campaignId;
  function randomIntFromInterval(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
  }
  function isBetween(a, b, c) {
    return a >= b && a <= c;
  }
  // The main test object
  return function () {
    var Constructor = function (storage, options) {
      this.storage = storage;
      this.options = U.extend({
        smart: false,
        name: null,
        cohorts: null,
        sample: 1,
        invalidConfigCallback: function () {
        },
        previousChoiceRemoved: function () {
        }
      }, options);
      campaignId = this.options.name;
      // Check params
      if (!campaignId) {
        console.warn('cohort: A name for this test must be specified');
        this.options.invalidConfigCallback();
      } else if (!this.options.cohorts) {
        console.warn('cohort: Cohorts must be specified for this test');
        this.options.invalidConfigCallback();
      } else if (U.objectSize(this.options.cohorts) < 2) {
        if (!this.getCohort(campaignId)) {
          console.warn('cohort: You must specify at least 2 cohorts for a test');
          this.options.invalidConfigCallback();
        } else {
          console.warn('cohort: Previous note is not longer available');
          this.options.previousChoiceRemoved();
        }
      } else {
        this.cohorts = Object.keys(this.options.cohorts);
        this.run();
      }
    };
    Constructor.prototype = {
      run: function () {
        // Determine whether there is forcing of cohorts via the URL
        var hash = win.location.hash;
        var cohort;
        if (hash.indexOf('#') === 0)
          hash = hash.slice(1, hash.length);
        var pairs = hash.split('&');
        for (var i = 0; i < pairs.length; i++) {
          var pair = pairs[i].split('=');
          var name = pair[0];
          cohort = pair[1];
          if (this.options.name == name) {
            this.setCohort(campaignId, cohort);
          }
        }
        // Determine whether user should be in the test
        var in_test = this.getInTest(campaignId);
        if (in_test === null)
          in_test = Math.random() <= this.options.sample;
        var chosen_cohort;
        if (in_test) {
          this.storage.setInTest(campaignId, 1);
          if (!this.getCohort(campaignId)) {
            var chosen_partition = 0;
            var j;
            var len = U.objectSize(this.options.cohorts);
            // determine which cohort the user is chosen to be in
            if (this.options.smart) {
              j = randomIntFromInterval(1, 100);
              while (len--) {
                cohort = this.options.cohorts[this.cohorts[len]];
                if (isBetween(j, cohort.low, cohort.high)) {
                  chosen_partition = len;
                  break;
                }
              }
            } else {
              chosen_partition = randomIntFromInterval(0, len - 1);
            }
            chosen_cohort = this.cohorts[chosen_partition];
            this.setCohort(campaignId, chosen_cohort);
          } else {
            chosen_cohort = this.getCohort(campaignId);
          }
          // not used now
          //if (!this.options.smart) SleekNote.tracker.cohortEvent(this.options.name, chosen_cohort, 'Total');
          //this.options.storageAdapter.onInitialize(in_test, this.options.name, chosen_cohort);
          // call the onChosen handler, if it exists
          if (this.options.cohorts[chosen_cohort] && this.options.cohorts[chosen_cohort].onChosen)
            this.options.cohorts[chosen_cohort].onChosen();
        } else {
          this.setInTest(campaignId, 0);
        }
      },
      /* not used now
                event: function(eventName) {
                    if (this.getInTest() && !this.options.smart) SleekNote.tracker.cohortEvent(this.options.name, this.getCohort(), eventName);
                    //    this.options.storageAdapter.onEvent(this.options.name, this.getCohort(), eventName);
                },
      	*/
      getInTest: function (campaignId) {
        return this.storage.getInTest(campaignId);
      },
      getCohort: function (campaignId) {
        if (this.getInTest(campaignId)) {
          return this.storage.getChosenCohort(campaignId);
        }
      },
      setCohort: function (campaignId, cohort) {
        if (this.cohorts.indexOf(cohort) == -1) {
          return false;
        } else {
          this.storage.setChosenCohort(campaignId, cohort);
          return true;
        }
      }
    };
    return Constructor;
  }();
}(utils, core_common);
rendermode = function (B, C, SleekNote) {
  /*
  		extracted from old preprocessor
  	*/
  var PROFILE = C.PROFILE;
  var debug = SleekNote.debug ? console.log : function () {
  };
  // if we detect that customers mobile site is some random mess and not real mobile site, we then do not run mobile sleeknotes there
  // if we detect that customers mobile site is some random mess and not real mobile site, we then do not run mobile sleeknotes there
  function isRealMobileSite() {
    // isRealMobileSite is now actually a number that is equal to win.innerWidth in normal unzoomed use
    if (B.is.phone && 'isRealMobileSite' in SleekNote.CustomInitSettings)
      return !!SleekNote.CustomInitSettings.isRealMobileSite;
    return B.is.phone ? B.notScaledMobileContent() : true;  // yep
  }
  function getRenderMode(conf, ignoreRules) {
    var profile;
    if (ignoreRules) {
      if ((SleekNote.editor || SleekNote.preview) && SleekNote.editor != 'test') {
        profile = (SleekNote.editor || SleekNote.preview).profile == 'mobile' ? PROFILE.MOBILE : PROFILE.DESKTOP;
      } else {
        if (B.is.desktop) {
          profile = PROFILE.DESKTOP;
        } else if (B.is.tablet) {
          profile = PROFILE.TABLET;
        } else {
          profile = PROFILE.MOBILE;
        }
      }
    } else {
      // hook to override PROFILE
      if ('displayStatus' in SleekNote.CustomInitSettings) {
        profile = SleekNote.CustomInitSettings.displayStatus(B, SleekNote, conf, PROFILE);
      }
      if (!('displayStatus' in SleekNote.CustomInitSettings) || profile === undefined) {
        profile = PROFILE.IGNORE;
        if (Array.isArray(conf.rules.display)) {
          if (B.is.desktop) {
            if (~conf.rules.display.indexOf(1))
              profile = PROFILE.DESKTOP;
          } else if (B.is.tablet) {
            if (~conf.rules.display.indexOf(1))
              profile = PROFILE.TABLET;
          } else {
            if (~conf.rules.display.indexOf(2))
              profile = PROFILE.MOBILE;
          }
        } else {
          if (B.is.desktop) {
            if (~[
                1,
                3
              ].indexOf(conf.rules.display))
              profile = PROFILE.DESKTOP;
          } else if (B.is.tablet) {
            if (~[
                1,
                2
              ].indexOf(conf.rules.display))
              profile = PROFILE.TABLET;
          } else {
            if (~[
                1,
                2
              ].indexOf(conf.rules.display))
              profile = PROFILE.MOBILE;
          }
        }
      }
    }
    if (!ignoreRules) {
      // as of now, when we detect a non-mobile optimized site, we act as desktop
      //if ( profile == PROFILE.MOBILE && !isRealMobileSite() ) profile = PROFILE.DESKTOP;
      let realMobile = isRealMobileSite();
      if (B.is.phone)
        debug(conf.campaignId || conf.CampaignId, 'realMobileSite', realMobile);
      if (profile == PROFILE.MOBILE && !realMobile)
        if ('displayStatus' in SleekNote.CustomInitSettings && SleekNote.CustomInitSettings.displayStatus(B, SleekNote, conf, PROFILE) == PROFILE.MOBILE) {
          profile = PROFILE.MOBILE;
        } else {
          profile = PROFILE.TABLET;
        }
    }
    return profile;
  }
  return getRenderMode;
}(browser, constants, core_common);
preprocessor = function (B, U, evaluator, Cohorts, SleekNote, C, getRenderMode) {
  var PROFILE = C.PROFILE;
  var P = C.POS;
  /* 
  	the purpose of this module is to act as a bridge between whatever back-end data and whatever front-end code
  	
  	currently it converts old (v1) init sleeknote data into structures that new code understands and needs - processConfig1()
  	
  	for various reasons, also v2 and v3 are alos stored partially in v1 notation, so we convert those too  - processConfig2()
  
  	there is only one method to export
  		generateConfig(sleekNotes, storage, ignoreRules)
  		
  		sleekNotes: array of sleeknote config from init script
  		storage: instance of storage object used
  		ignoreRules: include sleeknotes bypassing rules, this is used for jabascript triggering sleeknote which may be not included to show on this page by rules, 
  			with JS API any sleeknote that is in init, can be shown
  			
  		returns: array of seeknotes which members are suitable for NoteManager.add() only e.g to add sleeknotes to customer page, run the init script style array through generateConfig
  		and then add them one-by-one by calling notemanager's instance add(), everything from there is automatic
  
  */
  var win = this;
  var doc = win.document;
  var debug = SleekNote.debug ? function (id, msg, val) {
    if (typeof id == 'string') {
      id = id.split('-')[0];
    }
    if (val === Boolean(val))
      val = val ? 'YES' : 'NO';
    if ((msg + '').indexOf('START') === 0)
      id = '\n' + id;
    if (undefined !== val) {
      msg += ': ' + val;
    }
    console.log.call(console, id, msg);
  } : function () {
  };
  //function profile2prop(profile) {
  //	return profile == PROFILE.MOBILE ? 'mobile' : 'desktop';
  //}
  /* displayStatus HOOK example
  		CustomInitSettings: {
  			displayStatus: function(B, SleekNote, conf, PROFILE) {
  				// this is SleekNote
  				if ( conf.CampaignId == 1000 && !B.is.phone ) return PROFILE.DESKTOP;
  				// if not decided, return undefined
  			}
  		}
  
  		CustomInitSettings = {displayStatus: function(B, SleekNote, conf, PROFILE) {
  			// this is SleekNote
  			if ( conf.CampaignId == 22571 ) {
  				return B.is.phone ? PROFILE.IGNORE : PROFILE.DESKTOP;
  
  			} else if ( conf.CampaignId == 'e209efcd-d780-4651-a754-a60f19470763' ) {
  				return B.is.phone ? PROFILE.MOBILE : PROFILE.IGNORE;
  			}
  		}};
  
  	*/
  /*
  		to split smartsleeknote into split tests
  		1) create config - identify smart sleeknote and then add sleeknotes into config based on that
  	*/
  function newerThanV1(conf) {
    return 'rules' in conf || (+conf.Version || 0) > 1;
  }
  // see the beginning of this file
  function generateConfig(sleekNotes, storage, ignoreRules) {
    if (!Array.isArray(sleekNotes))
      return [];
    var splitTests = {};
    var add = [];
    // some of those that are to be shown may be smart sleeknotes
    sleekNotes.forEach(function (conf, index) {
      if (!conf)
        return;
      var variants;
      var newConf;
      var id = conf.CampaignId + '-smart';
      function getVariants() {
        var renderMode = getRenderMode(conf, ignoreRules);
        //If it's mobile or we're not going to show the sleeknote then don't create smart triggers
        return renderMode != PROFILE.MOBILE && renderMode != PROFILE.IGNORE ? conf.smarts : undefined;
      }
      if (Array.isArray(variants = getVariants())) {
        splitTests[id] = [];
        var low = 1;
        variants = variants.map(function (variant) {
          variant.low = low;
          variant.high = low + variant.weight - 1;
          low = variant.high + 1;
          return variant;
        });
        variants.forEach(function (variant, vindex) {
          var triggers = [U.extend(variant)];
          var smartIndex = [
            triggers[0].id,
            triggers[0].type,
            triggers[0].value,
            triggers[0].weight
          ].join(',');
          if (vindex) {
            newConf = U.extend(conf);
            newConf.SplitTestId = id;
            newConf.smartIndex = smartIndex;
            newConf.rules.triggers = triggers;
            add.push(newConf);
          } else {
            conf.smartIndex = smartIndex;
            conf.rules.triggers = triggers;
            conf.SplitTestId = id;
          }
        });
        conf = false;
      }
    });
    sleekNotes = sleekNotes.concat(add);
    // after map we have an array with empty slots for sleeknotes that are not to be shown
    var config = sleekNotes.map(function (conf, index) {
      if (newerThanV1(conf)) {
        return processConfig2(storage, conf, splitTests, index, ignoreRules);
      } else {
        return processConfig1(storage, conf, splitTests, index, ignoreRules);
      }
    });
    var chosenTests = [];
    var invalidSplitTest = [];
    var campaignId = '';
    Object.keys(splitTests).forEach(function (splitTestId) {
      var test = splitTests[splitTestId];
      var l = test.length;
      var smartIndex;
      var q;
      var low = 0;
      var high = 100;
      if (!l)
        return;
      debug('testSubjects: ' + l + ' Test subject 1: ' + config[test[0]].campaignId);
      var cohortObject = {};
      for (q = 0; q < l; q++) {
        smartIndex = config[test[q]].smartIndex || '';
        campaignId = config[test[q]].campaignId;
        if (smartIndex) {
          low = sleekNotes[test[q]].rules.triggers[0].low || 0;
          high = sleekNotes[test[q]].rules.triggers[0].high || 100;
        }
        cohortObject[campaignId + smartIndex] = {
          sleeknoteId: campaignId,
          smartIndex: smartIndex,
          low: low,
          high: high,
          onChosen: function (qq) {
            return function () {
              chosenTests.push(test[qq]);
            };
          }(q)
        };
      }
      try {
        debug('added Split test', cohortObject);
        //PP: this will initalize and call onChosen, so we need to erase not chosen ones from array
        new Cohorts(storage, {
          smart: smartIndex,
          name: smartIndex ? campaignId : splitTestId,
          sample: 1,
          cohorts: cohortObject,
          //Invalid Split test
          invalidConfigCallback: function () {
            //If invalid because it doesn't have enough sleeknotes that were included in the test
            if (Object.keys(cohortObject).length < 2) {
              debug('Split test not added, invalid split test...Stoping split test but showing the only one we have', cohortObject);
              invalidSplitTest[splitTestId] = true;
            }
          },
          //If the user previously had a cohort but it no longer exists, the split test logic will handle it
          previousChoiceRemoved: function () {
          }
        });
      } catch (e) {
        debug(e);
      }
    });
    return config.filter(function (c, index) {
      // filter out sleeknotes that did not chosen for split testing, also filter out not to be shown
      if (c) {
        if (c.splitTestId) {
          if (invalidSplitTest[c.splitTestId]) {
            delete c.splitTestId;
            // remove splitestid since it's an invalid splittest
            return c;
          }
          if (chosenTests.indexOf(index) < 0) {
            debug(c.campaignId, c.splitTestId, c.smartIndex || '', 'ignored for split test');
            return;
          } else {
            debug(c.campaignId, c.splitTestId, c.smartIndex || '', 'added for split test');
          }
        }
        // set persistent show cookie count to at least 0
        storage && storage.setShowCount(c.campaignId, storage.getShowCount(c.campaignId));
      }
      return c;
    });
  }
  function processConfig1(storage, conf, splitTests, index, ignoreRules) {
    var r;
    var profile = PROFILE.UNKN;
    var doNotShow;
    var subscribed = storage.isSubscribed() || U.getQueryVarByName('SNSubscribed') == 'true';
    // fix existng properties
    // if undefined, set 4, if 0 set 99999
    var showCount = conf.ShowCount === undefined ? 4 : +conf.ShowCount || 99999;
    var obeyDontShow = conf.ObeyDontShow == 'true' ? true : false;
    var includeExcludeReferral = evaluator.excludedOrIncludedFromThisReferral(conf.includeExcludeReferral, conf.includeExcludeReferrals, storage.getReferral(), conf);
    var includeExclude = evaluator.excludedOrIncludedOnThisPage(conf.includeExclude, conf.includeExcludeURLs, conf);
    var email = storage.getEmail(conf.CampaignId);
    var showed = storage.getShowCount(conf.CampaignId);
    var correctDomain = evaluator.isCorrectDomain(conf.HostnamePunycode, conf.Hostname, conf);
    var includeUTM = evaluator.includeOnThisUTM(conf.UTM, storage, conf.CampaignId, conf);
    // should this SleekNote to be launched
    doNotShow = email || showed >= showCount || obeyDontShow && subscribed || !correctDomain || !includeExclude || !includeExcludeReferral || !includeUTM;
    if (!ignoreRules && !conf.hiddenSleeknote && doNotShow) {
      profile = PROFILE.IGNORE;
    } else {
      profile = getRenderMode(conf, ignoreRules);
    }
    // that SleekNote is to be ignored, not shown at all
    if (profile <= PROFILE.IGNORE) {
      // band-aid 26.0.17, can i think safely removed in a year or so
      storage.cleanShowCount(conf.CampaignId);
      debug('sleeknote ignored', conf.CampaignId, 'email:', email, 'show:', showed, showCount, 'obey:', obeyDontShow, 'subscribed:', subscribed);
      return;
    }
    // copy over only what is needed now
    r = {
      profile: profile,
      campaignId: conf.CampaignId,
      // old
      //delay: conf.ShowSleekNoteAfter == 'exit' ? -1 : (storage.isSessionClosed(conf.CampaignId) ? false : +conf.ShowSleekNoteAfter),
      // new
      wait: conf.ShowSleekNoteAfter == 'exit' ? 0 : storage.isSessionClosed(conf.CampaignId) ? 0 : +conf.ShowSleekNoteAfter,
      // 0 - do not autoshow
      exit: storage.isSessionClosed(conf.CampaignId) ? false : conf.ShowSleekNoteAfter == 'exit',
      // show on exit
      hidden: conf.hiddenSleeknote,
      // do not autoshow
      type: conf.SleeknoteType,
      showCount: showCount,
      splitTestId: conf.SplitTestId,
      customerId: conf.CustomerId,
      version: 1,
      successLandingPage: conf.SuccessLandingPage,
      successAction: conf.SuccessAction
    };
    if (ignoreRules) {
      // set it hidden, because we always manage the sleeknote manually in that case
      debug('ignoring the rules for "' + conf.CampaignId + '" use t() to activate');
      r.hidden = true;
    }
    //if ( !r.wait ) r.hidden = true;
    if (r.hidden && !doNotShow)
      r.wait = 0;
    // i have special meaning for 0 later on, 1 is as good as 0 timewise :-)
    if (r.delay === 0)
      r.delay = 1;
    if (r.hidden && doNotShow) {
      // if we are hiddden and not to be shown - make it stick, set delay to zero
      r.delay = 0;
      r.exit = false;
      r.wait = 0;
    }
    return processConfigRest(r, conf, splitTests, index);
  }
  function ix(profile) {
    return profile == PROFILE.MOBILE ? 1 : 0;
  }
  function getConfProp(name, ifNone, conf, profile) {
    var res = conf[name];
    if (Array.isArray(res)) {
      res = res[ix(profile)];
    }
    if (res === undefined)
      res = ifNone;
    return res;
  }
  function processConfig2(storage, conf, splitTests, index, ignoreRules) {
    function trigger(i, def) {
      var l = conf.rules.triggers.length;
      while (l--)
        if (conf.rules.triggers[l].type == i)
          return conf.rules.triggers[l].value;
      return def;
    }
    var doNotShow;
    var r = {
      options: conf.advOptions || [],
      profile: getRenderMode(conf, ignoreRules),
      campaignId: conf.CampaignId,
      wait: 0,
      exit: false,
      hidden: true,
      type: conf.SleeknoteType,
      customerId: conf.CustomerId,
      summaryId: conf.summaryId,
      smartIndex: conf.smartIndex,
      version: +conf.Version || 2
    };
    if (r.version < 4) {
      r.successAction = getConfProp('SuccessAction', undefined, conf, r.profile);
      r.successLandingPage = getConfProp('SuccessLandingPage', undefined, conf, r.profile);
    }
    if (ignoreRules) {
      r = U.extend(r, { hidden: SleekNote.editor || SleekNote.preview ? false : true });
      debug(r.campaignId, 'ignoring the rules');
    } else {
      debug(r.campaignId, 'START EVALUATING');
      debug(r.campaignId, 'Location', win.location.toString());
      //if (B.is.phone) debug(r.campaignId, 'realMobileSite', isRealMobileSite());
      SleekNote.DomainLimits || (SleekNote.DomainLimits = {});
      var ignoreImpressionLimits = U.getAdvOption({ options: conf.advOptions }, 'impressionOverride', 1);
      var domainLimit = SleekNote.DomainLimits[conf.Hostname] || SleekNote.DomainLimits['All non-selected domains'];
      var overImpressionLimit = !ignoreImpressionLimits && domainLimit !== undefined && storage.getSessionShowCount() >= domainLimit;
      if (!domainLimit) {
        debug(r.campaignId, 'domainLimit(' + domainLimit + ') is not specified so ignored.... overImpressionLimit:' + overImpressionLimit);
      } else {
        debug(r.campaignId, ' ignoreImpressionLimits(' + ignoreImpressionLimits + ') domainLimit (' + domainLimit + ')  impressionCount (' + storage.getSessionShowCount() + ') >= ' + ' domainLimit (' + domainLimit + ') => overImpressionLimit: ' + overImpressionLimit);
      }
      var correctDomain = evaluator.isCorrectDomain(conf.HostnamePunycode, conf.Hostname, conf);
      var include = evaluator.includeNote2(conf, storage);
      var storedEmail = storage.getEmail(r.campaignId);
      doNotShow = overImpressionLimit || storedEmail || !correctDomain || !include || storage.isSessionHidden(r.campaignId);
      try {
        //if it's a demo campaign then always show
        if ('demoCampaignIds' in SleekNote.CustomInitSettings && r.customerId == 791 && SleekNote.CustomInitSettings.demoCampaignIds.some(function (includeCampaignId) {
            return includeCampaignId == r.campaignId;
          })) {
          doNotShow = false;
          debug(r.campaignId, 'Demo campaign always show');
        }
      } catch (e) {
      }
      debug(r.campaignId, 'didConditionsPass', include);
      debug(r.campaignId, 'isCorrectDomain', correctDomain);
      debug(r.campaignId, 'isSessionHidden', storage.isSessionHidden(r.campaignId));
      if (storedEmail)
        debug(r.campaignId, 'email', storedEmail);
      debug(r.campaignId, 'doNotShow', doNotShow);
      if (trigger(4, false) || trigger(5, false) || trigger(6, false)) {
        debug(r.campaignId, 'Re-eval doNotShow due to trigger type ie. html, manual, etc');
        // manual trigger specified
        if (correctDomain) {
          if (evaluator.isAnyConditions2(conf) && !include) {
            debug(r.campaignId, 'manual and ignored', true);
            // manually triggered sleeknotes that are specifically included by rules are now loaded only if rules match
            r.profile = PROFILE.IGNORE;
          } else {
            r.profile = getRenderMode(conf, ignoreRules);
          }
        } else {
          // wrong domain rejects always
          r.profile = PROFILE.IGNORE;
        }
      } else if (doNotShow) {
        r.profile = PROFILE.IGNORE;
      }
      debug(r.campaignId, 'profile', [
        'ZERO?',
        'UNKN',
        'IGNORE',
        'DESKTOP',
        'TABLET',
        'MOBILE'
      ][r.profile]);
      // that SleekNote is to be ignored, not shown at all
      if (r.profile <= PROFILE.IGNORE) {
        // band-aid 26.0.17, can i think safely removed in a year or so
        storage.cleanShowCount(r.campaignId);
        debug(r.campaignId, 'REJECTED');
        return;
      }
      //if we get a 0 in then user wants to show instantly
      var waitTime = trigger(1, undefined) === 0 ? -1 : trigger(1, 0);
      // copy over only what is needed now
      r = U.extend(r, {
        wait: storage.isSessionClosed(conf.CampaignId) ? 0 : waitTime * 1000,
        exit: storage.isSessionClosed(conf.CampaignId) ? false : trigger(3, false),
        scroll: storage.isSessionClosed(conf.CampaignId) ? false : trigger(2, 0),
        hidden: trigger(4, false),
        onClick: trigger(5, false),
        siteData: trigger(6, false),
        splitTestId: conf.SplitTestId
      });
      if (!r.wait && !r.exit && !r.scroll && !r.hidden && !r.onClick && !r.siteData) {
        var steps = r.version > 3 ? conf.steps[ix(r.profile)] : conf.steps;
        var teaserExist = Object.keys(steps).filter(function (name) {
          return steps[name].type == 'teaser';
        }).length;
        // dead box, there is no way to show that campaign
        if (!isSleekbar(getConfProp('BoxAndBarAlignment', P.POPUP, conf, r.profile)) && !teaserExist) {
          debug(r.campaignId, 'only form, no triggers REJECTED');
          return;
        }
      }
      debug(r.campaignId, 'INCLUDED');
      if (r.onClick) {
        try {
          r.onClick = JSON.parse(r.onClick);
          r.onClick.selector = (r.onClick.classes || []).reduce(function (result, obj) {
            try {
              doc.body.querySelector('.' + obj.value) && result.push('.' + obj.value);
            } catch (e) {
            }
            return result;
          }, []).concat((r.onClick.ids || []).reduce(function (result, obj) {
            try {
              doc.body.querySelector('#' + obj.value) && result.push('#' + obj.value);
            } catch (e) {
            }
            return result;
          }, [])).join(',');
          var match = r.onClick.selector && doc.body.querySelectorAll(r.onClick.selector) || [];
          if (!match.length)
            r.onClick = false;
        } catch (e) {
          r.onClick = false;
        }
        if (doNotShow) {
          //if it's not suppose to show just don't show the teaser
          r.hidden = true;
        }
      }
      if (r.siteData) {
        if (doNotShow) {
          //if it's not suppose to show just don't show the teaser
          r.hidden = true;
        }
      }
      // PP: now here we may have situation where conf.hiddenSleeknote is set to true and we have doNotShow and some exit or scroll triggers
      // MVH: If there is a manual trigger then don't do any automagical showing (SF-590)
      if (r.hidden || doNotShow) {
        // reject all triggers, if accidentally enabled
        r.wait = 0;
        r.exit = false;
        r.scroll = 0;  // otherwise, keep triggers no matter what as manual may still be useful somehow
      }
    }
    return processConfigRest(r, conf, splitTests, index);
  }
  function normalizeHttp(url) {
    return (~url.indexOf('http://') || ~url.indexOf('https://') ? '' : '//') + url;
  }
  function isSleekbar(position) {
    return U.contains(position, P.HELLO, P.HELLO2);
  }
  //	function getZet(r, t) {
  //		return U.getAdvOption(r, r.profile == PROFILE.MOBILE ? 'zindexes-mobile' : 'zindexes-desktop'), 2);
  //	}
  function processConfigRest(r, conf, splitTests, index) {
    var getProp = function (name, ifNone) {
      return getConfProp(name, ifNone, conf, r.profile);
    };
    var position = +getProp('BoxAndBarAlignment', P.POPUP);
    var placement = getProp('placement');
    if (isSleekbar(position)) {
      // notification bars to not have triggers
      r.wait = 0;
      r.exit = false;
      r.scroll = 0;
    }
    // translate old ones
    if (position == P.POPUP) {
      // split old popop into 2 separate effects
      position = r.profile == PROFILE.MOBILE ? P.SLIDEUP : P.POPUP2;
    }
    // for tablets we have just one effect now
    if (r.profile == PROFILE.TABLET && !isSleekbar(position)) {
      if (position == P.BOTTOM_LEFT) {
        position = P.POPUP7;
      } else if (position == P.BOTTOM_RIGHT) {
        position = P.POPUP9;
      } else {
        position = P.POPUP5;
      }
    }
    // if mobile and old 'desktop' positon (6,4,7,9)
    if (r.profile == PROFILE.MOBILE && (position <= P.BOTTOM_RIGHT || position == P.POPUP2)) {
      // translate old 'other' positions
      position = P.SLIDEUP;
    }
    if (r.version <= 3) {
      conf.steps = {
        form: {
          type: 'form',
          teaser: 'teaser'
        }
      };
      // old show teaser logic follows
      var showTeaser = getProp('ShowTeaser');
      // ShowTeaser must be expicitly set to 'false' to disable teaser e.g. missing property in conf means we must show teaser
      if (!showTeaser && showTeaser !== false)
        showTeaser = true;
      // disable teaser on old mobile boxes
      if (r.profile == PROFILE.MOBILE && r.version < 3)
        showTeaser = false;
      // disable teaser on old popups
      if (position == P.POPUP && r.version < 3)
        showTeaser = false;
      if (isSleekbar(position) || r.version == 1 && position == P.POPUP2) {
        showTeaser = false;
      }
      if (showTeaser)
        conf.steps.teaser = {
          type: 'teaser',
          form: 'form'
        };
      if (r.successAction == 'SuccessStep') {
        conf.steps.success = { type: 'success' };
        conf.steps.form.success = 'success';
      } else {
        if (r.successAction == 'redirect' && r.successLandingPage) {
          conf.steps.form.redirect = r.successLandingPage;
        } else {
          delete conf.steps.success;  //conf.steps.form.success = 'hideBox';
        }
      }
      delete r.successAction;
      delete r.successLandingPage;  //		} else {
                                    //			if (r.successAction != 'SuccessStep') {
                                    //				return U.filterMap(Object.keys(config), function(name) {
                                    //					if (config[name].type == type) return config[name];
                                    //				});
                                    //				delete conf.steps[ix(r.profile)].success;
                                    //			}
    }
    var tabletUsesMobile = false;
    SleekNote.tabletUsesMobile = false;
    //		// we cant anymore adjust zindex by sleeknote only and it is with high certainity not needed too
    //		// therefore we add zIndex to global settings here if any
    //		var zMax = 999999;
    //		var zIndex = zMax;
    //		if (!('zIndex' in SleekNote.CustomInitSettings)) {
    //
    //			zIndex = Math.max(Number(getZet(r,1)), Number(getZet(r,2)));
    //
    //			if (isNaN(zIndex)) zIndex = zMax;
    //		}
    //		SleekNote.CustomInitSettings.zIndex = zIndex;
    r.position = position;
    var mobile = r.profile == PROFILE.MOBILE;
    if (r.version > 3) {
      r.url = mobile ? conf.SleekNoteMobileURL : conf.SleekNoteDesktopURL;
    } else {
      if (r.version > 2 && mobile) {
        r.url = {
          toggler: conf.SleekNoteMobileURL,
          teaser: conf.SleekNoteMobileTeaserURL
        };
      } else {
        r.url = {
          toggler: conf.SleekNoteDesktopURL,
          teaser: conf.SleekNoteDesktopTeaserURL
        };
      }
    }
    var steps = r.version > 3 ? conf.steps[ix(r.profile)] : conf.steps;
    r.steps = {};
    var teaserExist = Object.keys(steps).filter(function (name) {
      return steps[name].type == 'teaser';
    }).length;
    if (r.profile == PROFILE.MOBILE && teaserExist)
      r.wait = 0;
    Object.keys(steps).forEach(function (name) {
      var step = U.extend({}, steps[name], {
        name: name,
        mobile: mobile,
        campaignId: r.campaignId,
        customerId: r.customerId,
        summaryId: r.summaryId,
        version: r.version,
        position: position,
        placement: placement,
        profile: r.profile,
        hostname: conf.Hostname,
        noteType: r.type
      });
      if (!U.empty(step.redirect) && U.typeStr(step.redirect) == 'string')
        step.redirect = normalizeHttp(step.redirect);
      if (r.version > 3) {
        step.id = '#' + U.stepId(name);
      } else {
        step.id = step.type == 'teaser' ? '#sleeknoteMinified' : step.type == 'form' ? '#sleeknoteBox' : '#sleeknoteSuccess';
      }
      if (r.version == 1) {
        switch (name) {
        case 'teaser':
          step.height1 = +conf.SleeknoteTeaserHeight;
          step.width1 = +conf.SleeknoteTeaserWidth;
          break;
        case 'form':
          step.height1 = +conf.SleeknoteBoxHeight;
          step.width1 = +conf.SleeknoteBoxWidth;
          break;
        case 'success':
          step.height1 = +conf.SleeknoteSuccessHeight;
          step.width1 = +conf.SleeknoteSuccessWidth;
          break;
        }
      }
      if (r.profile == PROFILE.TABLET && tabletUsesMobile) {
        step.relativeWidth = 1;
        // just a flag, will be calculated later
        //step.distanceFromEdge = 0;
        step.mobile = true;
      }
      if (r.profile == PROFILE.DESKTOP)
        step.relativeWidth = 0;
      if (U.contains(step.type, 'teaser')) {
        if (r.profile == PROFILE.TABLET && tabletUsesMobile) {
          if (position == P.POPUP9) {
            step.attach = 'right';
          } else if (position == P.POPUP7) {
            step.attach = 'left';
          } else {
            step.attach = 'none';
          }
        }
        if (r.profile == PROFILE.DESKTOP)
          step.relativeWidth = 0;
      }
      r.steps[name] = step;
    });
    var forms = [];
    Object.keys(r.steps).forEach(function (name) {
      // assure that we actually have all links correct
      var step = r.steps[name];
      [
        'form',
        'teaser',
        'success'
      ].forEach(function (link) {
        if (link in step) {
          if (!r.steps[step[link]])
            delete step[link];
        } else {
          // fix botched saves
          if ('form' == link && step.type == 'teaser')
            step.form = 'form';
          if ('teaser' == link && step.type == 'form' && 'teaser' in r.steps)
            step.teaser = 'teaser';
          if ('success' == link && step.type == 'form' && 'success' in r.steps)
            step.success = 'success';
        }
      });
      if (step.type == 'form') {
        forms.push(name);
      }
      step.timeZoneOffset = conf.timeZoneOffset || 0;
      // to be removed
      step.timeZone = conf.timeZone;
      step.locale = conf.locale || (win.navigator.userLanguage || win.navigator.language).split('-')[0];
    });
    // careful, in the future (very distant) this may bite, but I need to fix it now
    if (forms.length == 2) {
      // multistep where form one does not direct to form two and success is the same ( currently either 'success' or undefined in the case without success step
      if (r.steps[forms[0]].success == r.steps[forms[1]].success) {
        r.steps[forms[0]].success = forms[1];
      }
    }
    if (r.splitTestId) {
      if (!splitTests[r.splitTestId])
        splitTests[r.splitTestId] = [];
      splitTests[r.splitTestId].push(index);  // save index in config array
    }
    //		function undefAlert(o) {
    //			var t;
    //			for (var p in o) {
    //				t = U.typeStr(o[p]);
    //				if (t == 'array' || t == 'object') {
    //					undefAlert(o[p]);
    //				} else {
    //					if (o[p] === undefined) console.warn('preprocessor: undefined ', p);
    //				}
    //			}
    //		}
    //		// debug only
    //		undefAlert(r);
    return r;
  }
  return generateConfig;
}(browser, utils, evaluator, cohorts, core_common, constants, rendermode);
badge = function (B, U, CSS, SleekNote, layout, behaviour) {
  var badgeWidth = 76;
  var badgeHeight = 20;
  //		var badgeHeight = cfg.version > 1 ? 20 : 26;
  var noIFrames = SleekNote.CustomInitSettings.noIFrames;
  var logo = '<svg width="{width}px" xmlns="http://www.w3.org/2000/svg" height="{height}px"><path d="m26.514 12.038c0.175 0.339 0.489 0.544 0.851 0.639 0.345 0.089 0.702 0.091 1.053 0.042 0.16-0.025 0.31-0.069 0.451-0.137 0.14-0.068 0.256-0.159 0.35-0.276 0.202-0.255 0.193-0.689-0.045-0.92-0.305-0.298-0.767-0.417-1.167-0.513-0.254-0.061-0.511-0.127-0.771-0.2-0.268-0.067-0.528-0.149-0.782-0.247s-0.481-0.223-0.682-0.377c-0.2-0.154-0.362-0.347-0.486-0.578-0.456-0.853-0.089-1.942 0.667-2.479 0.254-0.181 0.541-0.314 0.862-0.402 0.664-0.18 1.372-0.167 2.038-0.005 0.343 0.084 0.648 0.22 0.917 0.407 0.267 0.188 0.479 0.428 0.636 0.719 0.157 0.292 0.235 0.646 0.235 1.062h-1.521c-0.014-0.215-0.059-0.393-0.136-0.534-0.077-0.14-0.179-0.251-0.306-0.331-0.126-0.081-0.271-0.139-0.435-0.171-0.297-0.062-0.619-0.073-0.917-0.011-0.126 0.027-0.242 0.074-0.346 0.141-0.103 0.066-0.189 0.15-0.255 0.251-0.13 0.195-0.145 0.521-0.02 0.724 0.053 0.088 0.158 0.168 0.315 0.241 0.157 0.074 0.373 0.147 0.651 0.222 0.277 0.073 0.64 0.167 1.087 0.281 0.133 0.026 0.319 0.075 0.556 0.146 0.236 0.07 0.473 0.183 0.706 0.337 0.234 0.154 0.437 0.36 0.606 0.618 0.357 0.544 0.322 1.331 0.065 1.905-0.126 0.281-0.315 0.524-0.566 0.729-0.25 0.205-0.561 0.364-0.931 0.478-0.771 0.239-1.657 0.231-2.434 0.024-0.371-0.096-0.699-0.25-0.982-0.456-0.285-0.209-0.51-0.473-0.677-0.795s-0.247-0.705-0.241-1.146h1.523c0 0.241 0.044 0.446 0.131 0.612m6.575-5.408h-1.422v7.178h1.422v-7.178zm2.546 5.932c-0.214-0.208-0.331-0.543-0.351-1.006h3.736c0.027-0.402-0.006-0.788-0.1-1.156-0.092-0.369-0.245-0.697-0.454-0.985-0.211-0.288-0.48-0.519-0.807-0.689-0.664-0.346-1.548-0.343-2.229-0.045-1.378 0.598-1.89 2.276-1.383 3.638 0.123 0.337 0.298 0.624 0.526 0.866 0.227 0.242 0.504 0.428 0.831 0.56 0.814 0.321 1.862 0.274 2.605-0.206 0.414-0.27 0.721-0.715 0.92-1.337h-1.25c-0.047 0.159-0.174 0.312-0.381 0.456-0.463 0.322-1.248 0.304-1.663-0.096m1.609-2.735c0.169 0.188 0.289 0.462 0.354 0.824h-2.313c0.007-0.101 0.027-0.215 0.064-0.342s0.1-0.248 0.19-0.361c0.09-0.114 0.21-0.21 0.361-0.286 0.15-0.078 0.339-0.116 0.566-0.116 0.347 0 0.607 0.094 0.778 0.281m4.065 2.735c-0.217-0.208-0.332-0.543-0.35-1.006h3.734c0.027-0.402-0.006-0.788-0.1-1.156-0.096-0.369-0.246-0.697-0.455-0.985-0.211-0.288-0.48-0.519-0.809-0.689-0.663-0.348-1.548-0.342-2.229-0.045-0.322 0.141-0.604 0.334-0.836 0.578-0.234 0.245-0.414 0.534-0.539 0.869-0.264 0.687-0.259 1.501-0.008 2.19 0.123 0.337 0.301 0.624 0.527 0.866 0.225 0.242 0.504 0.428 0.83 0.56 0.815 0.322 1.863 0.272 2.607-0.206 0.412-0.27 0.719-0.715 0.92-1.337h-1.251c-0.047 0.159-0.174 0.312-0.379 0.456-0.461 0.322-1.248 0.306-1.662-0.095m1.607-2.735c0.168 0.188 0.289 0.462 0.355 0.824h-2.312c0.004-0.101 0.025-0.215 0.062-0.342s0.1-0.248 0.189-0.361c0.092-0.114 0.213-0.21 0.361-0.286 0.15-0.078 0.338-0.116 0.566-0.116 0.349 0 0.609 0.094 0.779 0.281m2.58-3.197v7.178h1.422v-1.79l0.553-0.532 1.422 2.322h1.725l-2.174-3.287 1.953-1.91h-1.684l-1.795 1.87v-3.851h-1.422zm5.588 1.98v5.197h1.422v-2.725c0-0.529 0.088-0.909 0.26-1.141 0.324-0.427 1.24-0.522 1.555-0.03 0.133 0.211 0.199 0.532 0.199 0.961v2.935h1.424v-3.196c0-0.322-0.029-0.614-0.084-0.88-0.059-0.265-0.156-0.49-0.295-0.674-0.143-0.185-0.334-0.328-0.578-0.433-0.559-0.241-1.272-0.212-1.816 0.051-0.289 0.137-0.521 0.356-0.703 0.658h-0.029v-0.723h-1.355zm5.818 1.473c-0.263 0.702-0.265 1.556 0 2.258 0.127 0.335 0.309 0.62 0.541 0.86 0.234 0.237 0.516 0.419 0.844 0.547 0.689 0.267 1.52 0.262 2.209 0 0.33-0.128 0.611-0.31 0.846-0.547 0.234-0.24 0.414-0.525 0.543-0.86 0.262-0.704 0.26-1.553 0-2.258-0.129-0.339-0.309-0.626-0.543-0.864-0.234-0.237-0.516-0.423-0.846-0.553-0.685-0.27-1.525-0.274-2.209 0-0.328 0.13-0.609 0.315-0.844 0.553-0.232 0.238-0.414 0.526-0.541 0.864m1.295 1.739c-0.084-0.401-0.082-0.819 0-1.221 0.039-0.201 0.107-0.379 0.205-0.533 0.096-0.154 0.225-0.279 0.385-0.377 0.341-0.206 0.866-0.204 1.207 0 0.162 0.098 0.295 0.223 0.391 0.377s0.166 0.332 0.205 0.533c0.082 0.401 0.084 0.819 0 1.221-0.039 0.198-0.109 0.376-0.205 0.534-0.096 0.157-0.229 0.282-0.391 0.377-0.345 0.195-0.862 0.197-1.207 0-0.16-0.095-0.289-0.22-0.385-0.377-0.097-0.158-0.166-0.335-0.205-0.534m6.397-3.212v-1.557h-1.422v1.557h-0.861v0.955h0.861v3.065c0 0.263 0.045 0.474 0.131 0.636 0.086 0.16 0.205 0.283 0.355 0.371 0.15 0.089 0.324 0.146 0.521 0.177 0.351 0.05 0.704 0.048 1.057 0.034 0.146-0.007 0.281-0.02 0.4-0.04v-1.106c-0.066 0.016-0.137 0.023-0.209 0.031-0.213 0.017-0.545 0.055-0.715-0.111-0.078-0.082-0.119-0.241-0.119-0.483v-2.574h1.043v-0.955h-1.042zm3.094 3.952c-0.215-0.208-0.334-0.543-0.352-1.006h3.736c0.027-0.402-0.006-0.788-0.1-1.156-0.096-0.369-0.248-0.697-0.455-0.985-0.211-0.288-0.48-0.519-0.809-0.689-0.663-0.347-1.546-0.342-2.227-0.045-1.378 0.598-1.894 2.276-1.383 3.638 0.123 0.337 0.297 0.624 0.525 0.866 0.227 0.242 0.504 0.428 0.83 0.56 0.815 0.32 1.861 0.274 2.605-0.206 0.412-0.27 0.723-0.715 0.922-1.337h-1.254c-0.045 0.159-0.172 0.312-0.379 0.456-0.458 0.321-1.245 0.305-1.659-0.096m1.607-2.735c0.17 0.188 0.289 0.462 0.355 0.824h-2.314c0.006-0.101 0.027-0.215 0.064-0.342s0.1-0.248 0.189-0.361c0.09-0.114 0.211-0.21 0.361-0.286 0.15-0.078 0.338-0.116 0.566-0.116 0.347 0 0.609 0.094 0.779 0.281" fill="#464647"/><path d="m15.895 4.941h-5.643c-2.789 0-5.049 2.269-5.049 5.059 0 2.791 2.26 5.059 5.049 5.059h10.733v-5.141c-0.001-2.79-2.303-4.977-5.09-4.977m-0.446 8.995h-4.751c-2.351 0-4.256-1.775-4.256-3.936s1.905-3.935 4.256-3.935h4.751c2.351 0 4.256 1.721 4.256 3.882 0 1.07-0.466 2.074-1.223 2.781-0.773 0.72-1.846 1.208-3.033 1.208m-0.41-1.877c0 0.504-0.409 0.913-0.911 0.913-0.503 0-0.912-0.409-0.912-0.913 0-0.028 0.001-0.058 0.005-0.086l-1.57-1.13c-0.11 0.048-0.232 0.074-0.36 0.074-0.503 0-0.912-0.408-0.912-0.911 0-0.504 0.408-0.912 0.912-0.912 0.104 0 0.204 0.018 0.297 0.051l1.635-1.209c-0.005-0.036-0.008-0.07-0.008-0.106 0-0.504 0.408-0.912 0.911-0.912s0.911 0.409 0.911 0.912c0 0.504-0.408 0.912-0.911 0.912-0.114 0-0.223-0.021-0.324-0.061l-1.612 1.193c0.006 0.043 0.01 0.087 0.01 0.133 0 0.021-0.001 0.043-0.003 0.065l1.585 1.144c0.106-0.044 0.222-0.067 0.343-0.067 0.505-0.003 0.914 0.408 0.914 0.91z" fill="#464647"/></svg>';
  var href = '//sleeknote.com/?utm_source=Badge&utm_medium={medium}&utm_campaign={hostname}';
  var html = '<style>* {padding:0;margin:0} .sleeknote-badge {opacity:0.5;display:block;background-color:white;z-ndex:1000000;width:{width}px;height:{height}px;} .sleeknote-badge:hover {opacity:1}</style><body><a href="{href}" target="_blank" rel=noopener class="sleeknote-badge">{svg}<a>';
  var noIFramesHtml = '<style>.sleeknote-badge {opacity:0.5;display:block;background-color:white;z-ndex:1000000;width:{width}px;height:{height}px;} .sleeknote-badge:hover {opacity:1}</style><a href="{href}" target="_blank" rel=noopener class="sleeknote-badge">{svg}<a>';
  function Badge(target, manager) {
    this.manager = manager;
    this.config = behaviour.defaults('badge', {
      profile: manager.profile,
      width: badgeWidth,
      height: badgeHeight
    });
    layout.insert({
      what: 'badge',
      config: this.config,
      id: 'sleeknote-badge',
      onload: function (wrapNode) {
        this.config.DOMNode = wrapNode;
      }.bind(this)
    });
  }
  Badge.prototype = {
    dimensions: function () {
      return this.config;
    },
    remove: function () {
      if (this.config.DOMNode)
        U.removeNode(this.config.DOMNode);
    },
    setLayout: function () {
      if (!layout.doc(this.config.DOMNode))
        return;
      var scale = layout.getFrameScale();
      CSS.set(layout.doc(this.config.DOMNode).documentElement, {
        position: 'relative',
        top: 0,
        left: 0,
        height: 100 / scale + '%',
        transform: 'scale(' + scale + ')',
        transformOrigin: [
          0,
          0
        ],
        width: 100 / scale + '%'
      });
    },
    reposition: function (config) {
      var next = behaviour.needs.badge(config) ? 'open' : 'close';
      layout.css(this.config, 'DOMNode', layout.createPositionStyles(behaviour.boxParameters(this, next), 'to'));
      this.setLayout();
      this.config.current = next;
    },
    createHTML: function () {
      var doc = layout.doc(this.config.DOMNode);
      var node = doc.documentElement || doc;
      node.innerHTML = U.template(noIFrames ? noIFramesHtml : html, {
        width: this.config.width,
        height: this.config.height,
        href: U.template(href, {
          medium: this.config.type,
          hostname: this.config.hostname
        }),
        svg: U.template(logo, this.config)
      });
    },
    mergeConfigs: function (note) {
      if (!note)
        return;
      this.config.campaignId = note.config.campaignId;
      this.config.noteType = note.config.noteType;
      this.config.position = note.config.position;
    },
    prepare: function (to, note) {
      // no waiting specifically on badge DOM: 1. it should be created when any note is ready by far 2. no harm if we miss one badge
      if (!this.config.DOMNode)
        return;
      var from = this.config.current;
      //console.log('badge', from, '->', to);
      this.mergeConfigs(note);
      if (to == from) {
        if (this.config.current == 'open') {
          // we need to update
          this.createHTML();
        }
        return;
      }
      //this.insert();
      if (from == 'close') {
        this.createHTML();
      }
      this.config.next = to;
      this.params = behaviour.animationParameters(this, from, to);
      return layout.createMotion(this.params, function (styles, first, last) {
        if (first) {
          this.setLayout();
        }
        layout.css(this.config, 'DOMNode', styles);
        if (last) {
          this.config.current = this.config.next;
        }
      }.bind(this));
    }
  };
  return Badge;
}(browser, utils, css, core_common, layout2, behaviour);
cover_screen = function (B, U, CSS, layout, click, SleekNote, behaviour) {
  var noIFrames = SleekNote.CustomInitSettings.noIFrames;
  function Cover(target, manager) {
    this.manager = manager;
    this.config = behaviour.defaults('cover', { profile: manager.profile });
    this.status = 0;
    this.andThen = [];
  }
  Cover.prototype = {
    dimensions: function () {
      this.config.width = [101 / layout.getFrameScale() + 'vw'];
      this.config.height = [101 / layout.getFrameScale() + 'vh'];
      return this.config;
    },
    insert: function (next) {
      //console.log('insert', this.status);
      if (this.status == 0) {
        this.status = 1;
        this.removeListener = function () {
        };
        this.andThen.push(next);
        layout.insert({
          what: 'cover',
          config: this.config,
          id: 'sleeknote-cover',
          content: noIFrames ? '<div style="height:100vh; cursor:pointer;background:radial-gradient(ellipse at center, rgba(0,0,0,0.1) 40%,rgba(0,0,0,0.6) 100%); pointer-events:auto!important"></div>' : '<style>html{cursor:pointer;background:radial-gradient(ellipse at center, rgba(0,0,0,0.1) 40%,rgba(0,0,0,0.6) 100%)}body:{margin:0}</style><div style="height:100vh" onclick="void(0)"></div>',
          style: { cursor: 'pointer' },
          onload: function (wrapNode) {
            this.status = 2;
            var next;
            while (next = this.andThen.pop())
              next();
            this.config.DOMNode = wrapNode;
            this.removeListener = click.listen(noIFrames ? this.config.DOMNode.firstElementChild : layout.doc(this.config.DOMNode), this.onClick.bind(this));
          }.bind(this)
        });
      } else if (this.status == 1) {
        this.andThen.push(next);
      } else {
        next();
      }
    },
    remove: function () {
      if (this.config.DOMNode) {
        this.removeListener();
        U.removeNode(this.config.DOMNode);
      }
    },
    onClick: function (event) {
      var top = this.manager.showQueue.stopper;
      if (!top)
        return;
      var note = top.controller.notes[top.noteName];
      var closeButton = note.doc.querySelectorAll('[data-sn-type=close], .sleeknoteMobileClose')[0];
      if (closeButton)
        note.onClick(event, closeButton);
    },
    after: function () {
      if (this.config.DOMNode && this.config.current == 'close')
        CSS.conceal(this.config.DOMNode);
    },
    reposition: function (config, pos) {
      if (!this.config.DOMNode) {
        return;
      }
      var next = behaviour.needs.cover(config) ? 'open' : 'close';
      layout.css(this.config, 'DOMNode', layout.createPositionStyles(behaviour.boxParameters(this, next), 'to'));
      this.config.current = next;
      this.after();
    },
    prepare: function (to, note) {
      var from = this.config.current;
      if (!this.config.DOMNode || to == from) {
        return;
      }
      this.config.next = to;
      this.params = behaviour.animationParameters(this, from, to);
      this.params.width;
      return layout.createMotion(this.params, function (styles, first, last) {
        layout.css(this.config, 'DOMNode', styles);
        if (last) {
          this.config.current = this.config.next;
          if (this.config.current == 'close')
            CSS.conceal(this.config.DOMNode);
        }
      }.bind(this));
    }
  };
  return Cover;
}(browser, utils, css, layout2, click, core_common, behaviour);
rrhandler = function (B, U) {
  var win = this;
  var devicePixelRatio = win.devicePixelRatio;
  var throttleDuringResize = true;
  var throttleInterval = 200;
  function RRHandler(options) {
    var self = this, name, resizeHandler = function (event) {
        self.resize.call(self, event);
      };
    this.first = true;
    this.win = win;
    this.setBody = this.win == this.win.top;
    options = options || {};
    for (name in options)
      if (options.hasOwnProperty(name))
        this[name] = options[name];
    undefined !== options.throttleDuringResize && (throttleDuringResize = options.throttleDuringResize);
    undefined !== options.throttleInterval && (throttleInterval = options.throttleInterval);
    this.body = this.win.document.body;
    // there's no reason to set body minHeight on desktop
    B.is.desktop && (this.setBody = false);
    // save initial orientation
    this.initial = {
      orientation: this.getOrientation(),
      width: this.win.innerWidth
    };
    this.win.addEventListener('onorientationchange' in win ? 'orientationchange' : 'resize', function () {
      if (!B.is.desktop) {
        // on touch devices no need to throttle
        return resizeHandler;
      } else {
        return U.throttle(throttleInterval, resizeHandler, self, false, !throttleDuringResize);
      }
    }(), false);
    this.resize();
  }
  RRHandler.prototype = {
    getOrientation: function () {
      return undefined !== win.orientation ? win.orientation % 180 === 0 ? 'portrait' : 'landscape' : this.win.innerWidth < this.win.innerHeight ? 'portrait' : 'landscape';
    },
    resize: function (event) {
      var orientation = this.getOrientation();
      var i = 0;
      var pull = function () {
        // have a safety net, don't pull forever
        i++;
        // pull until you can confirm that width is changed
        if (i > 100 || this.initial.orientation === orientation && this.initial.width === this.win.innerWidth || this.initial.orientation !== orientation && this.initial.width !== this.win.innerWidth) {
          // orientation changed, DOM updated
          if (this.setBody) {
            this.body.style.minHeight = (B.is.android ? win.outerHeight / devicePixelRatio : win.innerHeight) + 'px';
          }
          this.callback && this.callback.call(this.context || this.win, this.first, orientation, event);
          this.first = false;
        } else {
          win.setTimeout(pull, 50);
        }
      }.bind(this);
      // secure yourself from IE quirks
      if (!this.body)
        return;
      // set safe body height before you try to scroll addressbar out of sight, be sure you CAN scroll at all
      if (this.setBody) {
        if (B.is.android) {
          this.body.offsetHeight < win.outerHeight / devicePixelRatio && (this.body.style.minHeight = win.outerHeight / devicePixelRatio + 'px');
        } else if (B.is.ios) {
          this.body.offsetHeight < win.screen.availHeight && (this.body.style.minHeight = win.screen.availHeight + 'px');
        }
      }
      win.setTimeout(function () {
        0 === this.body.scrollTop && (this.body.scrollTop = B.is.android ? 1 : 0);
        pull();  // it is good to give browser a little moment to breath and get the act together, especially on Android
      }.bind(this), 100);
    }
  };
  return RRHandler;
}(browser, utils);
notes_manager = function (B, U, CSS, NoteController, ShowQueue, Location, Tracker, preprocessor, SleekNote, CONST, Badge, Cover, StorageCache, emit, SiteData, behaviour, RRHandler, getRenderMode) {
  var win = this;
  var doc;
  var noIFrames = SleekNote.CustomInitSettings.noIFrames;
  function custom(prop) {
    return SleekNote.CustomInitSettings && SleekNote.CustomInitSettings[prop];
  }
  var debug = SleekNote.debugMessage('n');
  var lastTime;
  function each(obj, callback, context) {
    var i;
    var o;
    for (i in obj)
      if (obj.hasOwnProperty(i)) {
        o = obj[i];
        if (callback.call(context || o, o, i) === false) {
          break;
        }
      }
  }
  var ctx;
  function NotesManager(arr, context, editorVersion) {
    this.editor = !!context;
    this.editorVersion = editorVersion || 2;
    ctx = context || win;
    doc = ctx.document;
    this.context = ctx;
    this.name = 'NotesManager';
    this.controllers = {};
    this.stylesheets = {};
    this.noteImages = [];
    this.rawConfig = arr;
    //this.emulate = false;
    if (this.editor || SleekNote.local) {
      ctx.notesManager = this;
    }
    if (this.editor) {
      this.tracker = new Tracker();
      this.storage = StorageCache.create({
        useLocalStorage: true,
        dummyStorage: true
      });
      // 			this.idle = function () {
      // 				return true;
      // 			};
      this.showQueue = new ShowQueue(this);
      this.addSleekNotes(true);
      // this is now only connection to editor
      this.cover = new Cover(doc.body, this);
      if (this.editorVersion < 4) {
        U.listener(doc, 'add', function (e) {
          U.mouseEvent(ctx.top.document, e);
        }, true)('mousemove')('mousedown')('mouseup');
      }
      return;
    }
    // 		this.idle = this.idle.bind(this);
    this.showQueue = new ShowQueue(this);
    /*
    		//PP: add only if we have exit triggers
    		var lastY = 11;
    
    		// some Windows IE variants return wrong coordinates on mouseout, therefore i listen them in mousemove
    		// this is light enough
    		U.listener(doc, 'add', function (event) {
    			lastY = event.clientY;
    			//console.log(lastY);
    		})('mousemove');
    
    		U.listener(
    			doc.documentElement,
    			'add',
    			function (event) {
    				if (!event.relatedTarget && lastY < 10) {
    					each(
    						this.controllers,
    						function (controller, campaignId) {
    							//TODO AB - step type set in editor
    							if (controller.ifTrigger('exit') && controller.canBeLaunched()) this.showQueue.now(controller, 'open', 'form');
    						},
    						this
    					);
    				}
    			}.bind(this),
    			true
    		)('mouseout');
    		// Always pull from win.Sleeknote.editor vs Sleeknote.editor because the html could have been
    		// updated on template change
    */
    /*
    		var scrollTimeout;
    		var scrollFunc = function () {
    			lastTime = 0;
    			each(
    				this.controllers,
    				function (controller, id) {
    					//TODO AB - step type set in editor
    					if (controller.ifTrigger('scroll') && controller.canBeLaunched()) this.showQueue.push(controller, 'open', 'form');
    				},
    				this
    			);
    		}.bind(this);
    
    		function scrollListener(event) {
    			var now = +new Date();
    			if (lastTime && now - lastTime < 1000) {
    				// not enough lasted from previous, be as gentle as possible, return
    				// dont clear and set timout on every event
    			} else {
    				win.clearTimeout(scrollTimeout);
    				scrollTimeout = win.setTimeout(scrollFunc, 2000);
    				lastTime = now;
    			}
    		}
    
    		//PP: add only if we have scroll triggers
    		U.listener(ctx, 'add', scrollListener, true)('scroll');
    */
    this.historyListener;
    this.hashListener;
    this.urlPollerInterval;
    this.lastLocation = String(Location.get(SleekNote));
    this.triggerOnClick = this.triggerOnClick.bind(this);
    this.pollerFunc = function () {
      var loc = Location.reset(SleekNote);
      if (!loc.matches(this.lastLocation)) {
        this.resetSleekNotes();
        this.lastLocation = String(loc);
      }
    }.bind(this);
    //PP: add only if we have popups
    this.cover = new Cover(doc.body, this);
    this.tracker = new Tracker(SleekNote.CustomerId);
    this.storage = StorageCache.create(SleekNote.storageOptions);
    this.siteData = new SiteData(this);
    this.rrhandler = new RRHandler({
      throttleDuringResize: false,
      throttleInterval: 300,
      callback: this.onresize,
      context: this
    });
    //Referrer
    var referrerHost = U.cleanUpReferral(doc.referrer);
    if (!this.storage.getReferral() && referrerHost.indexOf(Location.get(SleekNote).host) < 0) {
      this.storage.setReferral(referrerHost);
    }
    if (U.getQueryVarByName('SNSubscribed') == 'true') {
      this.storage.setSubscription();
    }
    if ((SleekNote.local || SleekNote.reset) && Array.isArray(this.rawConfig)) {
      if (SleekNote.reset != 'n')
        this.storage.forceResetSession(SleekNote.reset);
    }
    if (this.rawConfig && ctx.ADDWISH_PARTNER_NS) {
      this.rawConfig.forEach(function (config) {
        var email = this.storage.getEmail(config.CampaignId);
        if (email) {
          try {
            ctx.ADDWISH_PARTNER_NS.regEmail(email);
          } catch (e) {
          }
          //after send clear and expire the field
          this.storage.setEmail(config.CampaignId, '', -1);
        }
      }, this);
    }
    var hideBadge = SleekNote.HideSleeknoteBadge;
    if (hideBadge === undefined)
      hideBadge = true;
    if (!hideBadge && SleekNote.CustomerId >= 790) {
      //PP:
      this.badge = new Badge(doc.body, this);
    }
    this.addSleekNotes(SleekNote.reset > 1);
    // keep the API function unbound, so that customer can bind it if needed
    var me = this;
    emit('load', function (operation) {
      //if (!U.contains(operation, 'reset', 'close', 'trigger', 'open', 'reveal', 'maximize', 'minimize')) {
      if (!U.contains(operation, 'reset', 'close', 'launch', 'open', 'status', 'add')) {
        console.warn('Unsupported Sleeknote API call');
      }
      if (operation == 'status') {
        var id;
        var entry;
        var res = {
          campaigns: {},
          visible: {}
        };
        for (id in me.controllers) {
          res.campaigns[id] = { campaignId: id };
        }
        for (id in me.showQueue.visibles) {
          entry = me.showQueue.visibles[id];
          res.visible[id] = {
            campaignId: id,
            name: entry.noteName
          };
        }
        return res;
      }
      try {
        return !!me.command.apply(me, arguments);
      } catch (e) {
        console.warn('Error calling Sleeknote API', e);
      }
    });
  }
  NotesManager.prototype = {
    get busy() {
      return this.showQueue.busy;
    },
    onresize: function (first, orientation, event) {
      //console.log('rr', first, orientation, event);
      this.command('visibleNotes').forEach(function (note) {
        note.onWindowResize(first, orientation, event);
      });
    },
    addExitListener: function () {
      if (!B.is.desktop)
        return;
      //PP: add only if we have exit triggers
      var lastY = 11;
      // some Windows IE variants return wrong coordinates on mouseout, therefore i listen them in mousemove
      // this is light enough
      U.listener(doc, 'add', function (event) {
        lastY = event.clientY;  //console.log(lastY);
      })('mousemove');
      U.listener(doc.documentElement, 'add', function (event) {
        if (!event.relatedTarget && lastY < 10) {
          each(this.controllers, function (controller, campaignId) {
            //TODO AB - step type set in editor
            if (controller.ifTrigger('exit') && controller.canBeLaunched())
              this.showQueue.now(controller, 'open', 'form');
          }, this);
        }
      }.bind(this), true)('mouseout');
      this.addExitListener = function () {
      };
    },
    addScrollListener: function () {
      var scrollTimeout;
      var scrollFunc = function () {
        lastTime = 0;
        each(this.controllers, function (controller, id) {
          //TODO AB - step type set in editor
          if (controller.ifTrigger('scroll') && controller.canBeLaunched())
            this.showQueue.push(controller, 'open', 'form');
        }, this);
      }.bind(this);
      function scrollListener(event) {
        var now = +new Date();
        if (lastTime && now - lastTime < 1000) {
        } else {
          win.clearTimeout(scrollTimeout);
          scrollTimeout = win.setTimeout(scrollFunc, 2000);
          lastTime = now;
        }
      }
      U.listener(ctx, 'add', scrollListener, true)('scroll');
      this.addScrollListener = function () {
      };
    },
    // 		idle: function (nextcontroller) {
    // 			if (!U.isEqual(B.getDocumentScale(SleekNote.CustomInitSettings.isRealMobileSite), 1, 0.1)) return;
    // 			if (B.isAddressBarVisible()) return;
    // 			if (lastTime) {
    // 				// scrolling continues
    // 				if (nextcontroller) {
    // 					// no need to wait if not fullscreen
    // 					if (nextcontroller.fullScreen) return;
    // 				} else {
    // 					return;
    // 				}
    // 			}
    // 			return true;
    // 		},
    // 		onVisible: function () {},
    // 		onReady: function () {},
    // 		onEvent: function () {},
    message: function (data) {
      var d = {};
      var p;
      for (p in data)
        if (data.hasOwnProperty(p)) {
          if (p == 'origin') {
            d.origin = data.origin.name;
          } else if (p == 'next') {
            continue;
          } else {
            d[p] = data[p];
          }
        }
      debug(JSON.stringify(d));
      switch (data.type) {
      case 'after':
        //TODO AB - step type set in editor
        if (data.action == 'open' && data.noteName == 'form')
          this.onTogglerShow(data);
        break;
      case 'aftersubmit':
        this.onSubmit(data);
        break;
      case 'trackerCustomEvent':
        // guard against external crashes
        try {
          var datalayer = ctx.dataLayer || ctx[SleekNote.CustomInitSettings.googleDataLayerObjectName];
          if (Array.isArray(datalayer)) {
            datalayer.push(U.extend(data.CustomEventData));
          }
          var fbData = U.extend(data.CustomEventData);
          //Can't send field data to fb #privacy
          if (fbData.fieldData) {
            delete fbData.fieldData;
          }
          delete fbData.SignupPage;
          var fbq = ctx.fbq || ctx[SleekNote.CustomInitSettings.fbqDataLayerObjectName];
          if (U.isFunction(fbq)) {
            fbq('trackCustom', data.CustomEventData.event, fbData);
          }
        } catch (e) {
          console.warn(e);
        }
        break;
      case 'ready':
        if (data.origin.name == 'NoteController') {
          if (this.editor) {
            try {
              SleekNote.editor.event('CORE.NOTES_READY', SleekNote.editor.profile);
            } catch (e) {
              this.onReady(data.origin);
            }
          } else {
            win.setTimeout(function () {
              this.onControllerReady(data.origin);
              emit('ready', data);
            }.bind(this), 0);
          }
        }
        break;
      case 'close':
        this.onClose(data);
        this.userInteraction(data);
        break;
      case 'step':
        this.onStepChange(data);
        this.userInteraction(data);
        break;
      case 'trackevent':
        this.trackEvent(data);
        break;
      case 'open':
      case 'maximize':
      case 'minimize':
        this.userInteraction(data);
        break;
      }
    },
    onTogglerShow: function (data) {
      if (this.editor)
        return;
      // it is usually Note
      var controller = data.origin instanceof NoteController ? data.origin : data.origin.controller;
      this.storage.incrementShowCount(controller.id);
      this.storage.closeSession(controller.id);
      CONST.PROFILE.MOBILE == controller.config.profile && !controller.isHello && this.storage.hideSession(controller.id);
      this.tracker.shown(controller.config);
    },
    onSubmit: function (data) {
      if (this.storage) {
        // it is usually Note
        var controller = data.origin instanceof NoteController ? data.origin : data.origin.controller;
        data.email && this.storage.setEmail(controller.id, data.email);
        data.setShown && this.storage.setShowCount(controller.id, 999999);
        data.setSubscription && this.storage.setSubscription();
        data.setEngaged && this.storage.setEngaged(controller.id);
        var noteType = controller.type || controller.config.type;
        var convertSession = this.storage.hasConvertSessionEvent(controller.id);
        if (!U.contains(noteType, 'promote', 'guide') && data.isUserDefinedClick || U.contains(noteType, 'promote', 'guide') && this.storage.hasConvertSessionEvent(controller.id) && data.mimirEvent  // if promote then only want to track one convert event if it exists
) {
          debug('trackEventSkip', data.source, noteType, this.storage.hasConvertSessionEvent(controller.id), data.mimirEvent);
          if (data.next)
            this.userInteraction(data.next);
          return;
        }
        //If the session has already been converted then it's a substep engage vs standard engage
        if (convertSession && controller.getType('form').length > 1)
          data.mimirEvent = 'substep_engaged';
        data.customTrackerEvent && this.tracker.customTrackerEvent(data.customTrackerEvent, controller.id);
        data.mimirEvent && this.tracker.event(data.mimirEvent, controller.config, data.callback);
        //need to track whether we've sent a convert event
        data.mimirEvent && this.storage.convertSessionEvent(controller.id);
      }
      if (data.next)
        this.userInteraction(data.next);
    },
    onClose: function (data) {
      // it is usually Note
      var controller = data.origin instanceof NoteController ? data.origin : data.origin.controller;
      this.tracker.event(data.noteName == 'teaser' ? 'teaser_closed' : 'closed', controller.config, data.callback);
    },
    onStepChange: function (data) {
      //all submits have thier links automatically passed so don't need to do it seperate
      if (data.isUserDefinedClick) {
        // isSuccessStep is always falsy
        var controller = data.origin instanceof NoteController ? data.origin : data.origin.controller;
        this.tracker.event('link_clicked', controller.config, data.callback);
      }
    },
    trackEvent: function (data) {
      var controller = data.origin instanceof NoteController ? data.origin : data.origin.controller;
      this.tracker.event(data.eventName || 'no_event_defined', controller.config, data.callback);
      if (!data.eventName) {
        debug('no event name', data);
      }
    },
    userInteraction: function (data) {
      // it is usually Note
      var controller = data.origin instanceof NoteController ? data.origin : data.origin.controller;
      // on all user interactions, turn smartIndex off
      controller.config.smartIndex = 0;
      switch (data.type) {
      case 'step':
        //this[data.step] && this[data.step](controller.id);
        if (data.step == 'hideBox') {
          this.command('close', controller.id);
        } else {
          this.command('reveal', controller.id, data.step);
        }
        break;
      case 'open':
        this.showQueue.now(controller, 'open', data.noteName);
        controller.tameTriggers();
        break;
      case 'close':
        if (U.contains(data.origin.config.type, 'teaser', 'form')) {
          //this.storage.incrementShowCount(controller.id); // decided we don't need this anymore https://www.notion.so/sleeknote/Show-Count-and-Session-Show-Count-6c438e6b0c3c4d068dcd6f86c4ca377e
          this.storage.hideSession(controller.id);
          if (data.origin.config.type == 'teaser')
            controller.tameTeaser();
        }
        this.showQueue.closeIf(controller);
        break;
      case 'maximize':
      case 'minimize':
        this.command(data.type, controller.id, data.noteName);
        break;
      }
    },
    // window.notesManager.applyConfig('cc5eef9b-7066-4e1b-b33f-207d4f3fa3bd', {BoxAndBarAlignment: [5, 7]} /*,'teaser' */);
    // window.notesManager.applyConfig('cc5eef9b-7066-4e1b-b33f-207d4f3fa3bd', {BoxAndBarAlignment: [5, 7]});
    applyConfig: function (id, sourceConfig, stepName) {
      var controller = this.controllers[id];
      if (!controller)
        return;
      var steps = stepName ? [stepName] : Object.keys(controller.notes);
      // find existing
      var oldConfig = this.rawConfig.filter(function (c) {
        return c.CampaignId == id;
      });
      var processedConfig = preprocessor([U.extend(oldConfig[0], sourceConfig)], this.storage, true)[0];
      if (!processedConfig)
        return;
      steps.forEach(function (name) {
        controller.notes[name].applyConfig(processedConfig[name]);
      }, this);
      this.showQueue.repositionIf(controller);
    },
    addSleekNotes: function (ignore, sourceConfig, justAdd) {
      sourceConfig || (sourceConfig = this.rawConfig);
      var config = preprocessor(sourceConfig, this.storage, ignore) || [];
      // empty it on every case, for onepage logic to work, except if justAdd
      if (justAdd) {
        Array.isArray(this.prioritizedConfig) || (this.prioritizedConfig = []);
      } else {
        this.prioritizedConfig = [];
      }
      if (this.editor)
        this.prioritizedConfig = config;
      if (!this.editor && config.length > 0) {
        if (!this.mode) {
          this.mode = CONST.PROFILE.MOBILE == config[0].profile ? 'sequential' : custom('notamanagermode') || 'concurrent';
        }
        config.sort(function (a, b) {
          var aPriority = +U.getAdvOption({ options: a.options }, 'note-priority', 1) || 0;
          var bPriority = +U.getAdvOption({ options: b.options }, 'note-priority', 1) || 0;
          return bPriority - aPriority;
        });
        var includedPositions = [];
        var exitPosition = -1;
        var news = config.filter(function (conf) {
          // include first one per position
          // if exit intent, then include it always, in case position is taken, then remove teaser
          // apply pseudo position fox exit intent
          // include hidden/manual trigger ones always
          if (!conf.hidden) {
            var position = conf.position;
            if (~includedPositions.indexOf(position)) {
              //position taken but always want onClicks to work so just delete teaser
              if (conf.onClick) {
                conf.steps && delete conf.steps.teaser;
                return conf;
              }
              // position taken, check for exit
              if (conf.exit && includedPositions.indexOf(exitPosition) < 0) {
                position = exitPosition;
                conf.steps && delete conf.steps.teaser;
              } else {
                return;
              }
            } else {
              // if this one has exit and NO teaser, then we can have another on same position
              // have to look for teaser in two different locations because of new version
              if (conf.exit && conf.steps && !conf.steps.teaser) {
                position = exitPosition;
              }
            }
            includedPositions.push(position);
          }
          return conf;
        });
        var olds = this.prioritizedConfig.map(function (cfg) {
          return cfg.campaignId;
        });
        news.forEach(function (cfg) {
          if (~olds.indexOf(cfg.campaignId))
            return;
          this.prioritizedConfig.push(cfg);
        }, this);
        if (!justAdd) {
          this.prioritizedConfig.sort(function (a, b) {
            // this is rare case where return is not falsy
            function compare(p) {
              if (a[p] && b[p])
                return a[p] - b[p];
              if (b[p])
                return 1;
              if (a[p])
                return -1;
            }
            var r;
            r = compare('scroll');
            if (r !== undefined)
              return r;
            r = compare('wait');
            if (r !== undefined)
              return r;
            r = compare('exit');
            if (r !== undefined)
              return r;
            return 0;
          });
        }
      }
      var l = this.prioritizedConfig.length;
      while (l--) {
        this.createController(this.prioritizedConfig[l]);
      }
      // start looking for one page config ... we need to look in sourceConfig because even if
      // a config is not initailly selected it maybe in the future
      // but onepage is defined at the note config level not global so we have to loop through them all
      if (!this.editor) {
        sourceConfig.forEach(function (noteConfig) {
          if (!this.urlPollerInterval && U.getAdvOption({ options: noteConfig.advOptions }, 'onepagesite', 1)) {
            this.urlPollerInterval = win.setInterval(this.pollerFunc, 1000);
          }
        }, this);
      }
      // remove old ones
      if (!justAdd)
        this.destroyControllersNotPresent(this.prioritizedConfig);
    },
    createController: function (config) {
      var id = config.campaignId;
      if (id in this.controllers)
        return;
      this.assureStylesheet(config.version, function () {
        if (!this.controllers[config.campaignId]) {
          //console.log('creating controller');
          this.controllers[id] = new NoteController(this, config);
        }
      }.bind(this));
    },
    resetSleekNotes: function (ignoreRules, config) {
      //console.log(config);
      this.addSleekNotes(ignoreRules, config);
      this.showQueue.reset(Object.keys(this.controllers));
    },
    launchController: function (controller) {
      //console.log('launchController');
      if (controller.config.exit)
        this.addExitListener();
      if (controller.config.scroll)
        this.addScrollListener();
      if (controller.teaserExist && !controller.config.hidden && controller.canBeLaunched()) {
        this.showQueue.push(controller, 'open', controller.getType('teaser')[0].config.name);
      }
      controller.launchTriggers(function (type, controller) {
        //TODO AB - step type set in editor
        if ((type == 'timer' || type == 'notification') && controller.canBeLaunched()) {
          this.showQueue.push(controller, 'open', controller.getType('form')[0].config.name, true);
        }
      }.bind(this));
    },
    getBase: function () {
      var base = '';
      if (this.editor) {
        var topBase = win.top.document.querySelector('base');
        //!!
        if (topBase)
          base = topBase.href;
      } else {
        if (!SleekNote.local)
          base = '//sleeknotestaticcontent.' + (SleekNote.branch ? 's3-eu-west-1.amazonaws.com/' : 'sleeknote.com/');
      }
      return base;
    },
    assureStylesheet: function (version, next) {
      function done(ss, styles) {
        ss.status = 2;
        ss.sheet = '<style data-name="' + ss.name + '">' + styles + '</style>';
        if (noIFrames && !U.qs('style[data-name="' + ss.name + '"]', doc)) {
          doc.head.insertAdjacentHTML('beforeend', ss.sheet);
        }
        var next;
        while (next = ss.andThen.pop())
          next();
      }
      var editorVersion = this.editorVersion;
      if (editorVersion == 4)
        return next();
      if (this.editor) {
        version = 4;
      }
      if (!this.stylesheets[version]) {
        var name = 'sleeknote' + (noIFrames ? 'nif' : version > 2 ? version : '');
        var href;
        if (SleekNote.branch) {
          href = SleekNote.path + name + '-' + SleekNote.branch + '.css';
        } else {
          var base = this.getBase();
          if (this.editor && !SleekNote.local && base)
            base = '//sncampaigneditor.sleeknote.com/';
          href = base + name + SleekNote.appendToFile + '.css';
        }
        this.stylesheets[version] = {
          name: name,
          href: href + SleekNote.timestamp,
          status: 0,
          andThen: [],
          sheet: ''
        };
      }
      var ss = this.stylesheets[version];
      //console.log('assureStylesheet', version, ss.status);
      if (ss.status == 0) {
        ss.status = 1;
        if (this.editor) {
          win.Promise.all([
            win.fetch(ss.href).then(function (response) {
              return response.text();
            }),
            win.fetch(ss.href.replace(name, 'sleeknote-editor' + editorVersion)).then(function (response) {
              return response.text();
            }),
            win.fetch(ss.href.replace(name, 'productrec')).then(function (response) {
              return response.text();
            })
          ]).then(function (styles) {
            done(ss, styles.join(' \n '));
          });
        } else {
          U.fetch(ss.href, function (request) {
            done(ss, request.responseText);
          });
        }
        ss.andThen.push(next);
      } else if (ss.status == 1) {
        ss.andThen.push(next);
      } else {
        next();
      }
    },
    onControllerReady: function () {
      var id;
      var top;
      if (this.immediate) {
        this.triggerOnClick(this.immediate);
        this.immediate = undefined;
        this.prioritizedConfig = [];
        return;
      }
      if (this.prioritizedConfig.length) {
        do {
          // start from top and push to queue those that are ready
          id = this.prioritizedConfig[0].campaignId;
          top = this.controllers[id];
          if (top && top.config.ready) {
            if (behaviour.needs.cover(top.getType('form')[0].config)) {
              this.cover.insert(this.launchController.bind(this, top));
            } else {
              this.launchController(top);
            }
            this.prioritizedConfig.splice(0, 1);
          } else {
            break;
          }
        } while (this.prioritizedConfig.length);
      }
    },
    destroyController: function (id, complete, abrupt) {
      var controller = this.controllers[id];
      if (controller) {
        delete this.controllers[id];
        if (this.showQueue.state(controller) < 2 || abrupt) {
          this.showQueue.closeIf(controller, function () {
          }, true);
          controller.destroy(complete);
        } else {
          this.showQueue.closeIf(controller, function () {
            controller.destroy(complete);
          });
        }
      }
    },
    destroyControllersNotPresent: function (config) {
      var ids = [];
      var l = config.length;
      while (l--)
        ids.push(String(config[l].campaignId));
      var campaignId;
      for (campaignId in this.controllers) {
        if (this.controllers.hasOwnProperty(campaignId) && ids.indexOf(campaignId) < 0) {
          this.destroyController(campaignId, true);
        }
      }
    },
    // API
    triggerOnClick: function (id, onlyShowPreloaded) {
      var controller = this.controllers[id];
      if (controller) {
        if (onlyShowPreloaded && this.storage.isSessionClosed(controller.id))
          return;
        controller.config.smartIndex = 0;
      }
      if (controller && !controller.config.ready) {
        this.immediate = controller.id;
      } else if (!controller && !onlyShowPreloaded) {
        // load that controller forcefully
        var len = this.rawConfig.length;
        var config;
        while (len--) {
          config = this.rawConfig[len];
          if (config.CampaignId == id) {
            var profile = getRenderMode(config);
            if (profile > CONST.PROFILE.IGNORE) {
              config.hiddenSleeknote = true;
              config.SplitTestId = '';
              this.addSleekNotes(true, [config], true);
              win.setTimeout(function () {
                this.triggerOnClick(id);
              }.bind(this), 0);
            }
            break;
          }
        }
      } else if (controller) {
        controller.tameTeaser();
        controller.processOpenTrigger('manual');
        //TODO AB - step type set in editor
        this.showQueue.now(controller, 'open', 'form', true);
      } else {
        console.warn && console.warn('can not show toggler onlyShowPreloaded:' + onlyShowPreloaded + ' id:', id);
      }
    },
    siteDataTriggerIf: function () {
      this.rawConfig.forEach(function (conf) {
        var siteDataTrigger = conf.rules.triggers.filter(function (trigger) {
          return trigger.type == 6;
        });
        if (siteDataTrigger.length && siteDataTrigger[0].some(function (match) {
            return this.siteDataStorage.matchSessionProperty(match.property, match.type, match.value);
          })) {
          this.triggerOnClick(conf.CampaignId, false);
        }
      }, this);
    },
    // remove this in V4
    getFormCurrent: function (id) {
      debug('getFormCurrent');
      var controller = this.controllers[id];
      return controller && controller.notes.form.config.current;
    },
    reposition: function (hard) {
      //console.log('reposition');
      this.showQueue.repositionIf(undefined, hard);
    },
    setConfig: function (id, stepName, props) {
      id || (id = Object.keys(this.controllers)[0]);
      var controller = this.controllers[id];
      var note = controller && controller.notes[stepName];
      if (!note || note.config.profile != CONST.PROFILE.MOBILE)
        return;
      note.applyConfig(props);  //note.onResize();
    },
    // 				switchEmulation: function(on) {
    // 					this.emulate = on;
    // 				},
    //
    // 		renderBot: function (id, botData) {
    // 			var controller = this.controllers[id];
    // 			return controller && controller.notes.form && controller.notes.form.renderBot(botData);
    // 		},
    // end remove
    loadNoteImages: function (config, andThen) {
      var manager = this;
      function next() {
        win.setTimeout(andThen, 0);
      }
      var noteImages = [];
      if (U.typeStr(config) == 'string') {
        // just a src to support editor
        noteImages = [{ src: config }];
      } else {
        noteImages = U.slice(config.boxNode.querySelectorAll('img')).map(function (img) {
          return img.src;
        }).concat(U.slice(config.boxNode.querySelectorAll('[style*="background-image"]')).map(function (node) {
          return node.style.backgroundImage.slice(4, -1).replace(/"/g, '');
        })).filter(function (src) {
          return !U.empty(src) && U.empty(manager.noteImages.filter(function (img) {
            return ~img.src.indexOf(src);
          }));
        }).map(function (src) {
          return { src: src };
        });
      }
      var imagesLeft = noteImages.length;
      function areImagesLoaded() {
        imagesLeft -= 1;
        if (imagesLeft <= 0) {
          next();
        }
      }
      if (imagesLeft) {
        noteImages.forEach(function (data, i) {
          var img = new win.Image();
          img.onload = function (data) {
            data.width = this.naturalWidth || this.width;
            data.height = this.naturalHeight || this.height;
            areImagesLoaded();
            manager.noteImages.push(data);
          }.bind(img, noteImages[i]);
          img.onerror = areImagesLoaded;
          img.src = (~data.src.indexOf('//') ? '' : config.base) + data.src;
        });
      } else {
        next();
      }
    },
    command: function (operation, id, noteName) {
      //console.log('NM', operation, id, noteName);
      var controller = this.controllers[id];
      switch (operation) {
      case 'visibleNotes':
        return Object.keys(this.showQueue.visibles).map(function (campaignId) {
          var entry = this.showQueue.visibles[campaignId];
          return entry.controller.notes[entry.noteName];
        }, this);
      case 'hasCover':
        return this.cover && this.cover.config.current == 'open';
      case 'reset':
        var prop;
        for (prop in this.controllers) {
          win.clearTimeout(this.controllers[prop].timer);
        }
        return this.showQueue.reset(id);
      case 'add':
        if (noteName)
          U.extend(SleekNote.CustomInitSettings, noteName);
        return this.addSleekNotes(false, id, true);
      case 'remove':
        return this.destroyController(id, true, noteName);
      case 'querySelectorAll':
        var res = controller ? controller.querySelectorAll(noteName) : [];
        //if ( !res.length ) console.log(operation, id, noteName)
        return res;
      case 'close':
        // closeIf does not need controller to be specified
        this.showQueue.closeIf(controller, noteName, arguments[3]);
        return true;
      case 'hide':
        this.showQueue.closeIf(controller, noteName, true);
        return true;
      case 'state':
        var position = -1;
        var note;
        var show = this.showQueue.state(controller);
        if (controller) {
          position = controller.getType('form')[0].config.position;
          if (show) {
            note = this.showQueue.visibles[controller.id].noteName;
          }
        }
        return {
          note: note,
          show: show,
          position: position
        };
      case 'onafterrender':
        if (controller)
          controller.onafterrender();
        return;
      }
      if (!controller || !controller.config.ready) {
        //console.log('no controller', Object.keys(this.controllers), id);
        return;
      }
      var note = controller.notes[noteName];
      //console.log(operation, id, noteName);
      switch (operation) {
      case 'rerender':
        note.rerender(arguments[3]);
        note.onafterrender();
        return true;
      case 'callExternal':
        return note && note.callExternal.apply(note, Array.prototype.slice.call(arguments, 3));
      case 'config':
        return note.applyConfig(arguments[3]);
      case 'images':
        return note.config.images;
      case 'purpose':
        //controller.setPurpose(noteName);
        return;
      case 'trigger':
      case 'launch':
        this.triggerOnClick(id, noteName);
        break;
      case 'visibility':
        controller.setVisibility(noteName, arguments[3]);
        return true;
      case 'open':
      case 'reveal':
        if (note) {
          if (arguments[3] !== undefined) {
            this.command('position', id, noteName, arguments[3]);
          }
          this.showQueue.now(controller, operation, noteName, false, arguments[4]);
        }
        return true;
      case 'maximize':
      case 'minimize':
        if (!noteName) {
          var id = controller.config.campaignId;
          if (id in this.showQueue.visibles)
            noteName = this.showQueue.visibles[id].noteName;
        }
        note = controller.notes[noteName];
        if (note)
          this.showQueue.now(controller, operation, noteName);
        return true;
      case 'current':
        // console.log(note && note.config.current);
        return note && note.config.current;
      case 'next':
        // console.log(note && note.config.current);
        return note && note.config.next;
      case 'dimensions':
        return note ? note.dimensions() : {};
      case 'hasToggle':
        return note && note.toggleDivider();
      case 'position':
        var position = arguments[3];
        Object.keys(controller.notes).forEach(function (name) {
          controller.notes[name].applyConfig({ position: position });
        });
        return true;
      }
    }
  };
  return NotesManager;
}(browser, utils, css, note_controller2, show_queue2, location, tracker, preprocessor, core_common, constants, badge, cover_screen, storage_cache, event_emitter, site_data, behaviour, rrhandler, rendermode);
session_tracker = function (U) {
  var win = this;
  var doc = win.document;
  // Hook up events for session listening
  var idleTimeOut = 1800;
  //default is 30 minutes
  var sessionEndCallback = null;
  var sessionResetCallback = null;
  var localStorageKey = 'sn_global_countdown_last_reset_timestamp';
  var idleSecondsTimer = 0;
  var inMemlastResetTimeStamp = 0;
  var localStorage;
  var activityThrottleInterval = 1000 * 60;
  // do something once per minute
  var idleTimeInterval = activityThrottleInterval;
  function GetLastResetTimeStamp() {
    var lastResetTimeStamp = 0;
    if (localStorage) {
      lastResetTimeStamp = parseInt(localStorage[localStorageKey], 10);
      if (isNaN(lastResetTimeStamp) || lastResetTimeStamp < 0)
        lastResetTimeStamp = new Date().getTime();
    } else {
      lastResetTimeStamp = inMemlastResetTimeStamp;
    }
    return lastResetTimeStamp;
  }
  function HasTimeStamp() {
    return localStorage ? +localStorage[localStorageKey] || 0 : inMemlastResetTimeStamp;
  }
  function SetLastResetTimeStamp(timeStamp) {
    if (localStorage) {
      //console.log(1);
      //console.trace();
      localStorage[localStorageKey] = timeStamp;
    } else {
      inMemlastResetTimeStamp = timeStamp;
    }
  }
  var ResetTimeActivity = U.throttle(activityThrottleInterval, function () {
    CheckIdleTime('activity');
  });
  /*
  	function ResetTimeActivity() {
  		// Need to check if expired before restarting timer
  		CheckIdleTime('activity');
  	}
  	*/
  function SessionCleanup() {
    //Only close if timer running ... if not timer then already closed and don't need to call again
    if (idleSecondsTimer) {
      win.clearInterval(idleSecondsTimer);
      idleSecondsTimer = 0;
      if (sessionEndCallback)
        sessionEndCallback();
    }
  }
  // Always start a new session
  function SessionStart() {
    if (sessionResetCallback)
      sessionResetCallback();
    if (!idleSecondsTimer) {
      idleSecondsTimer = win.setInterval(CheckIdleTimeInterval, idleTimeInterval);
    }
  }
  // Start new session only if there isn't a session running
  function NewSessionIf() {
    if (!idleSecondsTimer) {
      if (sessionResetCallback)
        sessionResetCallback();
      idleSecondsTimer = win.setInterval(CheckIdleTimeInterval, idleTimeInterval);
    }
  }
  function ResetTime(event) {
    switch (event) {
    case 'newSession':
      SessionStart();
      break;
    case 'newSessionIf':
      NewSessionIf();
      break;
    case 'endSession':
      SessionCleanup();
      break;
    case 'restartSession':
      SessionCleanup();
      SessionStart();
      break;
    }
    SetLastResetTimeStamp(new Date().getTime());
  }
  function CheckIdleTimeInterval() {
    CheckIdleTime('interval');
  }
  function CheckIdleTime(source, firstRun) {
    var currentTimeStamp = new Date().getTime();
    var lastResetTimeStamp = GetLastResetTimeStamp();
    var secondsDiff = Math.floor((currentTimeStamp - lastResetTimeStamp) / 1000);
    if (secondsDiff <= 0) {
      secondsDiff = 0;
    }
    if (secondsDiff >= idleTimeOut) {
      //expired
      switch (source) {
      case 'start':
      case 'activity':
        ResetTime('restartSession');
        break;
      case 'interval':
        ResetTime('endSession');
        break;
      }
    } else {
      // not expired
      switch (source) {
      case 'activity':
        ResetTime('newSessionIf');
        break;
      case 'start':
        if (firstRun) {
          ResetTime('newSession');
        } else {
          ResetTime('newSessionIf');
        }
        break;
      case 'interval':
        // do nothing
        break;
      }
    }
  }
  function SessionTracker() {
    try {
      localStorage = win.localStorage;
    } catch (ex) {
    }
  }
  SessionTracker.prototype = {
    start: function (idleTimeInMin, endCallback, resetCallback) {
      var firstRun = !HasTimeStamp();
      inMemlastResetTimeStamp = new Date().getTime();
      U.listener(doc, 'add', ResetTimeActivity)('click')('mousemove')('keypress');
      U.listener(win, 'add', ResetTimeActivity)('load');
      idleTimeOut = idleTimeInMin * 60;
      sessionEndCallback = endCallback;
      sessionResetCallback = resetCallback;
      idleSecondsTimer = win.setInterval(CheckIdleTimeInterval, idleTimeInterval);
      CheckIdleTime('start', firstRun);
    }
  };
  return SessionTracker;
}(utils);
(function (B, SleekNote, U, NotesManager, SessionTracker, StorageCache, layout) {
  var win = this;
  var doc = win.document;
  /* jshint ignore:start */
  if (Array.prototype.toJSON)
    delete Array.prototype.toJSON;
  /* jshint ignore:end */
  function custom(prop) {
    return SleekNote.CustomInitSettings && SleekNote.CustomInitSettings[prop];
  }
  var bootStorage = StorageCache.create({ useLocalStorage: false });
  var sessionTracker = new SessionTracker();
  sessionTracker.start(30, function () {
    bootStorage.endSessionTime();
  }, function () {
    bootStorage.startSessionTime();
  });
  if (B.is.quirks) {
    console.warn('This web-page runs in Quirks Mode (usually that means DOCTYPE is missing), therefore sleeknotes may not shown correctly.');
  }
  // detect outright if we need to run at all
  if (B.is.other || B.is.ie && B.is.version < (custom('ie') || 11)) {
    console.warn('This browser is not supported by Sleeknote.');
    return;
  }
  if (!Array.isArray(SleekNote.SleekNotes) || !SleekNote.SleekNotes.length) {
    // nothing to do (possibly second instance of the script)
    // 		console.warn('nothing to do');
    // 		return;
    // this allows empty run
    SleekNote.SleekNotes = [];
  }
  //If the siteData array isn't setup set it up
  win.sleeknoteSiteData || (win.sleeknoteSiteData = []);
  //Legacy call
  this.SleekNote.addSiteData = function (name, value) {
    var obj = {};
    obj[name] = value;
    win.sleeknoteSiteData.push(obj);
  };
  var noteManager;
  var timeout = 100;
  var start = +new Date();
  var me = this;
  var launch = function () {
    win.setTimeout(function () {
      layout.initialize();
      win.setTimeout(function () {
        noteManager = new NotesManager(SleekNote.SleekNotes, SleekNote.editor && win);
        me.SleekNote.triggerOnclick = me.SleekNote.triggerOnClick = noteManager.triggerOnClick;
        me.SleekNote.triggerOnClick = noteManager.triggerOnClick;
        if (SleekNote.debug) {
          me.q = noteManager.showQueue;
          me.t = noteManager.triggerOnClick;
          me.n = noteManager;
        }
      }, 0);
    }, 0);
  };
  var hasGeoCondition = SleekNote.SleekNotes.some(function (notes) {
    return notes && notes.rules && notes.rules.groups && notes.rules.groups.some(function (group) {
      return group.conditions && group.conditions.some(function (cond) {
        return cond && cond.type == 11;
      });
    });
  });
  var hasStoredGeoInfo = bootStorage.getGeoInfo();
  var waitingForGeoInfo = false;
  if (hasGeoCondition && !hasStoredGeoInfo) {
    waitingForGeoInfo = true;
    U.httpRequest('GET', 'https://workers-203821.appspot.com/geo/api/v1.0/getJSON?getgeoids', undefined, function (data) {
      try {
        var geoData = JSON.parse(data.response);
      } catch (e) {
        return;
      }
      if (geoData.geoname_id_list) {
        bootStorage.setGeoInfo({
          lt: geoData.location.latitude,
          lg: geoData.location.longitude,
          gi: geoData.geoname_id_list
        });
      }
    }, function (data) {
    });
  }
  var hasIPAddressCondition = SleekNote.SleekNotes.some(function (notes) {
    return notes && notes.rules && notes.rules.groups && notes.rules.groups.some(function (group) {
      return group.conditions && group.conditions.some(function (cond) {
        return cond && cond.type == 15;
      });
    });
  });
  var hasIPAddressInfo = bootStorage.getIPAddress();
  var waitingForIPAddressInfo = false;
  if (hasIPAddressCondition && !hasIPAddressInfo) {
    waitingForIPAddressInfo = true;
    U.httpRequest('GET', 'https://us-central1-mimir-181311.cloudfunctions.net/get_ip', undefined, function (data) {
      try {
        var geoData = JSON.parse(data.response);
      } catch (e) {
        return;
      }
      if (geoData.userIP) {
        bootStorage.setIPAddress(geoData.userIP);
      }
    }, function (data) {
    });
  }
  var detect = function () {
    // prioritizing custom loader
    if (custom('loading') && !custom('loading')())
      return;
    // to prevent custom loading hooks, if just empty page, then wait
    if (!doc.body.clientWidth)
      return;
    return (!waitingForGeoInfo || bootStorage.getGeoInfo() !== undefined) && (!waitingForIPAddressInfo || bootStorage.getIPAddress() !== undefined);
  };
  var isLoaded = function () {
    if (detect(U) || +new Date() - start > 10000) {
      launch();
    } else {
      this.setTimeout(isLoaded, timeout);
    }
  }.bind(this);
  isLoaded();  //this.setTimeout(isLoaded, timeout);
}(browser, core_common, utils, notes_manager, session_tracker, storage_cache, layout2));
core_boot = undefined;
}());